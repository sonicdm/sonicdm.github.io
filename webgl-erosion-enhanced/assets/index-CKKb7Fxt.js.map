{"version":3,"file":"index-CKKb7Fxt.js","sources":["../../src/globals.ts","../../src/rendering/gl/Drawable.ts","../../src/geometry/Square.ts","../../src/geometry/Plane.ts","../../src/rendering/gl/OpenGLRenderer.ts","../../src/Camera.ts","../../src/controls-config.ts","../../src/settings.ts","../../src/brush-palette.ts","../../src/gui/gui-setup.ts","../../src/utils/raycast.ts","../../src/utils/bvh-raycast.ts","../../src/simulation/simulation-state.ts","../../src/brush-handler.ts","../../src/utils/water-sources.ts","../../src/events/event-handlers.ts","../../src/utils/terrain-geometry-builder.ts","../../src/simulation/texture-management.ts","../../src/utils/heightmap-loader.ts","../../src/utils/uniform-cache.ts","../../src/rendering/render-utils.ts","../../src/rendering/gl/uniforms/TerrainUniforms.ts","../../src/rendering/gl/uniforms/BrushUniforms.ts","../../src/rendering/gl/uniforms/SimulationUniforms.ts","../../src/rendering/gl/ShaderProgram.ts","../../src/shaders/terrain-vert.glsl?raw","../../src/shaders/terrain-frag.glsl?raw","../../src/shaders/flat-vert.glsl?raw","../../src/shaders/flat-frag.glsl?raw","../../src/shaders/quad-vert.glsl?raw","../../src/shaders/initial-frag.glsl?raw","../../src/shaders/flow-frag.glsl?raw","../../src/shaders/alterwaterhight-frag.glsl?raw","../../src/shaders/sediment-frag.glsl?raw","../../src/shaders/sediadvect-frag.glsl?raw","../../src/shaders/maccormack-frag.glsl?raw","../../src/shaders/rain-frag.glsl?raw","../../src/shaders/eva-frag.glsl?raw","../../src/shaders/average-frag.glsl?raw","../../src/shaders/clean-frag.glsl?raw","../../src/shaders/water-vert.glsl?raw","../../src/shaders/water-frag.glsl?raw","../../src/shaders/thermalterrainflux-frag.glsl?raw","../../src/shaders/thermalapply-frag.glsl?raw","../../src/shaders/maxslippageheight-frag.glsl?raw","../../src/shaders/shadowmap-vert.glsl?raw","../../src/shaders/shadowmap-frag.glsl?raw","../../src/shaders/sceneDepth-frag.glsl?raw","../../src/shaders/combine-frag.glsl?raw","../../src/shaders/bilateralBlur-frag.glsl?raw","../../src/shaders/veladvect-frag.glsl?raw","../../src/rendering/shader-factory.ts","../../src/main.ts"],"sourcesContent":["\nexport var gl: WebGL2RenderingContext;\nexport function setGL(_gl: WebGL2RenderingContext) {\n  gl = _gl;\n}\n","import {gl} from '../../globals';\n\nabstract class Drawable {\n  count: number = 0;\n\n  bufIdx: WebGLBuffer;\n  bufPos: WebGLBuffer;\n  bufNor: WebGLBuffer;\n  bufUv : WebGLBuffer;\n\n  idxBound: boolean = false;\n  posBound: boolean = false;\n  norBound: boolean = false;\n  uvBound : boolean = false;\n\n  mode = gl.TRIANGLES;\n\n  abstract create() : void;\n\n  destory() {\n    gl.deleteBuffer(this.bufIdx);\n    gl.deleteBuffer(this.bufPos);\n    gl.deleteBuffer(this.bufNor);\n    gl.deleteBuffer(this.bufUv);\n  }\n\n  generateIdx() {\n    this.idxBound = true;\n    this.bufIdx = gl.createBuffer();\n  }\n\n  generatePos() {\n    this.posBound = true;\n    this.bufPos = gl.createBuffer();\n  }\n\n  generateNor() {\n    this.norBound = true;\n    this.bufNor = gl.createBuffer();\n  }\n\n  generateUv(){\n    this.uvBound = true;\n    this.bufUv = gl.createBuffer();\n  }\n\n  bindIdx(): boolean {\n    if (this.idxBound) {\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufIdx);\n    }\n    return this.idxBound;\n  }\n\n  bindPos(): boolean {\n    if (this.posBound) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.bufPos);\n    }\n    return this.posBound;\n  }\n\n  bindNor(): boolean {\n    if (this.norBound) {\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.bufNor);\n    }\n    return this.norBound;\n  }\n\n  bindUv(): boolean {\n    if(this.uvBound){\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.bufUv);\n    }\n    return this.uvBound;\n  }\n\n  elemCount(): number {\n    return this.count;\n  }\n\n  drawMode(): GLenum {\n    return this.mode;\n  }\n\n  setDrawMode(m : GLenum){\n    this.mode = m;\n  }\n};\n\nexport default Drawable;\n","import {vec3, vec4} from 'gl-matrix';\nimport Drawable from '../rendering/gl/Drawable';\nimport {gl} from '../globals';\n\nclass Square extends Drawable {\n  indices: Uint32Array;\n  positions: Float32Array;\n  normals: Float32Array;\n  center: vec4;\n\n  constructor(center: vec3) {\n    super(); // Call the constructor of the super class. This is required.\n    this.center = vec4.fromValues(center[0], center[1], center[2], 1);\n  }\n\n  create() {\n\n  this.indices = new Uint32Array([0, 1, 2,\n                                  0, 2, 3]);\n  this.normals = new Float32Array([0, 0, 1, 0,\n                                   0, 0, 1, 0,\n                                   0, 0, 1, 0,\n                                   0, 0, 1, 0]);\n  this.positions = new Float32Array([-1, -1, 0.99999, 1,\n                                     1, -1, 0.99999, 1,\n                                     1, 1, 0.99999, 1,\n                                     -1, 1, 0.99999, 1]);\n\n    this.generateIdx();\n    this.generatePos();\n    this.generateNor();\n\n    this.count = this.indices.length;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufIdx);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.bufNor);\n    gl.bufferData(gl.ARRAY_BUFFER, this.normals, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.bufPos);\n    gl.bufferData(gl.ARRAY_BUFFER, this.positions, gl.STATIC_DRAW);\n\n    console.log(`Created square`);\n  }\n};\n\nexport default Square;\n","import {vec2, vec3, vec4} from 'gl-matrix';\nimport Drawable from '../rendering/gl/Drawable';\nimport {gl} from '../globals';\n\nclass Plane extends Drawable {\n  indices: Uint32Array;\n  positions: Float32Array;\n  normals: Float32Array;\n  uvs: Float32Array;\n  center: vec3;\n  scale: vec2;\n  subdivs: number; // 2^subdivs is how many squares will compose the plane; must be even.\n\n  constructor(center: vec3, scale: vec2, subdivs: number) {\n    super(); // Call the constructor of the super class. This is required.\n    this.center = vec3.fromValues(center[0], center[1], center[2]);\n    this.scale = scale;\n    this.subdivs = subdivs + subdivs % 2; // Ensures the number is even, rounds up.\n  }\n\n  create() {\n\n    let width: number = Math.pow(2, this.subdivs / 2);\n    let normalize: number = 1.0 / width;\n    this.positions = new Float32Array((width + 1) * (width + 1) * 4);\n    this.normals = new Float32Array((width + 1) * (width + 1) * 4);\n    this.uvs = new Float32Array((width + 1) * (width + 1) * 2);\n    this.indices = new Uint32Array(width * width * 6); // NxN squares, each square is two triangles, each triangle is three indices\n\n    let posIdx = 0;\n    for(let x = 0; x <= width; ++x) {\n      for(let z = 0; z <= width; ++z) {\n        // Make a strip of vertices along Z with the current X coord\n        this.normals[posIdx] = 0;\n        this.positions[posIdx++] = x * normalize * this.scale[0] + this.center[0] - this.scale[0] * 0.5;\n        this.normals[posIdx] = 1;\n        this.positions[posIdx++] = 0 + this.center[1];\n        this.normals[posIdx] = 0;\n        this.positions[posIdx++] = z * normalize * this.scale[1] + this.center[2] - this.scale[1] * 0.5;\n        this.normals[posIdx] = 0;\n        this.positions[posIdx++] = 1;\n      }\n    }\n\n    let uvIdx = 0;\n    for(let x = 0; x <= width; ++x) {\n        for(let z = 0; z <= width; ++z) {\n            // Make a strip of vertices along Z with the current X coord\n            this.uvs[uvIdx++] = x * normalize;\n            this.uvs[uvIdx++] = z * normalize;\n        }\n    }\n\n    let indexIdx = 0;\n    // Make the squares out of indices\n    for(let i = 0; i < width; ++i) { // X iter\n      for(let j = 0; j < width; ++j) { // Z iter\n        this.indices[indexIdx++] = j + i * (width + 1);\n        this.indices[indexIdx++] = j + 1 + i * (width + 1);\n        this.indices[indexIdx++] = j + (i + 1) * (width + 1);\n\n        this.indices[indexIdx++] = j + 1 + i * (width + 1);\n        this.indices[indexIdx++] = j + (i + 1) * (width + 1);\n        this.indices[indexIdx++] = j + 1 + (i + 1) * (width + 1);\n      }\n    }\n\n    this.generateUv()\n    this.generateIdx();\n    this.generatePos();\n    this.generateNor();\n\n    this.count = this.indices.length;\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.bufIdx);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.bufNor);\n    gl.bufferData(gl.ARRAY_BUFFER, this.normals, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.bufPos);\n    gl.bufferData(gl.ARRAY_BUFFER, this.positions, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER,this.bufUv);\n    gl.bufferData(gl.ARRAY_BUFFER,this.uvs,gl.STATIC_DRAW);\n\n    console.log(`Created plane`);\n  }\n};\n\nexport default Plane;\n","import {mat4, vec4} from 'gl-matrix';\nimport Drawable from './Drawable';\nimport Camera from '../../Camera';\nimport {gl} from '../../globals';\nimport ShaderProgram from './ShaderProgram';\nimport {isNumber} from \"util\";\n\n// In this file, `gl` is accessible because it is imported above\nclass OpenGLRenderer {    counter : number;\n  constructor(public canvas: HTMLCanvasElement) {\n  this.counter = 0;\n  }\n\n  setClearColor(r: number, g: number, b: number, a: number) {\n    gl.clearColor(r, g, b, a);\n  }\n\n  setSize(width: number, height: number) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n  }\n\n  clear() {\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n  }\n\n  render(camera: Camera, prog: ShaderProgram, drawables: Array<Drawable>) {\n    let model = mat4.create();\n    let viewProj = mat4.create();\n    let color = vec4.fromValues(1, 0, 0, 1);\n\n    mat4.identity(model);\n    mat4.multiply(viewProj, camera.projectionMatrix, camera.viewMatrix);\n    prog.setModelMatrix(model);\n    prog.setViewProjMatrix(viewProj);\n    prog.setEyeRefUp(camera.position, camera.target, camera.up);\n    prog.setDimensions(this.canvas.width,this.canvas.height);\n\n    for (let drawable of drawables) {\n      prog.draw(drawable);\n    }\n  }\n};\n\nexport default OpenGLRenderer;\n","import * as THREE from 'three';\n// @ts-ignore\nimport { PerspectiveCamera } from 'three';\nimport {OrbitControls} from \"three/examples/jsm/controls/OrbitControls\";\n\nimport {vec3, mat4} from 'gl-matrix';\n// @ts-ignore\n\nimport {Vector3} from \"three\";\nimport { ControlsConfig } from './controls-config';\n\n\n\n\nclass Camera {\n\n  threeControls : any;\n  threeCamera : any;\n\n  worldUp : vec3 = vec3.fromValues(0,1,0);\n  projectionMatrix: mat4 = mat4.create();\n  viewMatrix: mat4 = mat4.create();\n  fovy: number = 45;\n  aspectRatio: number = 1;\n  near: number = 0.01;\n  far: number = 500;\n  position: vec3 = vec3.create();\n  direction: vec3 = vec3.create();\n  target: vec3 = vec3.create();\n  up: vec3 = vec3.fromValues(0.0, 1.0, 0.0);\n  counter : number = 0;\n\n  tposition : Vector3 = new Vector3(0,0,0);\n  tdirection : Vector3 = new Vector3(0,0,0);\n  tup : Vector3 = new  Vector3(0,0,0);\n\n  // Key tracking for WASD movement\n  private pressedKeys: Set<string> = new Set();\n  private lastUpdateTime: number = performance.now();\n  \n  // Velocity tracking for smooth acceleration/deceleration\n  private velocity: vec3 = vec3.create();\n  \n  // Smoothed deltaTime for consistent movement at variable frame rates\n  private smoothedDeltaTime: number = 0.016; // Start with ~60 FPS (16ms)\n  private readonly deltaTimeSmoothingFactor: number = 0.05; // EMA factor (lower = more smoothing, reduced from 0.1 for more stability)\n\n  constructor(position: vec3, target: vec3, cameraConfig?: ControlsConfig['camera'], brushUsesLeftClick?: boolean) {\n\n\n    vec3.subtract(this.direction, target, position);\n\n    this.tposition = new Vector3(position[0], position[1],position[2]);\n    this.tdirection = new Vector3(this.direction[0], this.direction[1],this.direction[2]);\n    this.tup = new Vector3(this.up[0], this.up[1],this.up[2]);\n\n\n\n    this.threeCamera = new PerspectiveCamera(this.fovy,this.aspectRatio,this.near,this.far);\n    this.threeCamera.position.set(position[0],position[1],position[2]);\n    this.threeControls = new OrbitControls(this.threeCamera, document.getElementById('canvas'));\n\n    // Apply camera configuration if provided\n    if (cameraConfig) {\n        // Configure mouse button mappings\n        const mouseButtons: any = {\n            LEFT: null,\n            MIDDLE: null,\n            RIGHT: null\n        };\n        // If brush uses left click, ensure LEFT is disabled for camera\n        if (brushUsesLeftClick) {\n            console.log('[DEBUG] Camera: Disabling LEFT button for OrbitControls (brush uses it)');\n            mouseButtons.LEFT = null;\n        }\n        // Set rotate button (unless it's LEFT and brush uses it)\n        if (cameraConfig.rotateButton) {\n            if (!brushUsesLeftClick || cameraConfig.rotateButton !== 'LEFT') {\n                mouseButtons[cameraConfig.rotateButton] = THREE.MOUSE.ROTATE;\n            }\n        }\n        // Set pan button (unless it's LEFT and brush uses it)\n        if (cameraConfig.panButton) {\n            if (!brushUsesLeftClick || cameraConfig.panButton !== 'LEFT') {\n                mouseButtons[cameraConfig.panButton] = THREE.MOUSE.PAN;\n            }\n        }\n        this.threeControls.mouseButtons = mouseButtons;\n        console.log('[DEBUG] Camera: OrbitControls mouseButtons set to:', mouseButtons);\n\n        // Apply speed settings\n        this.threeControls.rotateSpeed = cameraConfig.rotateSpeed;\n        this.threeControls.zoomSpeed = cameraConfig.zoomSpeed;\n        this.threeControls.panSpeed = cameraConfig.panSpeed;\n\n        // Apply enable/disable settings\n        this.threeControls.enableRotate = cameraConfig.enableRotate;\n        this.threeControls.enablePan = cameraConfig.enablePan;\n        this.threeControls.enableZoom = cameraConfig.enableZoom;\n\n        // Apply damping settings\n        this.threeControls.enableDamping = cameraConfig.enableDamping;\n        this.threeControls.dampingFactor = cameraConfig.dampingFactor;\n    } else {\n        // Default settings\n        this.threeControls.enableDamping = true;\n        this.threeControls.dampingFactor = 0.08;\n    }\n    \n    // Disable OrbitControls' built-in keyboard controls (we handle WASD ourselves)\n    this.threeControls.keys = {\n        LEFT: null,\n        UP: null,\n        RIGHT: null,\n        BOTTOM: null\n    };\n    console.log( this.threeCamera.position);\n\n\n\n    this.threeControls.update();\n\n\n    vec3.add(this.target, this.position, this.direction);\n\n\n    let wd = new Vector3();\n    this.threeCamera.getWorldDirection(wd);\n    this.direction = vec3.fromValues(wd.x,wd.y,wd.z);\n    this.position = vec3.fromValues(this.threeCamera.position.x,this.threeCamera.position.y,this.threeCamera.position.z);\n    vec3.add(this.target, this.position, this.direction);\n\n    let lookatVec = vec3.fromValues(0,0,0);\n    vec3.subtract(lookatVec,this.position, this.target);\n    let tmpRight = vec3.fromValues(0,0,0);\n    let camUp = vec3.fromValues(0,0,0);\n    vec3.cross(tmpRight, this.worldUp,lookatVec);\n    vec3.cross(camUp,tmpRight,lookatVec);\n    vec3.normalize(camUp,camUp);\n    vec3.scale(camUp,camUp,-1);\n\n    this.up = camUp;\n\n\n    mat4.lookAt(this.viewMatrix, this.position, this.target, vec3.fromValues(0,1,0));\n  }\n\n  setAspectRatio(aspectRatio: number) {\n    this.aspectRatio = aspectRatio;\n  }\n\n  updateProjectionMatrix() {\n    mat4.perspective(this.projectionMatrix, this.fovy, this.aspectRatio, this.near, this.far);\n  }\n\n  // Movement key tracking methods\n  addMovementKey(key: string): void {\n    this.pressedKeys.add(key.toLowerCase());\n  }\n\n  removeMovementKey(key: string): void {\n    this.pressedKeys.delete(key.toLowerCase());\n  }\n\n  isMovementKeyPressed(key: string): boolean {\n    return this.pressedKeys.has(key.toLowerCase());\n  }\n\n  // Update movement based on pressed keys with acceleration/deceleration\n  updateMovement(deltaTime: number, config: ControlsConfig['camera']): void {\n    if (!config.movement.enableWASD) {\n      return;\n    }\n\n\n    // Acceleration and deceleration constants (reduced for smoother movement at high frame rates)\n    // Further reduced for smoother movement at variable frame rates\n    const acceleration = 2.0;  // Units per second squared (reduced from 4.0 for smoother movement)\n    const deceleration = 3.0;   // Units per second squared (reduced from 6.0 for smoother stopping)\n    const maxSpeed = config.movement.moveSpeed;\n    const fastMaxSpeed = maxSpeed * (config.movement.fastMoveMultiplier || 3.0);\n\n    // Ensure camera matrix is up to date before calculating direction\n    // This is important at higher resolutions where matrix updates might be delayed\n    this.threeCamera.updateMatrixWorld();\n\n    // Calculate movement vectors using camera's world direction\n    const forward = vec3.create();\n    const right = vec3.create();\n    const up = vec3.create();\n    const desiredDirection = vec3.create();\n\n    // Get camera's forward direction in world space using getWorldDirection\n    // Cache the direction calculation to avoid inconsistencies\n    const threeForward = new Vector3();\n    this.threeCamera.getWorldDirection(threeForward);\n    \n    // Remove Y component for horizontal movement only\n    threeForward.y = 0;\n    const forwardLength = threeForward.length();\n    \n    // Check if forward vector is valid (not too small)\n    if (forwardLength < 0.001) {\n      // Camera is looking straight up/down, use last valid forward or default\n      // For now, use a default forward direction\n      threeForward.set(0, 0, -1);\n    } else {\n      threeForward.normalize();\n    }\n    \n    forward[0] = threeForward.x;\n    forward[1] = 0;\n    forward[2] = threeForward.z;\n    const forwardLen = vec3.length(forward);\n    if (forwardLen > 0.001) {\n      vec3.normalize(forward, forward);\n    } else {\n      vec3.set(forward, 0, 0, -1);\n    }\n\n    // Right vector is perpendicular to forward (strafe direction)\n    // Use forward crossed with world up to get proper right vector\n    // cross(forward, up) gives right, cross(up, forward) gives left\n    const threeRight = new Vector3();\n    const worldUpVec = new Vector3(0, 1, 0);\n    threeRight.crossVectors(threeForward, worldUpVec); // Fixed order: forward x up = right\n    threeRight.y = 0; // Keep horizontal\n    const rightLength = threeRight.length();\n    \n    if (rightLength < 0.001) {\n      // Fallback if forward is parallel to up - use perpendicular to forward\n      threeRight.set(-threeForward.z, 0, threeForward.x);\n      const fallbackLength = threeRight.length();\n      if (fallbackLength > 0.001) {\n        threeRight.normalize();\n      } else {\n        threeRight.set(1, 0, 0);\n      }\n    } else {\n      threeRight.normalize();\n    }\n    \n    right[0] = threeRight.x;\n    right[1] = 0;\n    right[2] = threeRight.z;\n    const rightLen = vec3.length(right);\n    if (rightLen > 0.001) {\n      vec3.normalize(right, right);\n    } else {\n      // Fallback: perpendicular to forward\n      right[0] = -forward[2];\n      right[1] = 0;\n      right[2] = forward[0];\n      const fallbackLen = vec3.length(right);\n      if (fallbackLen > 0.001) {\n        vec3.normalize(right, right);\n      } else {\n        vec3.set(right, 1, 0, 0);\n      }\n    }\n\n    // Up vector is world up for vertical movement\n    vec3.copy(up, this.worldUp);\n\n    // Build desired movement direction based on pressed keys\n    vec3.set(desiredDirection, 0, 0, 0);\n\n    // W = forward (horizontal, no pitch)\n    if (this.isMovementKeyPressed('w')) {\n      vec3.add(desiredDirection, desiredDirection, forward);\n    }\n    // S = backward\n    if (this.isMovementKeyPressed('s')) {\n      vec3.subtract(desiredDirection, desiredDirection, forward);\n    }\n    // A = strafe left\n    if (this.isMovementKeyPressed('a')) {\n      vec3.subtract(desiredDirection, desiredDirection, right);\n    }\n    // D = strafe right\n    if (this.isMovementKeyPressed('d')) {\n      vec3.add(desiredDirection, desiredDirection, right);\n    }\n\n    // Vertical movement (if enabled)\n    if (config.movement.enableVerticalMovement) {\n      if (this.isMovementKeyPressed(' ')) { // Space for up\n        vec3.add(desiredDirection, desiredDirection, up);\n      }\n      // Shift for down (only if not used as brush modifier - handled in event handlers)\n      if (this.isMovementKeyPressed('shift')) {\n        vec3.subtract(desiredDirection, desiredDirection, up);\n      }\n    }\n\n    // Normalize desired direction if there's any input\n    if (vec3.length(desiredDirection) > 0.001) {\n      vec3.normalize(desiredDirection, desiredDirection);\n    }\n\n    // Determine current max speed (fast mode if Shift is held)\n    const currentMaxSpeed = (this.isMovementKeyPressed('shift') && config.movement.fastMoveMultiplier > 1.0) \n      ? fastMaxSpeed \n      : maxSpeed;\n\n    // Calculate desired velocity\n    const desiredVelocity = vec3.create();\n    vec3.scale(desiredVelocity, desiredDirection, currentMaxSpeed);\n\n    // Calculate velocity change based on acceleration/deceleration\n    const velocityChange = vec3.create();\n    if (vec3.length(desiredDirection) > 0.001) {\n      // Accelerating towards desired direction\n      vec3.subtract(velocityChange, desiredVelocity, this.velocity);\n      const accelRate = acceleration * deltaTime;\n      vec3.scale(velocityChange, velocityChange, Math.min(accelRate, 1.0));\n    } else {\n      // Decelerating (no input)\n      const decelRate = deceleration * deltaTime;\n      vec3.scale(velocityChange, this.velocity, -Math.min(decelRate, 1.0));\n    }\n\n    // Update velocity\n    vec3.add(this.velocity, this.velocity, velocityChange);\n\n    // Clamp velocity to max speed\n    const currentSpeed = vec3.length(this.velocity);\n    if (currentSpeed > currentMaxSpeed) {\n      vec3.scale(this.velocity, this.velocity, currentMaxSpeed / currentSpeed);\n    }\n\n\n    // Apply velocity to both camera position AND target to maintain orbit relationship\n    // This is the key: move both together so the camera maintains its relative position\n    const movementDelta = vec3.create();\n    vec3.scale(movementDelta, this.velocity, deltaTime);\n    \n    \n    // Move both camera and target together\n    this.threeCamera.position.x += movementDelta[0];\n    this.threeCamera.position.y += movementDelta[1];\n    this.threeCamera.position.z += movementDelta[2];\n    \n    this.threeControls.target.x += movementDelta[0];\n    this.threeControls.target.y += movementDelta[1];\n    this.threeControls.target.z += movementDelta[2];\n\n  }\n\n  update(cameraConfig?: ControlsConfig['camera']) {\n    // Calculate deltaTime for frame-rate independent movement\n    const currentTime = performance.now();\n    let rawDeltaTime = (currentTime - this.lastUpdateTime) / 1000.0; // Convert to seconds\n    this.lastUpdateTime = currentTime;\n\n    // Clamp raw deltaTime to prevent extreme values\n    const maxDeltaTime = 0.1; // Maximum 100ms per frame (10 FPS minimum)\n    rawDeltaTime = Math.min(rawDeltaTime, maxDeltaTime);\n    \n    // Smooth deltaTime using exponential moving average to reduce jerky movement\n    // This is especially important at high resolutions where frame times can vary significantly\n    this.smoothedDeltaTime = this.smoothedDeltaTime * (1.0 - this.deltaTimeSmoothingFactor) + \n                            rawDeltaTime * this.deltaTimeSmoothingFactor;\n    \n    // Use smoothed deltaTime for movement calculations\n    const deltaTime = this.smoothedDeltaTime;\n\n    // Update movement before OrbitControls (so movement happens first)\n    if (cameraConfig) {\n      this.updateMovement(deltaTime, cameraConfig);\n    }\n\n    // Update OrbitControls AFTER movement to ensure it respects the new positions\n    this.threeControls.update();\n\n    this.threeCamera.updateMatrixWorld();\n\n    let wd = new Vector3();\n    this.threeCamera.getWorldDirection(wd);\n    this.direction = vec3.fromValues(wd.x,wd.y,wd.z);\n    this.position = vec3.fromValues(this.threeCamera.position.x,this.threeCamera.position.y,this.threeCamera.position.z);\n    vec3.add(this.target, this.position, this.direction);\n\n    let lookatVec = vec3.fromValues(0,0,0);\n    vec3.subtract(lookatVec,this.position, this.target);\n    let tmpRight = vec3.fromValues(0,0,0);\n    let camUp = vec3.fromValues(0,0,0);\n    vec3.cross(tmpRight, this.worldUp,lookatVec);\n    vec3.cross(camUp,tmpRight,lookatVec);\n    vec3.normalize(camUp,camUp);\n    vec3.scale(camUp,camUp,-1);\n    this.up = camUp;\n\n    this.counter ++;\n\n    mat4.lookAt(this.viewMatrix, this.position, this.target, vec3.fromValues(0,1,0));\n  }\n};\n\nexport default Camera;\n","// Controls configuration file - easily rebind keys here\nexport interface ControlsConfig {\n    keys: {\n        brushActivate: string;      // Key OR mouse button ('LEFT', 'MIDDLE', 'RIGHT') to hold for brush painting\n        permanentWaterSource: string; // Key to toggle permanent water source\n        removePermanentSource: string; // Key to remove all permanent sources\n    };\n    mouse: {\n        brushActivate: string | null; // Optional: Mouse button ('LEFT', 'MIDDLE', 'RIGHT') for brush - overrides keys.brushActivate if set\n    };\n    modifiers: {\n        brushSizeScroll: 'Ctrl' | 'Shift' | 'Alt' | null; // Modifier key for brush size adjustment via scroll wheel (null = disabled)\n        brushInvert: 'Ctrl' | 'Shift' | 'Alt' | null; // Modifier key to invert brush operation (Add/Subtract) when held with brush activate\n        brushSecondary: 'Ctrl' | 'Shift' | 'Alt' | null; // Modifier key for secondary brush operation (e.g., Alt+click for flatten target height, slope end point)\n    };\n    camera: {\n        // Mouse button mappings: 'LEFT', 'MIDDLE', 'RIGHT', or null to disable\n        rotateButton: 'LEFT' | 'MIDDLE' | 'RIGHT' | null;\n        panButton: 'LEFT' | 'MIDDLE' | 'RIGHT' | null;\n        // Speed settings (0.0 to 10.0)\n        rotateSpeed: number;\n        zoomSpeed: number;\n        panSpeed: number;\n        // Enable/disable features\n        enableRotate: boolean;\n        enablePan: boolean;\n        enableZoom: boolean;\n        // Damping settings\n        enableDamping: boolean;\n        dampingFactor: number;\n        // WASD movement settings\n        movement: {\n            enableWASD: boolean;           // Enable WASD movement\n            moveSpeed: number;              // Base movement speed (units per second)\n            fastMoveMultiplier: number;     // Speed multiplier when Shift is held\n            enableVerticalMovement: boolean; // Enable Space/Shift for up/down movement\n        };\n    };\n    // Raycasting settings\n    raycast: {\n        method: 'heightmap' | 'bvh'; // Raycast method: 'heightmap' or 'bvh'\n    };\n}\n\n// Default key bindings - modify these to rebind controls\nexport const defaultControlsConfig: ControlsConfig = {\n    keys: {\n        brushActivate: 'LEFT',              // Keyboard key OR mouse button ('LEFT', 'MIDDLE', 'RIGHT') for brush\n        permanentWaterSource: 'r',       // Toggle permanent water source at cursor\n        removePermanentSource: 'p',      // Remove all permanent sources\n    },\n    mouse: {\n        // Optional: Set to 'LEFT', 'MIDDLE', or 'RIGHT' to bind mouse button for brush\n        // If set, mouse button takes priority. You can also set keys.brushActivate to a keyboard key\n        // to have BOTH keyboard and mouse work simultaneously\n        brushActivate: null, \n    },\n    modifiers: {\n        brushSizeScroll: 'Ctrl',      // Hold this modifier + scroll to adjust brush size (Ctrl, Shift, Alt, or null to disable)\n        brushInvert: 'Shift',          // Hold this modifier + brush activate to invert operation (Add â†” Subtract)\n        brushSecondary: 'Alt',        // Hold this modifier + brush activate for secondary operation (e.g., flatten target height, slope end point)\n    },\n    camera: {\n        // Default OrbitControls bindings: LEFT = rotate, MIDDLE = pan, RIGHT = rotate (with shift = pan)\n        rotateButton: 'RIGHT',            // Mouse button for rotation\n        panButton: 'MIDDLE',              // Mouse button for panning\n        rotateSpeed: 1.0,                 // Rotation speed multiplier\n        zoomSpeed: 1.0,                   // Zoom speed multiplier\n        panSpeed: 1.0,                    // Pan speed multiplier\n        enableRotate: true,               // Enable rotation\n        enablePan: true,                  // Enable panning\n        enableZoom: true,                 // Enable zoom (scroll wheel)\n        enableDamping: true,              // Enable smooth damping\n        dampingFactor: 0.08,             // Damping factor (0.0 to 1.0)\n        movement: {\n            enableWASD: true,             // Enable WASD movement\n            moveSpeed: 0.3,                // Base speed: 0.3 units/second (reduced from 2.0)\n            fastMoveMultiplier: 3.0,       // 3x speed with Shift\n            enableVerticalMovement: true,   // Space = up, Shift = down\n        },\n    },\n    raycast: {\n        method: 'bvh',                     // Default raycast method: 'bvh' for better accuracy\n    },\n};\n\n// Helper function to check if a key matches any action\nexport function getKeyAction(key: string, config: ControlsConfig): string | null {\n    // Check keyboard keys (not mouse buttons)\n    if (key !== 'LEFT' && key !== 'MIDDLE' && key !== 'RIGHT') {\n        if (key === config.keys.brushActivate) return 'brushActivate';\n        if (key === config.keys.permanentWaterSource) return 'permanentWaterSource';\n        if (key === config.keys.removePermanentSource) return 'removePermanentSource';\n    }\n    return null;\n}\n\n// Helper function to check if a mouse button OR keyboard key matches brushActivate\nexport function isBrushActivate(input: string | number, config: ControlsConfig): boolean {\n    if (typeof input === 'number') {\n        // Mouse button number: 0 = LEFT, 1 = MIDDLE, 2 = RIGHT\n        const buttonMap: { [key: number]: string } = {\n            0: 'LEFT',\n            1: 'MIDDLE',\n            2: 'RIGHT'\n        };\n        const buttonName = buttonMap[input];\n        // Check mouse binding first, then fall back to keys.brushActivate if it's a mouse button\n        if (config.mouse.brushActivate) {\n            return buttonName === config.mouse.brushActivate;\n        }\n        // Fall back: if keys.brushActivate is a mouse button string, check that\n        return buttonName === config.keys.brushActivate;\n    } else {\n        // Keyboard key string - check keys.brushActivate (only if it's not a mouse button)\n        const key = input.toLowerCase();\n        if (config.keys.brushActivate !== 'LEFT' && \n            config.keys.brushActivate !== 'MIDDLE' && \n            config.keys.brushActivate !== 'RIGHT') {\n            return key === config.keys.brushActivate;\n        }\n        return false;\n    }\n}\n\n// Helper function to check if a mouse button matches any action\nexport function getMouseButtonAction(button: number, config: ControlsConfig): string | null {\n    // Convert button number to string: 0 = LEFT, 1 = MIDDLE, 2 = RIGHT\n    const buttonMap: { [key: number]: string } = {\n        0: 'LEFT',\n        1: 'MIDDLE',\n        2: 'RIGHT'\n    };\n    const buttonName = buttonMap[button];\n    console.log('[DEBUG] getMouseButtonAction - button:', button, '-> buttonName:', buttonName, 'mouse.brushActivate:', config.mouse.brushActivate, 'keys.brushActivate:', config.keys.brushActivate);\n    \n    // Check mouse binding first (takes priority)\n    if (config.mouse.brushActivate && buttonName === config.mouse.brushActivate) {\n        console.log('[DEBUG] getMouseButtonAction - MATCH (mouse binding)!');\n        return 'brushActivate';\n    }\n    // Fall back to keys.brushActivate if it's a mouse button string\n    if (buttonName && config.keys.brushActivate === buttonName) {\n        console.log('[DEBUG] getMouseButtonAction - MATCH (key binding)!');\n        return 'brushActivate';\n    }\n    console.log('[DEBUG] getMouseButtonAction - NO MATCH');\n    return null;\n}\n\n/**\n * Helper function to check if a modifier key is pressed based on the config\n */\nexport function isModifierPressed(modifier: 'Ctrl' | 'Shift' | 'Alt' | null, event: MouseEvent | PointerEvent | KeyboardEvent): boolean {\n    if (modifier === null) return false;\n    \n    switch (modifier) {\n        case 'Ctrl':\n            return event.ctrlKey || event.metaKey; // metaKey for Mac Cmd key\n        case 'Shift':\n            return event.shiftKey;\n        case 'Alt':\n            return event.altKey;\n        default:\n            return false;\n    }\n}\n\n","// Settings management - handles loading/saving control bindings\n// \n// This system allows control bindings to be:\n// 1. Loaded from localStorage on startup (persists across sessions)\n// 2. Saved to localStorage when changed\n// 3. Exported/imported as JSON files\n// 4. Reset to defaults\n//\n// Future UI rebinding:\n// - Call loadSettings() to get current config\n// - Modify the config object\n// - Call saveSettings(config) to persist changes\n// - The app will automatically use the new settings on next load\n//\n// Example usage in UI:\n//   import { loadSettings, saveSettings, resetSettings } from './settings';\n//   const config = loadSettings();\n//   config.keys.brushActivate = 'b'; // Change binding\n//   saveSettings(config); // Save to localStorage\n\nimport { ControlsConfig, defaultControlsConfig } from './controls-config';\n\nconst SETTINGS_STORAGE_KEY = 'webgl-erosion-controls';\n\n/**\n * Load settings from localStorage, falling back to defaults if not found or invalid\n */\nexport function loadSettings(): ControlsConfig {\n    try {\n        const stored = localStorage.getItem(SETTINGS_STORAGE_KEY);\n        if (stored) {\n            const parsed = JSON.parse(stored);\n            // Validate and merge with defaults to ensure all fields exist\n            return mergeWithDefaults(parsed);\n        }\n    } catch (error) {\n        console.warn('[Settings] Failed to load settings from localStorage:', error);\n    }\n    \n    // Return defaults if nothing stored or error occurred\n    return defaultControlsConfig;\n}\n\n/**\n * Save settings to localStorage\n */\nexport function saveSettings(config: ControlsConfig): void {\n    try {\n        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(config, null, 2));\n        console.log('[Settings] Settings saved successfully');\n    } catch (error) {\n        console.error('[Settings] Failed to save settings to localStorage:', error);\n    }\n}\n\n/**\n * Reset settings to defaults\n */\nexport function resetSettings(): ControlsConfig {\n    try {\n        localStorage.removeItem(SETTINGS_STORAGE_KEY);\n        console.log('[Settings] Settings reset to defaults');\n    } catch (error) {\n        console.error('[Settings] Failed to reset settings:', error);\n    }\n    return defaultControlsConfig;\n}\n\n/**\n * Merge loaded settings with defaults to ensure all fields are present\n * This handles cases where new fields are added to ControlsConfig\n */\nfunction mergeWithDefaults(loaded: any): ControlsConfig {\n    const merged: ControlsConfig = {\n        keys: {\n            brushActivate: loaded.keys?.brushActivate ?? defaultControlsConfig.keys.brushActivate,\n            permanentWaterSource: loaded.keys?.permanentWaterSource ?? defaultControlsConfig.keys.permanentWaterSource,\n            removePermanentSource: loaded.keys?.removePermanentSource ?? defaultControlsConfig.keys.removePermanentSource,\n        },\n        mouse: {\n            brushActivate: loaded.mouse?.brushActivate ?? defaultControlsConfig.mouse.brushActivate,\n        },\n        modifiers: {\n            brushSizeScroll: loaded.modifiers?.brushSizeScroll ?? defaultControlsConfig.modifiers.brushSizeScroll,\n            brushInvert: loaded.modifiers?.brushInvert ?? defaultControlsConfig.modifiers.brushInvert,\n            brushSecondary: loaded.modifiers?.brushSecondary ?? defaultControlsConfig.modifiers.brushSecondary,\n        },\n        camera: {\n            rotateButton: loaded.camera?.rotateButton ?? defaultControlsConfig.camera.rotateButton,\n            panButton: loaded.camera?.panButton ?? defaultControlsConfig.camera.panButton,\n            rotateSpeed: loaded.camera?.rotateSpeed ?? defaultControlsConfig.camera.rotateSpeed,\n            zoomSpeed: loaded.camera?.zoomSpeed ?? defaultControlsConfig.camera.zoomSpeed,\n            panSpeed: loaded.camera?.panSpeed ?? defaultControlsConfig.camera.panSpeed,\n            enableRotate: loaded.camera?.enableRotate ?? defaultControlsConfig.camera.enableRotate,\n            enablePan: loaded.camera?.enablePan ?? defaultControlsConfig.camera.enablePan,\n            enableZoom: loaded.camera?.enableZoom ?? defaultControlsConfig.camera.enableZoom,\n            enableDamping: loaded.camera?.enableDamping ?? defaultControlsConfig.camera.enableDamping,\n            dampingFactor: loaded.camera?.dampingFactor ?? defaultControlsConfig.camera.dampingFactor,\n            movement: {\n                enableWASD: loaded.camera?.movement?.enableWASD ?? defaultControlsConfig.camera.movement.enableWASD,\n                moveSpeed: loaded.camera?.movement?.moveSpeed ?? defaultControlsConfig.camera.movement.moveSpeed,\n                fastMoveMultiplier: loaded.camera?.movement?.fastMoveMultiplier ?? defaultControlsConfig.camera.movement.fastMoveMultiplier,\n                enableVerticalMovement: loaded.camera?.movement?.enableVerticalMovement ?? defaultControlsConfig.camera.movement.enableVerticalMovement,\n            },\n        },\n        raycast: {\n            method: loaded.raycast?.method ?? defaultControlsConfig.raycast.method,\n        },\n    };\n    \n    return merged;\n}\n\n/**\n * Export settings to a JSON string (for file download)\n */\nexport function exportSettings(config: ControlsConfig): string {\n    return JSON.stringify(config, null, 2);\n}\n\n/**\n * Import settings from a JSON string (for file upload)\n */\nexport function importSettings(jsonString: string): ControlsConfig {\n    try {\n        const parsed = JSON.parse(jsonString);\n        const merged = mergeWithDefaults(parsed);\n        saveSettings(merged);\n        return merged;\n    } catch (error) {\n        console.error('[Settings] Failed to import settings:', error);\n        throw new Error('Invalid settings format');\n    }\n}\n\n","// Brush Palette UI - Quick access to brush types without going to terrain editor\n\nimport { ControlsConfig } from './controls-config';\n\nexport interface BrushPaletteControls {\n    brushType: number;\n    brushSize: number;\n    brushStrenth: number;\n    brushOperation: number;\n    flattenTargetHeight?: number;\n    slopeActive?: number;\n    slopeStartPos?: { x: number; y: number };\n    slopeEndPos?: { x: number; y: number };\n}\n\n// Type for objects that have at least the brush palette controls\nexport type BrushPaletteControlsLike = {\n    brushType: number;\n    brushSize: number;\n    brushStrenth: number;\n    brushOperation: number;\n    flattenTargetHeight?: number;\n    slopeActive?: number;\n    slopeStartPos?: any; // Can be vec2 or { x: number; y: number }\n    slopeEndPos?: any; // Can be vec2 or { x: number; y: number }\n    [key: string]: any; // Allow additional properties\n}\n\nexport interface BrushType {\n    id: number;\n    name: string;\n    icon?: string; // Optional icon/emoji for visual representation\n    color?: string; // Optional color for the button\n    shortcut?: string; // Keyboard shortcut key\n    description?: string; // Tooltip description\n}\n\n// Brush type definitions\nexport const BRUSH_TYPES: BrushType[] = [\n    { id: 0, name: 'None', icon: 'ðŸš«', color: '#666', shortcut: '0', description: 'Disable brush' },\n    { id: 1, name: 'Terrain', icon: 'â›°ï¸', color: '#8B4513', shortcut: '1', description: 'Modify terrain height' },\n    { id: 2, name: 'Water', icon: 'ðŸ’§', color: '#4A90E2', shortcut: '2', description: 'Add/remove water' },\n    { id: 3, name: 'Rock', icon: 'ðŸª¨', color: '#555', shortcut: '3', description: 'Place erosion-resistant rock' },\n    { id: 4, name: 'Smooth', icon: 'âœ¨', color: '#9B59B6', shortcut: '4', description: 'Smooth terrain surface' },\n    { id: 5, name: 'Flatten', icon: 'ðŸ“', color: '#F39C12', shortcut: '5', description: 'Flatten to target height\\n\\nLeft Click: Flatten terrain to target height\\nAlt+Click: Set target height to clicked location\\nUse slider to manually set target height (0-500)' },\n    { id: 6, name: 'Slope', icon: 'ðŸ“‰', color: '#27AE60', shortcut: '6', description: 'Create slope between two points\\n\\nAlt+Click (first): Set start point\\nAlt+Click (second): Set end point\\nLeft Click: Apply slope after both points are set' },\n];\n\n// Brush size presets\nexport const BRUSH_SIZE_PRESETS = [\n    { name: 'Tiny', value: 0.5 },\n    { name: 'Small', value: 1.0 },\n    { name: 'Medium', value: 4.0 },\n    { name: 'Large', value: 8.0 },\n    { name: 'Huge', value: 15.0 },\n];\n\n// Brush strength presets\nexport const BRUSH_STRENGTH_PRESETS = [\n    { name: 'Weak', value: 0.1 },\n    { name: 'Normal', value: 0.25 },\n    { name: 'Strong', value: 0.5 },\n    { name: 'Very Strong', value: 1.0 },\n];\n\n/**\n * Create and return the brush palette HTML element\n */\nexport function createBrushPalette(\n    controls: BrushPaletteControlsLike,\n    onBrushChange: (brushType: number) => void,\n    onSizeChange: (size: number) => void,\n    onStrengthChange: (strength: number) => void,\n    onOperationChange: (operation: number) => void\n): HTMLElement {\n    const palette = document.createElement('div');\n    palette.id = 'brush-palette';\n    let isMinimized = false;\n    \n    // Main container styles\n    palette.style.cssText = `\n        position: fixed;\n        top: 20px;\n        left: 20px;\n        background: rgba(30, 30, 30, 0.95);\n        border: 2px solid #555;\n        border-radius: 8px;\n        padding: 15px;\n        z-index: 10000;\n        display: flex;\n        flex-direction: column;\n        gap: 10px;\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);\n        font-family: 'Segoe UI', Arial, sans-serif;\n        min-width: 200px;\n        max-width: 220px;\n        user-select: none;\n        transition: all 0.3s ease;\n    `;\n\n    // Make palette draggable\n    let isDragging = false;\n    let dragOffset = { x: 0, y: 0 };\n    \n    const handleMouseDown = (e: MouseEvent) => {\n        if ((e.target as HTMLElement).closest('button, input, select, label')) {\n            return; // Don't drag if clicking on controls\n        }\n        isDragging = true;\n        const rect = palette.getBoundingClientRect();\n        dragOffset.x = e.clientX - rect.left;\n        dragOffset.y = e.clientY - rect.top;\n        palette.style.cursor = 'grabbing';\n    };\n    \n    const handleMouseMove = (e: MouseEvent) => {\n        if (isDragging) {\n            palette.style.left = `${e.clientX - dragOffset.x}px`;\n            palette.style.top = `${e.clientY - dragOffset.y}px`;\n        }\n    };\n    \n    const handleMouseUp = () => {\n        isDragging = false;\n        palette.style.cursor = 'default';\n    };\n    \n    palette.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n\n    // Header with title and minimize button\n    const header = document.createElement('div');\n    header.style.cssText = `\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        margin-bottom: 5px;\n        cursor: move;\n    `;\n    \n    const title = document.createElement('div');\n    title.textContent = 'Brush Palette';\n    title.style.cssText = `\n        color: #fff;\n        font-weight: bold;\n        font-size: 16px;\n        flex: 1;\n    `;\n    header.appendChild(title);\n    \n    // Controls help button\n    const controlsButton = document.createElement('button');\n    controlsButton.textContent = 'ðŸŽ®';\n    controlsButton.title = `CONTROLS HELP\n\nBRUSH TYPES:\n1 - Terrain â›°ï¸: Modify terrain height\n2 - Water ðŸ’§: Add/remove water\n3 - Rock ðŸª¨: Place erosion-resistant rock\n4 - Smooth âœ¨: Smooth terrain surface\n5 - Flatten ðŸ“: Flatten to target height\n6 - Slope ðŸ“‰: Create slope between points\n\nBRUSH OPERATIONS:\nLeft Click: Add mode\nShift + Click: Subtract mode\nAlt + Click: Secondary operation\n\nBRUSH MODIFIERS:\nCtrl + Scroll: Adjust brush size\nShift: Invert operation (Add â†” Subtract)\nAlt: Secondary operation\n\nFLATTEN BRUSH:\nLeft Click: Flatten to target height\nAlt + Click: Set target height to clicked location\nUse slider to manually set target height (0-500)\n\nSLOPE BRUSH:\nLeft Click (first): Set start point of slope\nAlt + Click + Drag: Paint to the start point of slope\n\nWATER SOURCES:\nr: Place permanent water source\nShift + r: Remove nearest water source\np: Remove all permanent water sources\n\nCAMERA:\nRight Mouse: Rotate\nMiddle Mouse: Pan\nScroll: Zoom\nWASD: Move camera\nSpace: Move up\n\nOTHER:\nStart/Resume: Start/pause simulation\nReset: Generate new terrain`;\n    controlsButton.style.cssText = `\n        background: transparent;\n        border: 1px solid #555;\n        color: #ccc;\n        width: 24px;\n        height: 24px;\n        border-radius: 4px;\n        cursor: help;\n        font-size: 14px;\n        line-height: 1;\n        padding: 0;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        margin-right: 4px;\n        transition: all 0.2s;\n    `;\n    controlsButton.addEventListener('mouseenter', () => {\n        controlsButton.style.background = 'rgba(100, 100, 100, 0.5)';\n        controlsButton.style.transform = 'scale(1.1)';\n    });\n    controlsButton.addEventListener('mouseleave', () => {\n        controlsButton.style.background = 'transparent';\n        controlsButton.style.transform = 'scale(1)';\n    });\n    header.appendChild(controlsButton);\n    \n    // GitHub README link button\n    const readmeButton = document.createElement('button');\n    readmeButton.textContent = 'ðŸ“–';\n    readmeButton.title = 'View full documentation on GitHub';\n    readmeButton.style.cssText = `\n        background: transparent;\n        border: 1px solid #555;\n        color: #ccc;\n        width: 24px;\n        height: 24px;\n        border-radius: 4px;\n        cursor: pointer;\n        font-size: 14px;\n        line-height: 1;\n        padding: 0;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        margin-right: 4px;\n        transition: all 0.2s;\n    `;\n    readmeButton.addEventListener('mouseenter', () => {\n        readmeButton.style.background = 'rgba(100, 100, 100, 0.5)';\n        readmeButton.style.transform = 'scale(1.1)';\n    });\n    readmeButton.addEventListener('mouseleave', () => {\n        readmeButton.style.background = 'transparent';\n        readmeButton.style.transform = 'scale(1)';\n    });\n    readmeButton.addEventListener('click', () => {\n        window.open('https://github.com/sonicdm/Webgl-Erosion/blob/master/README.md', '_blank');\n    });\n    header.appendChild(readmeButton);\n    \n    // Minimize/Maximize button\n    const minimizeBtn = document.createElement('button');\n    minimizeBtn.textContent = 'âˆ’';\n    minimizeBtn.style.cssText = `\n        background: transparent;\n        border: 1px solid #555;\n        color: #ccc;\n        width: 24px;\n        height: 24px;\n        border-radius: 4px;\n        cursor: pointer;\n        font-size: 18px;\n        line-height: 1;\n        padding: 0;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    `;\n    minimizeBtn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        isMinimized = !isMinimized;\n        const content = palette.querySelector('.palette-content') as HTMLElement;\n        if (content) {\n            content.style.display = isMinimized ? 'none' : 'flex';\n            minimizeBtn.textContent = isMinimized ? '+' : 'âˆ’';\n        }\n    });\n    header.appendChild(minimizeBtn);\n    palette.appendChild(header);\n\n    // Content container (can be hidden when minimized)\n    const content = document.createElement('div');\n    content.className = 'palette-content';\n    content.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        gap: 10px;\n    `;\n\n    // Brush type buttons section\n    const brushSection = document.createElement('div');\n    brushSection.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        gap: 6px;\n    `;\n    \n    const brushLabel = document.createElement('div');\n    brushLabel.textContent = 'Brush Type:';\n    brushLabel.style.cssText = `\n        color: #aaa;\n        font-size: 11px;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n        margin-bottom: 4px;\n    `;\n    brushSection.appendChild(brushLabel);\n\n    // Create buttons for each brush type\n    BRUSH_TYPES.forEach(brush => {\n        const button = document.createElement('button');\n        button.className = 'brush-type-button';\n        button.setAttribute('data-brush-id', brush.id.toString());\n        const shortcutText = brush.shortcut ? ` [${brush.shortcut}]` : '';\n        button.textContent = `${brush.icon || ''} ${brush.name}${shortcutText}`;\n        // Enhanced tooltip for Flatten and Slope brushes\n        if (brush.id === 5) {\n            button.title = 'Flatten Brush ðŸ“\\n\\nLeft Click: Flatten terrain to target height\\nAlt+Click: Set target height to clicked location\\nUse slider to manually set target height (0-500)';\n        } else if (brush.id === 6) {\n            button.title = 'Slope Brush ðŸ“‰\\n\\nLeft Click (first): Set start point of slope\\nAlt + Click + Drag: Paint to the start point of slope';\n        } else {\n            button.title = brush.description || brush.name; // Standard tooltip\n        }\n        button.style.cssText = `\n            padding: 8px 12px;\n            border: 2px solid ${brush.color || '#666'};\n            background: ${controls.brushType === brush.id ? brush.color || '#666' : 'transparent'};\n            color: ${controls.brushType === brush.id ? '#fff' : brush.color || '#ccc'};\n            cursor: pointer;\n            border-radius: 4px;\n            font-size: 12px;\n            transition: all 0.2s;\n            text-align: left;\n            position: relative;\n        `;\n\n        // Update button style on hover\n        button.addEventListener('mouseenter', () => {\n            if (controls.brushType !== brush.id) {\n                button.style.background = `${brush.color || '#666'}33`;\n                button.style.transform = 'translateX(2px)';\n            }\n        });\n        button.addEventListener('mouseleave', () => {\n            if (controls.brushType !== brush.id) {\n                button.style.background = 'transparent';\n                button.style.transform = 'translateX(0)';\n            }\n        });\n\n        // Handle click\n        button.addEventListener('click', (e) => {\n            e.stopPropagation();\n            onBrushChange(brush.id);\n            updatePaletteSelection(palette, controls);\n        });\n\n        brushSection.appendChild(button);\n    });\n    content.appendChild(brushSection);\n\n    // Add separator\n    const separator = document.createElement('div');\n    separator.style.cssText = `\n        border-top: 1px solid #555;\n        margin: 5px 0;\n    `;\n    content.appendChild(separator);\n\n    // Brush Size control with presets\n    const sizeContainer = document.createElement('div');\n    sizeContainer.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        gap: 5px;\n    `;\n    \n    const sizeHeader = document.createElement('div');\n    sizeHeader.style.cssText = `\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        margin-bottom: 2px;\n    `;\n    \n    const sizeLabel = document.createElement('label');\n    sizeLabel.textContent = `Size: ${controls.brushSize.toFixed(1)}`;\n    sizeLabel.style.cssText = `\n        color: #ccc;\n        font-size: 12px;\n        font-weight: 500;\n    `;\n    sizeHeader.appendChild(sizeLabel);\n    \n    // Size preset buttons\n    const sizePresets = document.createElement('div');\n    sizePresets.style.cssText = `\n        display: flex;\n        gap: 2px;\n    `;\n    BRUSH_SIZE_PRESETS.forEach(preset => {\n        const presetBtn = document.createElement('button');\n        presetBtn.textContent = preset.name[0];\n        presetBtn.title = `${preset.name}: ${preset.value}`;\n        presetBtn.style.cssText = `\n            width: 20px;\n            height: 20px;\n            padding: 0;\n            font-size: 9px;\n            background: ${Math.abs(controls.brushSize - preset.value) < 0.1 ? '#4A90E2' : '#333'};\n            border: 1px solid #555;\n            color: #ccc;\n            border-radius: 3px;\n            cursor: pointer;\n        `;\n        presetBtn.addEventListener('click', (e) => {\n            e.stopPropagation();\n            onSizeChange(preset.value);\n            updatePaletteSelection(palette, controls);\n        });\n        sizePresets.appendChild(presetBtn);\n    });\n    sizeHeader.appendChild(sizePresets);\n    sizeContainer.appendChild(sizeHeader);\n    \n    const sizeInput = document.createElement('input');\n    sizeInput.type = 'range';\n    sizeInput.min = '0.1';\n    sizeInput.max = '20.0';\n    sizeInput.step = '0.1';\n    sizeInput.value = controls.brushSize.toString();\n    sizeInput.style.cssText = `\n        width: 100%;\n        cursor: pointer;\n    `;\n    sizeInput.addEventListener('input', (e) => {\n        const value = parseFloat((e.target as HTMLInputElement).value);\n        sizeLabel.textContent = `Size: ${value.toFixed(1)}`;\n        onSizeChange(value);\n    });\n    sizeContainer.appendChild(sizeInput);\n    content.appendChild(sizeContainer);\n\n    // Brush Strength control with presets\n    const strengthContainer = document.createElement('div');\n    strengthContainer.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        gap: 5px;\n    `;\n    \n    const strengthHeader = document.createElement('div');\n    strengthHeader.style.cssText = `\n        display: flex;\n        justify-content: space-between;\n        align-items: center;\n        margin-bottom: 2px;\n    `;\n    \n    const strengthLabel = document.createElement('label');\n    strengthLabel.textContent = `Strength: ${controls.brushStrenth.toFixed(2)}`;\n    strengthLabel.style.cssText = `\n        color: #ccc;\n        font-size: 12px;\n        font-weight: 500;\n    `;\n    strengthHeader.appendChild(strengthLabel);\n    \n    // Strength preset buttons\n    const strengthPresets = document.createElement('div');\n    strengthPresets.style.cssText = `\n        display: flex;\n        gap: 2px;\n    `;\n    BRUSH_STRENGTH_PRESETS.forEach(preset => {\n        const presetBtn = document.createElement('button');\n        presetBtn.textContent = preset.name[0];\n        presetBtn.title = `${preset.name}: ${preset.value}`;\n        presetBtn.style.cssText = `\n            width: 20px;\n            height: 20px;\n            padding: 0;\n            font-size: 9px;\n            background: ${Math.abs(controls.brushStrenth - preset.value) < 0.01 ? '#4A90E2' : '#333'};\n            border: 1px solid #555;\n            color: #ccc;\n            border-radius: 3px;\n            cursor: pointer;\n        `;\n        presetBtn.addEventListener('click', (e) => {\n            e.stopPropagation();\n            onStrengthChange(preset.value);\n            updatePaletteSelection(palette, controls);\n        });\n        strengthPresets.appendChild(presetBtn);\n    });\n    strengthHeader.appendChild(strengthPresets);\n    strengthContainer.appendChild(strengthHeader);\n    \n    const strengthInput = document.createElement('input');\n    strengthInput.type = 'range';\n    strengthInput.min = '0.1';\n    strengthInput.max = '2.0';\n    strengthInput.step = '0.01';\n    strengthInput.value = controls.brushStrenth.toString();\n    strengthInput.style.cssText = `\n        width: 100%;\n        cursor: pointer;\n    `;\n    strengthInput.addEventListener('input', (e) => {\n        const value = parseFloat((e.target as HTMLInputElement).value);\n        strengthLabel.textContent = `Strength: ${value.toFixed(2)}`;\n        onStrengthChange(value);\n    });\n    strengthContainer.appendChild(strengthInput);\n    content.appendChild(strengthContainer);\n\n    // Add/Subtract toggle with better styling\n    const operationContainer = document.createElement('div');\n    operationContainer.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        gap: 5px;\n    `;\n    \n    const operationLabel = document.createElement('label');\n    operationLabel.textContent = 'Operation:';\n    operationLabel.style.cssText = `\n        color: #ccc;\n        font-size: 12px;\n        font-weight: 500;\n    `;\n    operationContainer.appendChild(operationLabel);\n    \n    // Toggle buttons instead of dropdown\n    const operationToggle = document.createElement('div');\n    operationToggle.style.cssText = `\n        display: flex;\n        gap: 4px;\n    `;\n    \n    const addBtn = document.createElement('button');\n    addBtn.className = 'operation-add-btn';\n    addBtn.textContent = 'âž• Add';\n    addBtn.style.cssText = `\n        flex: 1;\n        padding: 6px;\n        background: ${controls.brushOperation === 0 ? '#27AE60' : '#333'};\n        border: 1px solid ${controls.brushOperation === 0 ? '#27AE60' : '#555'};\n        color: #fff;\n        border-radius: 4px;\n        font-size: 11px;\n        cursor: pointer;\n        transition: all 0.2s;\n    `;\n    addBtn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        // Update controls object first\n        controls.brushOperation = 0;\n        // Then call the callback to update dat-gui\n        onOperationChange(0);\n        // Refresh palette visual state\n        updatePaletteSelection(palette, controls);\n    });\n    \n    const subtractBtn = document.createElement('button');\n    subtractBtn.className = 'operation-subtract-btn';\n    subtractBtn.textContent = 'âž– Subtract';\n    subtractBtn.style.cssText = `\n        flex: 1;\n        padding: 6px;\n        background: ${controls.brushOperation === 1 ? '#E74C3C' : '#333'};\n        border: 1px solid ${controls.brushOperation === 1 ? '#E74C3C' : '#555'};\n        color: #fff;\n        border-radius: 4px;\n        font-size: 11px;\n        cursor: pointer;\n        transition: all 0.2s;\n    `;\n    subtractBtn.addEventListener('click', (e) => {\n        e.stopPropagation();\n        // Update controls object first\n        controls.brushOperation = 1;\n        // Then call the callback to update dat-gui\n        onOperationChange(1);\n        // Refresh palette visual state\n        updatePaletteSelection(palette, controls);\n    });\n    \n    operationToggle.appendChild(addBtn);\n    operationToggle.appendChild(subtractBtn);\n    operationContainer.appendChild(operationToggle);\n    content.appendChild(operationContainer);\n\n    // Special controls for Flatten brush\n    if (controls.flattenTargetHeight !== undefined) {\n        const flattenContainer = document.createElement('div');\n        flattenContainer.id = 'flatten-controls';\n        flattenContainer.style.cssText = `\n            display: ${controls.brushType === 5 ? 'flex' : 'none'};\n            flex-direction: column;\n            gap: 5px;\n            padding-top: 8px;\n            border-top: 1px solid #555;\n        `;\n        \n        const flattenLabel = document.createElement('label');\n        flattenLabel.textContent = `Target Height: ${controls.flattenTargetHeight.toFixed(1)}`;\n        flattenLabel.style.cssText = `\n            color: #ccc;\n            font-size: 11px;\n        `;\n        flattenContainer.appendChild(flattenLabel);\n        \n        const flattenInput = document.createElement('input');\n        flattenInput.type = 'range';\n        flattenInput.min = '0';\n        flattenInput.max = '500';\n        flattenInput.step = '1';\n        flattenInput.value = controls.flattenTargetHeight.toString();\n        flattenInput.style.cssText = `width: 100%;`;\n        flattenInput.addEventListener('input', (e) => {\n            const value = parseFloat((e.target as HTMLInputElement).value);\n            flattenLabel.textContent = `Target Height: ${value.toFixed(1)}`;\n            if (controls.flattenTargetHeight !== undefined) {\n                // UI and shader both use 0-500 range\n                controls.flattenTargetHeight = value;\n            }\n        });\n        flattenContainer.appendChild(flattenInput);\n        content.appendChild(flattenContainer);\n    }\n\n    palette.appendChild(content);\n\n    // Add keyboard shortcuts\n    const handleKeyPress = (e: KeyboardEvent) => {\n        // Only handle if not typing in an input\n        if (e.target instanceof HTMLInputElement || e.target instanceof HTMLSelectElement) {\n            return;\n        }\n        \n        const brush = BRUSH_TYPES.find(b => b.shortcut === e.key);\n        if (brush) {\n            e.preventDefault();\n            onBrushChange(brush.id);\n            updatePaletteSelection(palette, controls);\n        }\n    };\n    \n    document.addEventListener('keydown', handleKeyPress);\n    \n    // Store cleanup function\n    (palette as any).cleanup = () => {\n        document.removeEventListener('keydown', handleKeyPress);\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n    };\n\n    return palette;\n}\n\n/**\n * Update the visual selection state of the palette\n */\nexport function updatePaletteSelection(\n    palette: HTMLElement,\n    controls: BrushPaletteControlsLike\n): void {\n    // Update brush type buttons - only select buttons with the brush-type-button class\n    const brushButtons = palette.querySelectorAll('.brush-type-button');\n    brushButtons.forEach((button) => {\n        const brushId = parseInt((button as HTMLElement).getAttribute('data-brush-id') || '-1');\n        const brush = BRUSH_TYPES.find(b => b.id === brushId);\n        if (brush) {\n            const isSelected = controls.brushType === brush.id;\n            (button as HTMLElement).style.background = isSelected ? (brush.color || '#666') : 'transparent';\n            (button as HTMLElement).style.color = isSelected ? '#fff' : (brush.color || '#ccc');\n        }\n    });\n\n    // Update brush size slider and label\n    const sizeInput = palette.querySelector('input[type=\"range\"]') as HTMLInputElement;\n    const sizeLabel = palette.querySelector('label') as HTMLLabelElement;\n    if (sizeInput && sizeLabel && sizeLabel.textContent?.includes('Size:')) {\n        sizeInput.value = controls.brushSize.toString();\n        sizeLabel.textContent = `Size: ${controls.brushSize.toFixed(1)}`;\n        \n        // Update size preset buttons\n        const sizePresets = Array.from(sizeLabel.parentElement?.querySelectorAll('button') || []) as HTMLButtonElement[];\n        sizePresets.forEach((btn, i) => {\n            const preset = BRUSH_SIZE_PRESETS[i];\n            if (preset) {\n                btn.style.background = Math.abs(controls.brushSize - preset.value) < 0.1 ? '#4A90E2' : '#333';\n            }\n        });\n    }\n\n    // Update brush strength slider and label\n    const strengthInputs = palette.querySelectorAll('input[type=\"range\"]');\n    if (strengthInputs.length >= 2) {\n        const strengthInput = strengthInputs[1] as HTMLInputElement;\n        strengthInput.value = controls.brushStrenth.toString();\n        const strengthLabel = strengthInput.parentElement?.querySelector('label') as HTMLLabelElement;\n        if (strengthLabel && strengthLabel.textContent?.includes('Strength:')) {\n            strengthLabel.textContent = `Strength: ${controls.brushStrenth.toFixed(2)}`;\n            \n            // Update strength preset buttons\n            const strengthPresets = Array.from(strengthLabel.parentElement?.querySelectorAll('button') || []) as HTMLButtonElement[];\n            strengthPresets.forEach((btn, i) => {\n                const preset = BRUSH_STRENGTH_PRESETS[i];\n                if (preset) {\n                    btn.style.background = Math.abs(controls.brushStrenth - preset.value) < 0.01 ? '#4A90E2' : '#333';\n                }\n            });\n        }\n    }\n\n    // Update operation buttons - use class selectors for more reliable finding\n    const addBtn = palette.querySelector('.operation-add-btn') as HTMLButtonElement;\n    const subtractBtn = palette.querySelector('.operation-subtract-btn') as HTMLButtonElement;\n    if (addBtn && subtractBtn) {\n        addBtn.style.background = controls.brushOperation === 0 ? '#27AE60' : '#333';\n        addBtn.style.borderColor = controls.brushOperation === 0 ? '#27AE60' : '#555';\n        subtractBtn.style.background = controls.brushOperation === 1 ? '#E74C3C' : '#333';\n        subtractBtn.style.borderColor = controls.brushOperation === 1 ? '#E74C3C' : '#555';\n    }\n    \n    // Show/hide flatten controls\n    const flattenContainer = palette.querySelector('#flatten-controls') as HTMLElement;\n    if (flattenContainer) {\n        flattenContainer.style.display = controls.brushType === 5 ? 'flex' : 'none';\n    }\n}\n\n/**\n * Initialize the brush palette and add it to the document\n */\nexport function initBrushPalette(\n    controls: BrushPaletteControlsLike,\n    onBrushChange: (brushType: number) => void,\n    onSizeChange: (size: number) => void,\n    onStrengthChange: (strength: number) => void,\n    onOperationChange: (operation: number) => void\n): HTMLElement {\n    // Remove existing palette if it exists\n    const existing = document.getElementById('brush-palette');\n    if (existing) {\n        const cleanup = (existing as any).cleanup;\n        if (cleanup) cleanup();\n        existing.remove();\n    }\n\n    const palette = createBrushPalette(controls, onBrushChange, onSizeChange, onStrengthChange, onOperationChange);\n    document.body.appendChild(palette);\n    return palette;\n}\n","import * as DAT from 'dat-gui';\nimport { updatePaletteSelection, initBrushPalette } from '../brush-palette';\nimport { loadSettings, saveSettings } from '../settings';\n\nexport interface Controls {\n    [key: string]: any;\n    brushType: number;\n    brushSize: number;\n    brushStrenth: number;\n    brushOperation: number;\n    slopeActive: number;\n}\n\nexport interface GUIControllers {\n    brushTypeController: DAT.GUIController;\n    brushSizeController: DAT.GUIController;\n    brushStrengthController: DAT.GUIController;\n    brushOperationController: DAT.GUIController;\n    flattenTargetHeightController: DAT.GUIController;\n}\n\nexport function setupGUI(controls: Controls): { gui: DAT.GUI, controllers: GUIControllers } {\n    const gui = new DAT.GUI();\n    \n    // Simulation Controls\n    var simcontrols = gui.addFolder('Simulation Controls');\n    simcontrols.add(controls, 'Pause/Resume');\n    simcontrols.add(controls, 'SimulationSpeed', { fast: 3, medium: 2, slow: 1 });\n    simcontrols.open();\n    \n    // Terrain Parameters\n    var terrainParameters = gui.addFolder('Terrain Parameters');\n    terrainParameters.add(controls, 'SimulationResolution', { 256: 256, 512: 512, 1024: 1024, 2048: 2048, 4096: 4096 });\n    terrainParameters.add(controls, 'TerrainScale', 0.1, 4.0);\n    terrainParameters.add(controls, 'TerrainHeight', 1.0, 5.0);\n    terrainParameters.add(controls, 'TerrainMask', { \n        OFF: 0, \n        Sphere: 1, \n        Slope: 2, \n        Square: 3, \n        Ring: 4, \n        RadialGradient: 5, \n        Corner: 6, \n        Diagonal: 7, \n        Cross: 8 \n    });\n    terrainParameters.add(controls, 'TerrainBaseType', { ordinaryFBM: 0, domainWarp: 1, terrace: 2, voroni: 3, ridgeNoise: 4 });\n    terrainParameters.add(controls, 'ResetTerrain');\n    terrainParameters.add(controls, 'Import Height Map');\n    terrainParameters.add(controls, 'Clear Height Map');\n    terrainParameters.open();\n    \n    // Erosion Parameters\n    var erosionpara = gui.addFolder('Erosion Parameters');\n    var RainErosionPara = erosionpara.addFolder('Rain Erosion Parameters');\n    RainErosionPara.add(controls, 'RainErosion');\n    RainErosionPara.add(controls, 'RainErosionStrength', 0.1, 3.0);\n    RainErosionPara.add(controls, 'RainErosionDropSize', 0.1, 3.0);\n    RainErosionPara.close();\n    erosionpara.add(controls, 'ErosionMode', { RiverMode: 0, MountainMode: 1, PolygonalMode: 2 });\n    erosionpara.add(controls, 'VelocityAdvectionMag', 0.0, 0.5);\n    erosionpara.add(controls, 'EvaporationConstant', 0.0001, 0.08);\n    erosionpara.add(controls, 'Kc', 0.01, 0.5);\n    erosionpara.add(controls, 'Ks', 0.001, 0.2);\n    erosionpara.add(controls, 'Kd', 0.0001, 0.1);\n    erosionpara.add(controls, 'TerrainDebug', { noDebugView: 0, sediment: 1, velocity: 2, velocityHeatmap: 9, terrain: 3, flux: 4, terrainflux: 5, maxslippage: 6, flowMap: 7, spikeDiffusion: 8, rockMaterial: 10 });\n    erosionpara.add(controls, 'AdvectionMethod', { Semilagrangian: 0, MacCormack: 1 });\n    erosionpara.add(controls, 'VelocityMultiplier', 1.0, 5.0);\n    erosionpara.open();\n    \n    // Thermal Erosion Parameters\n    var thermalerosionpara = gui.addFolder(\"Thermal Erosion Parameters\");\n    thermalerosionpara.add(controls, 'thermalTalusAngleScale', 1.0, 10.0);\n    thermalerosionpara.add(controls, 'thermalErosionScale', 0.0, 5.0);\n    \n    // Terrain Editor\n    var terraineditor = gui.addFolder('Terrain Editor');\n    terraineditor.add(controls, 'raycastMethod', { Heightmap: 'heightmap', BVH: 'bvh' }).onChange((value: string) => {\n        console.log('[Raycast] Method changed to:', value);\n        // Save to settings\n        const config = loadSettings();\n        config.raycast.method = value as 'heightmap' | 'bvh';\n        saveSettings(config);\n    });\n    const brushTypeController = terraineditor.add(controls, 'brushType', { NoBrush: 0, TerrainBrush: 1, WaterBrush: 2, RockBrush: 3, SmoothBrush: 4, FlattenBrush: 5, SlopeBrush: 6 });\n    brushTypeController.onChange((value: number) => {\n        // Reset slope state when switching brush types\n        if (value !== 6) {\n            controls.slopeActive = 0;\n        }\n        // Update brush palette to reflect change\n        if ((window as any).brushPalette) {\n            updatePaletteSelection((window as any).brushPalette, controls);\n        }\n    });\n    const flattenTargetHeightController = terraineditor.add(controls, 'flattenTargetHeight', 0.0, 500.0);\n    terraineditor.add(controls, 'rockErosionResistance', 0.0, 1.0);\n    const brushSizeController = terraineditor.add(controls, 'brushSize', 0.1, 20.0);\n    const brushStrengthController = terraineditor.add(controls, 'brushStrenth', 0.1, 2.0);\n    const brushOperationController = terraineditor.add(controls, 'brushOperation', { Add: 0, Subtract: 1 });\n    terraineditor.open();\n    \n    // Initialize brush palette UI (floating palette for quick brush selection)\n    const brushPalette = initBrushPalette(\n        controls,\n        (brushType: number) => {\n            controls.brushType = brushType;\n            // Reset slope state when switching brush types\n            if (brushType !== 6) {\n                controls.slopeActive = 0;\n            }\n            // Update dat-gui to reflect the change\n            brushTypeController.updateDisplay();\n        },\n        (size: number) => {\n            controls.brushSize = size;\n            brushSizeController.updateDisplay();\n        },\n        (strength: number) => {\n            controls.brushStrenth = strength;\n        },\n        (operation: number) => {\n            controls.brushOperation = operation;\n            brushOperationController.updateDisplay();\n        }\n    );\n    (window as any).brushPalette = brushPalette; // Store reference for updates\n    \n    // Store brushSize controller reference for updating UI when changed via Ctrl+Scroll\n    (window as any).brushSizeController = brushSizeController;\n    \n    // Store flattenTargetHeight controller reference for updating UI when set via Alt+click\n    (window as any).flattenTargetHeightController = flattenTargetHeightController;\n    \n    // Update palette when controls change from dat-gui\n    brushTypeController.onChange(() => {\n        if ((window as any).brushPalette) {\n            updatePaletteSelection((window as any).brushPalette, controls);\n        }\n    });\n    brushSizeController.onChange(() => {\n        if ((window as any).brushPalette) {\n            updatePaletteSelection((window as any).brushPalette, controls);\n        }\n    });\n    brushStrengthController.onChange(() => {\n        if ((window as any).brushPalette) {\n            updatePaletteSelection((window as any).brushPalette, controls);\n        }\n    });\n    brushOperationController.onChange(() => {\n        if ((window as any).brushPalette) {\n            updatePaletteSelection((window as any).brushPalette, controls);\n        }\n    });\n    \n    // Rendering Parameters\n    var renderingpara = gui.addFolder('Rendering Parameters');\n    renderingpara.add(controls, 'WaterTransparency', 0.0, 1.0);\n    renderingpara.add(controls, 'TerrainPlatte', { AlpineMtn: 0, Desert: 1, Jungle: 2 });\n    renderingpara.add(controls, 'SnowRange', 0.0, 100.0);\n    renderingpara.add(controls, 'ForestRange', 0.0, 50.0);\n    renderingpara.add(controls, 'ShowFlowTrace');\n    renderingpara.add(controls, 'SedimentTrace');\n    renderingpara.add(controls, 'showScattering');\n    renderingpara.add(controls, 'enableBilateralBlur');\n    var renderingparalightpos = renderingpara.addFolder('sunPos/Dir');\n    renderingparalightpos.add(controls, 'lightPosX', -1.0, 1.0);\n    renderingparalightpos.add(controls, 'lightPosY', 0.0, 1.0);\n    renderingparalightpos.add(controls, 'lightPosZ', -1.0, 1.0);\n    renderingparalightpos.open();\n    renderingpara.open();\n    \n    return {\n        gui,\n        controllers: {\n            brushTypeController,\n            brushSizeController,\n            brushStrengthController,\n            brushOperationController,\n            flattenTargetHeightController\n        }\n    };\n}\n\n","import {vec2, vec3} from 'gl-matrix';\n\n// Configuration constants for adaptive raycasting\nconst INITIAL_STEP_SIZE = 0.05;              // Larger step for initial traversal\nconst REFINEMENT_STEP_SIZE = 0.0005;        // Smaller step near terrain (reduced from 0.001 for better precision)\nconst ULTRA_REFINEMENT_STEP_SIZE = 0.00025; // Ultra-small step when very close to terrain\nconst TERRAIN_PROXIMITY_THRESHOLD = 0.02;   // Distance threshold to switch to refinement\nconst MAX_RAY_DISTANCE = 10.0;               // Maximum distance to search (increased from 2.0 to prevent missed hits)\nconst MAX_ITERATIONS = 200;                  // Maximum iterations (increased from 100)\nconst BINARY_SEARCH_ITERATIONS = 12;        // Number of binary search iterations for precise intersection (balanced for performance)\nconst BINARY_SEARCH_CONVERGENCE_THRESHOLD = 0.0001; // Early exit threshold when binary search positions are close enough\n\n/**\n * Get height value from buffer at integer texel coordinates\n */\nfunction getHeightAt(x: number, y: number, simres: number, buffer: Float32Array): number {\n    // Clamp coordinates to valid range\n    const clampedX = Math.max(0, Math.min(simres - 1, Math.floor(x)));\n    const clampedY = Math.max(0, Math.min(simres - 1, Math.floor(y)));\n    const index = clampedY * simres * 4 + clampedX * 4 + 0;\n    if (index >= 0 && index < buffer.length) {\n        return buffer[index];\n    }\n    return 0;\n}\n\n/**\n * Sample height using bilinear interpolation for smooth height values\n * Clamps UV to [0, 1] and texel indices to [0, simres - 1] to prevent out-of-bounds\n */\nexport function sampleHeightBilinear(uv: vec2, simres: number, buffer: Float32Array): number {\n    // Clamp UV to [0, 1]\n    const clampedU = Math.max(0, Math.min(1, uv[0]));\n    const clampedV = Math.max(0, Math.min(1, uv[1]));\n    \n    // Calculate texel coordinates\n    const x = clampedU * simres;\n    const y = clampedV * simres;\n    \n    // Get integer and fractional parts\n    const x0 = Math.floor(x);\n    const y0 = Math.floor(y);\n    const x1 = Math.min(x0 + 1, simres - 1);\n    const y1 = Math.min(y0 + 1, simres - 1);\n    const fx = x - x0;\n    const fy = y - y0;\n    \n    // Sample 4 corners\n    const h00 = getHeightAt(x0, y0, simres, buffer);\n    const h10 = getHeightAt(x1, y0, simres, buffer);\n    const h01 = getHeightAt(x0, y1, simres, buffer);\n    const h11 = getHeightAt(x1, y1, simres, buffer);\n    \n    // Bilinear interpolation\n    const h0 = h00 * (1 - fx) + h10 * fx;\n    const h1 = h01 * (1 - fx) + h11 * fx;\n    const result = h0 * (1 - fy) + h1 * fy;\n    \n    return result;\n}\n\nexport function rayCast(\n    ro: vec3,\n    rd: vec3,\n    simres: number,\n    HightMapCpuBuf: Float32Array,\n    out: vec2\n): void {\n    out[0] = -10.0;\n    out[1] = -10.0;\n    \n    // Reusable temporary vectors to avoid allocations\n    const cur = vec3.create();\n    const prev = vec3.create();\n    const curTexSpace = vec2.create();\n    const scaledTexSpace = vec2.create();\n    const rdscaled = vec3.create();\n    const binarySearchStart = vec3.create();\n    const binarySearchEnd = vec3.create();\n    const binarySearchMid = vec3.create();\n    \n    vec3.copy(cur, ro);\n    vec3.copy(prev, ro);\n    let step = INITIAL_STEP_SIZE;\n    let totalDistance = 0.0;\n    let foundHit = false;\n    let hitPosition = vec3.create();\n    \n    // Check if ray starts below terrain - if so, use current position as hit\n    let startTexSpace = vec2.create();\n    startTexSpace[0] = (ro[0] + 0.50) / 1.0;\n    startTexSpace[1] = (ro[2] + 0.50) / 1.0;\n    if (startTexSpace[0] >= 0.0 && startTexSpace[0] <= 1.0 && \n        startTexSpace[1] >= 0.0 && startTexSpace[1] <= 1.0) {\n        // Use bilinear sampling for smooth height\n        let startHval = sampleHeightBilinear(startTexSpace, simres, HightMapCpuBuf);\n        let startTerrainHeight = startHval / simres;\n        if (ro[1] <= startTerrainHeight) {\n            // Ray starts at or below terrain, return current position\n            out[0] = startTexSpace[0];\n            out[1] = startTexSpace[1];\n            return;\n        }\n    }\n    \n    // Main ray marching loop with adaptive step sizing\n    for (let i = 0; i < MAX_ITERATIONS; ++i) {\n        // Check if we've exceeded max distance\n        if (totalDistance > MAX_RAY_DISTANCE) {\n            break;\n        }\n        \n        // Convert current position to texture space (unclamped for bounds checks)\n        curTexSpace[0] = (cur[0] + 0.50) / 1.0;\n        curTexSpace[1] = (cur[2] + 0.50) / 1.0;\n        \n        // Check bounds - early exit if out of valid terrain bounds\n        if (curTexSpace[0] < 0.0 || curTexSpace[0] > 1.0 || \n            curTexSpace[1] < 0.0 || curTexSpace[1] > 1.0) {\n            // Out of bounds, but continue if we haven't hit anything yet\n            if (!foundHit) {\n                rdscaled[0] = rd[0] * step;\n                rdscaled[1] = rd[1] * step;\n                rdscaled[2] = rd[2] * step;\n                vec3.add(cur, cur, rdscaled);\n                totalDistance += step;\n                continue;\n            } else {\n                break;\n            }\n        }\n        \n        // Use bilinear sampling for smooth height values\n        let hval = sampleHeightBilinear(curTexSpace, simres, HightMapCpuBuf);\n        let terrainHeight = hval / simres;\n        \n        // Check if we've hit the terrain (first hit detection)\n        if (cur[1] < terrainHeight) {\n            // First hit detected - store position for binary search\n            vec3.copy(hitPosition, cur);\n            vec3.copy(binarySearchStart, prev);\n            vec3.copy(binarySearchEnd, cur);\n            foundHit = true;\n            \n            // Binary search refinement for precise intersection\n            // Track best position found during search (closest to terrain surface)\n            const bestPosition = vec3.create();\n            let bestDistanceToSurface = Infinity;\n            vec3.copy(bestPosition, binarySearchEnd);\n            \n            for (let j = 0; j < BINARY_SEARCH_ITERATIONS; ++j) {\n                // Check convergence - if positions are very close, we're done\n                const searchRange = vec3.distance(binarySearchStart, binarySearchEnd);\n                if (searchRange < BINARY_SEARCH_CONVERGENCE_THRESHOLD) {\n                    break; // Converged\n                }\n                \n                vec3.lerp(binarySearchMid, binarySearchStart, binarySearchEnd, 0.5);\n                \n                // Check height at midpoint using bilinear sampling\n                let midTexSpace = vec2.create();\n                midTexSpace[0] = (binarySearchMid[0] + 0.50) / 1.0;\n                midTexSpace[1] = (binarySearchMid[2] + 0.50) / 1.0;\n                \n                if (midTexSpace[0] < 0.0 || midTexSpace[0] > 1.0 || \n                    midTexSpace[1] < 0.0 || midTexSpace[1] > 1.0) {\n                    break;\n                }\n                \n                // Use bilinear sampling for smooth height\n                let midHval = sampleHeightBilinear(midTexSpace, simres, HightMapCpuBuf);\n                let midTerrainHeight = midHval / simres;\n                \n                // Track distance to surface for best position selection\n                const distanceToSurface = Math.abs(binarySearchMid[1] - midTerrainHeight);\n                if (distanceToSurface < bestDistanceToSurface) {\n                    bestDistanceToSurface = distanceToSurface;\n                    vec3.copy(bestPosition, binarySearchMid);\n                }\n                \n                if (binarySearchMid[1] < midTerrainHeight) {\n                    // Still below terrain, move start forward\n                    vec3.copy(binarySearchStart, binarySearchMid);\n                } else {\n                    // Above terrain, move end back\n                    vec3.copy(binarySearchEnd, binarySearchMid);\n                }\n            }\n            \n            // Use the best position found during binary search (already tracked for minimal distance to surface)\n            // This avoids expensive candidate sampling while maintaining accuracy\n            vec3.copy(hitPosition, bestPosition);\n            \n            // Simple validation: if position is significantly above terrain, fall back to previous position\n            // This avoids expensive refinement passes while maintaining reasonable accuracy\n            let finalTexSpace = vec2.create();\n            finalTexSpace[0] = (hitPosition[0] + 0.50) / 1.0;\n            finalTexSpace[1] = (hitPosition[2] + 0.50) / 1.0;\n            \n            if (finalTexSpace[0] >= 0.0 && finalTexSpace[0] <= 1.0 && \n                finalTexSpace[1] >= 0.0 && finalTexSpace[1] <= 1.0) {\n                let finalHval = sampleHeightBilinear(finalTexSpace, simres, HightMapCpuBuf);\n                let finalTerrainHeight = finalHval / simres;\n                \n                // Use resolution-dependent threshold for better precision at high resolutions\n                const threshold = 0.001 * (1024 / simres);\n                \n                // If significantly above terrain, fall back to previous position\n                if (hitPosition[1] > finalTerrainHeight + threshold * 2) {\n                    vec3.copy(hitPosition, prev);\n                }\n            }\n            \n            // Convert to texture coordinates\n            out[0] = (hitPosition[0] + 0.50) / 1.0;\n            out[1] = (hitPosition[2] + 0.50) / 1.0;\n            break;\n        }\n        \n        // Adaptive step sizing: use smaller steps when approaching terrain\n        let distanceToTerrain = Math.abs(cur[1] - terrainHeight);\n        if (distanceToTerrain < TERRAIN_PROXIMITY_THRESHOLD * 0.5) {\n            // Ultra-refinement tier: very small steps when extremely close to terrain\n            step = ULTRA_REFINEMENT_STEP_SIZE;\n        } else if (distanceToTerrain < TERRAIN_PROXIMITY_THRESHOLD) {\n            step = REFINEMENT_STEP_SIZE;\n        } else if (distanceToTerrain < TERRAIN_PROXIMITY_THRESHOLD * 2) {\n            // Medium step size for intermediate distances\n            step = INITIAL_STEP_SIZE * 0.5;\n        } else {\n            step = INITIAL_STEP_SIZE;\n        }\n        \n        // Store previous position before stepping\n        vec3.copy(prev, cur);\n        \n        // Step forward along ray\n        rdscaled[0] = rd[0] * step;\n        rdscaled[1] = rd[1] * step;\n        rdscaled[2] = rd[2] * step;\n        vec3.add(cur, cur, rdscaled);\n        totalDistance += step;\n    }\n}\n\n","import { vec2, vec3 } from 'gl-matrix';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport { BufferGeometry, Ray, Vector3, Triangle, Vector2 } from 'three';\nimport { getTriangleHitPointInfo } from 'three-mesh-bvh';\n\n/**\n * BVH-based raycast function.\n * Uses three-mesh-bvh for fast raycasting against terrain geometry.\n * \n * @param rayOrigin - Ray origin in world space (vec3)\n * @param rayDirection - Ray direction in world space (normalized vec3)\n * @param bvh - MeshBVH instance built from terrain geometry\n * @param geometry - BufferGeometry of the terrain mesh\n * @param out - Output vec2 to store UV coordinates [0-1, 0-1]\n * @returns true if intersection found, false otherwise\n */\nexport function rayCastBVH(\n    rayOrigin: vec3,\n    rayDirection: vec3,\n    bvh: MeshBVH,\n    geometry: BufferGeometry,\n    out: vec2\n): boolean {\n    // Initialize output to invalid values\n    out[0] = -10.0;\n    out[1] = -10.0;\n    \n    if (!bvh || !geometry) {\n        return false;\n    }\n    \n    // Convert gl-matrix vectors to Three.js vectors\n    let origin = new Vector3(rayOrigin[0], rayOrigin[1], rayOrigin[2]);\n    const direction = new Vector3(rayDirection[0], rayDirection[1], rayDirection[2]);\n    \n    // Ensure direction is normalized (should already be, but double-check for precision)\n    const dirLength = direction.length();\n    if (dirLength > 0.0001) {\n        direction.normalize();\n    } else {\n        // Invalid direction, return false\n        return false;\n    }\n    \n    // Check if ray is nearly parallel to Y plane (flat terrain case)\n    // If the Y component of direction is very small, the ray is nearly horizontal\n    const isNearlyHorizontal = Math.abs(direction.y) < 0.05;\n    \n    // For nearly horizontal rays, use a more robust approach\n    // Try multiple ray origins slightly offset to improve hit rate on flat surfaces\n    let hit: any = null;\n    const maxDistance = isNearlyHorizontal ? 5000.0 : 1000.0; // Much longer for nearly horizontal rays\n    \n    // For nearly horizontal rays, try a slight upward offset to improve hit reliability\n    // This helps when the ray is nearly parallel to flat terrain\n    if (isNearlyHorizontal) {\n        // Try with a small upward offset first (most reliable for flat terrain)\n        const offsetOrigin = origin.clone().addScaledVector(new Vector3(0, 1, 0), 0.001);\n        const offsetRay = new Ray(offsetOrigin, direction);\n        hit = bvh.raycastFirst(offsetRay, maxDistance);\n        \n        // If offset ray didn't hit, try original\n        if (!hit || hit.distance < 0) {\n            const ray = new Ray(origin, direction);\n            hit = bvh.raycastFirst(ray, maxDistance);\n        }\n    } else {\n        // For normal rays, use standard approach\n        const ray = new Ray(origin, direction);\n        hit = bvh.raycastFirst(ray, maxDistance);\n    }\n    \n    if (hit && hit.distance >= 0) {\n        // hit.point contains the intersection point in world space\n        // hit.faceIndex contains the triangle index\n        // hit.distance contains the distance along the ray\n        \n        // For stability, always use world position to calculate UV coordinates\n        // This is more consistent than triangle interpolation, especially for flat terrain\n        // Terrain spans from -0.5 to 0.5 in X and Z (scale = 1.0)\n        const worldX = hit.point.x;\n        const worldZ = hit.point.z;\n        \n        // Convert to UV space [0, 1]\n        // Inverse of: worldX = (u - 0.5) * scale, so u = worldX / scale + 0.5\n        let u = worldX + 0.5;\n        let v = worldZ + 0.5;\n        \n        // Clamp to valid range [0, 1]\n        u = Math.max(0, Math.min(1, u));\n        v = Math.max(0, Math.min(1, v));\n        \n        // Validate UV coordinates are reasonable\n        // If they're way out of bounds, try triangle interpolation as fallback\n        if (u >= 0 && u <= 1 && v >= 0 && v <= 1) {\n            out[0] = u;\n            out[1] = v;\n        } else {\n            // Fallback to triangle interpolation if world position conversion fails\n            const hitInfo = getTriangleHitPointInfo(hit.point, geometry, hit.faceIndex, {});\n            if (hitInfo && hitInfo.uv) {\n                out[0] = Math.max(0, Math.min(1, hitInfo.uv.x));\n                out[1] = Math.max(0, Math.min(1, hitInfo.uv.y));\n            } else {\n                // Last resort: clamp the world position UV\n                out[0] = Math.max(0, Math.min(1, u));\n                out[1] = Math.max(0, Math.min(1, v));\n            }\n        }\n        \n        return true;\n    }\n    \n    return false;\n}\n\n","import {vec2} from 'gl-matrix';\nimport { BufferGeometry } from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\n\n// Simulation state variables\nexport const simresolution = 1024;\nexport const shadowMapResolution = 4096;\nexport const enableBilateralBlur = false;\n\nexport let speed = 3;\nexport let SimFramecnt = 0;\nexport let TerrainGeometryDirty = true;\nexport let PauseGeneration = false;\n// CPU buffer for raycasting - dynamically sized to match simulation resolution\nexport let HightMapCpuBuf = new Float32Array(1024 * 1024 * 4); // Initial size, will be resized\nexport let HightMapBufCounter = 0;\n\nexport function incrementHightMapBufCounter(): void {\n    HightMapBufCounter++;\n}\n\nexport function resetHightMapBufCounter(): void {\n    HightMapBufCounter = 0;\n}\n\n// Read heightmap to CPU every 200 frames for raycasting (when brush is idle)\nexport const MaxHightMapBufCounter = 200;\n\n// Read heightmap more frequently when brush is active/visible\n// Higher values reduce CPU readback cost but can make brush hover slightly stale\nexport const ActiveHeightmapReadInterval = 2; // every 2 frames when brush is pressed (base, scaled by resolution)\nexport const HoverHeightmapReadInterval = 4;  // every 4 frames when brush is visible but not pressed (base, scaled by resolution)\n\n// Determine if heightmap should be read based on brush state\n// Returns true if brush is active (read every frame) or if counter threshold reached (throttled mode)\nfunction getResolutionScale(simres: number): number {\n    const basePixels = 1024 * 1024;\n    const currentPixels = simres * simres;\n    return Math.max(1, Math.round(currentPixels / basePixels));\n}\n\nexport function shouldReadHeightmap(brushPressed: boolean, brushVisible: boolean, simres: number): boolean {\n    if (brushPressed) {\n        const scale = getResolutionScale(simres);\n        return HightMapBufCounter % (ActiveHeightmapReadInterval * scale) === 0;\n    }\n    if (brushVisible) {\n        const scale = getResolutionScale(simres);\n        return HightMapBufCounter % (HoverHeightmapReadInterval * scale) === 0;\n    }\n    return HightMapBufCounter >= MaxHightMapBufCounter;\n}\nexport let simres: number = simresolution;\n\nexport function resizeHightMapCpuBuf(newRes: number): void {\n    // Resize CPU buffer to match simulation resolution for accurate raycasting\n    HightMapCpuBuf = new Float32Array(newRes * newRes * 4);\n}\n\n// Global state\nexport let clientWidth: number;\nexport let clientHeight: number;\n// Last pointer position in client coordinates (pixels)\nexport let lastX = 0;\nexport let lastY = 0;\nexport let gl_context: WebGL2RenderingContext;\n\n// Update functions\nexport function setSimRes(newRes: number): void {\n    simres = newRes;\n}\n\nexport function setGlContext(context: WebGL2RenderingContext): void {\n    gl_context = context;\n}\n\nexport function setClientDimensions(width: number, height: number): void {\n    clientWidth = width;\n    clientHeight = height;\n}\n\nexport function setLastMousePosition(x: number, y: number): void {\n    lastX = x;\n    lastY = y;\n}\n\nexport function setPauseGeneration(value: boolean): void {\n    PauseGeneration = value;\n}\n\nexport function setSimFramecnt(value: number): void {\n    SimFramecnt = value;\n}\n\nexport function incrementSimFramecnt(): void {\n    SimFramecnt++;\n}\n\nexport function setTerrainGeometryDirty(value: boolean): void {\n    TerrainGeometryDirty = value;\n}\n\n// BVH and terrain geometry state (secondary mesh for raycasting)\nexport let terrainGeometry: BufferGeometry | null = null;\nexport let terrainBVH: MeshBVH | null = null;\n\nexport function setTerrainGeometry(geometry: BufferGeometry | null): void {\n    terrainGeometry = geometry;\n}\n\nexport function setTerrainBVH(bvh: MeshBVH | null): void {\n    terrainBVH = bvh;\n}\n\n","import { vec2, vec3, vec4, mat4 } from \"gl-matrix\";\nimport { ControlsConfig, getMouseButtonAction, isModifierPressed } from \"./controls-config\";\nimport { sampleHeightBilinear, rayCast } from \"./utils/raycast\";\nimport { rayCastBVH } from \"./utils/bvh-raycast\";\nimport Camera from \"./Camera\";\nimport { terrainGeometry, terrainBVH, simres, HightMapCpuBuf } from \"./simulation/simulation-state\";\n\n// Store original brushOperation when modifier is held (for restoration on release)\n// This is module-level state that persists across calls\nlet originalBrushOperation: number | null = null;\n\n// Export a function to get/set this for external access if needed\nexport function getOriginalBrushOperation(): number | null {\n    return originalBrushOperation;\n}\n\nexport function setOriginalBrushOperation(value: number | null): void {\n    originalBrushOperation = value;\n}\n\nexport interface BrushControls {\n    brushType: number;\n    brushSize: number;\n    brushStrenth: number;\n    brushOperation: number;\n    brushPressed: number;\n    flattenTargetHeight: number;\n    slopeStartPos: vec2;\n    slopeEndPos: vec2;\n    slopeActive: number;\n    posTemp: vec2;\n}\n\nexport interface BrushContext {\n    controls: BrushControls;\n    controlsConfig: ControlsConfig;\n    simres: number;\n    HightMapCpuBuf: Float32Array;\n    camera: Camera;\n}\n\n/**\n * Handle brush activation on mouse down\n */\nexport function handleBrushMouseDown(\n    event: MouseEvent | PointerEvent,\n    context: BrushContext\n): { shouldActivate: boolean; brushPressed: number } {\n    const { controls, controlsConfig } = context;\n    const buttonName = ['LEFT', 'MIDDLE', 'RIGHT'][event.button];\n    \n    const action = getMouseButtonAction(event.button, controlsConfig);\n    \n    if (action !== 'brushActivate') {\n        return { shouldActivate: false, brushPressed: 0 };\n    }\n    \n    let brushPressed = 1;\n    \n    // Convert brushType to number (it might be a string from UI control)\n    const brushTypeNum = Number(controls.brushType);\n    \n    // Check if secondary brush modifier is pressed (configurable, default Alt)\n    const secondaryModifier = controlsConfig.modifiers.brushSecondary;\n    const isSecondaryPressed = isModifierPressed(secondaryModifier, event);\n    \n    if (isSecondaryPressed) {\n        if (brushTypeNum === 5) {\n            // Flatten: Secondary modifier+click should set target height and NOT activate brush\n            // Store original operation if not already stored (for restoration on release)\n            if (originalBrushOperation === null) {\n                originalBrushOperation = controls.brushOperation;\n            }\n            controls.brushOperation = 1; // Secondary button (temporary override)\n            \n            // Perform a fresh raycast using the event's mouse coordinates\n            // This ensures we get the correct position for the click, not stale data from tick()\n            const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n            if (!canvas) {\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                brushPressed = 0;\n                return { shouldActivate: false, brushPressed: 0 };\n            }\n            \n            const rect = canvas.getBoundingClientRect();\n            const normalizedX = (event.clientX - rect.left) / rect.width;\n            const normalizedY = (event.clientY - rect.top) / rect.height;\n            \n            \n            // Perform fresh raycast using event coordinates and current camera matrices\n            // Update camera first to ensure matrices are current\n            context.camera.update(context.controlsConfig.camera);\n            \n            // Calculate ray from mouse coordinates (same logic as tick())\n            const viewProj = mat4.create();\n            mat4.multiply(viewProj, context.camera.projectionMatrix, context.camera.viewMatrix);\n            const invViewProj = mat4.create();\n            mat4.invert(invViewProj, viewProj);\n            \n            const mousePoint = vec4.create();\n            const mousePointEnd = vec4.create();\n            mousePoint[0] = 2.0 * normalizedX - 1.0;\n            mousePoint[1] = 1.0 - 2.0 * normalizedY;\n            mousePoint[2] = -1.0;\n            mousePoint[3] = 1.0;\n            mousePointEnd[0] = 2.0 * normalizedX - 1.0;\n            mousePointEnd[1] = 1.0 - 2.0 * normalizedY;\n            mousePointEnd[2] = -0.0;\n            mousePointEnd[3] = 1.0;\n            \n            \n            vec4.transformMat4(mousePoint, mousePoint, invViewProj);\n            vec4.transformMat4(mousePointEnd, mousePointEnd, invViewProj);\n            mousePoint[0] /= mousePoint[3];\n            mousePoint[1] /= mousePoint[3];\n            mousePoint[2] /= mousePoint[3];\n            mousePointEnd[0] /= mousePointEnd[3];\n            mousePointEnd[1] /= mousePointEnd[3];\n            mousePointEnd[2] /= mousePointEnd[3];\n            \n            const rayDir = vec3.create();\n            rayDir[0] = mousePointEnd[0] - mousePoint[0];\n            rayDir[1] = mousePointEnd[1] - mousePoint[1];\n            rayDir[2] = mousePointEnd[2] - mousePoint[2];\n            vec3.normalize(rayDir, rayDir);\n            \n            const rayOrigin = vec3.fromValues(mousePoint[0], mousePoint[1], mousePoint[2]);\n            \n            \n            // Perform raycast\n            const freshPos = vec2.create();\n            freshPos[0] = -10.0;\n            freshPos[1] = -10.0;\n            \n            if ((controls as any).raycastMethod === 'bvh' && terrainBVH && terrainGeometry) {\n                const hit = rayCastBVH(rayOrigin, rayDir, terrainBVH, terrainGeometry, freshPos);\n                if (!hit) {\n                    const heightmapPos = vec2.create();\n                    rayCast(rayOrigin, rayDir, context.simres, context.HightMapCpuBuf, heightmapPos);\n                    freshPos[0] = heightmapPos[0];\n                    freshPos[1] = heightmapPos[1];\n                }\n            } else {\n                rayCast(rayOrigin, rayDir, context.simres, context.HightMapCpuBuf, freshPos);\n            }\n            \n            \n            // Validate fresh raycast result\n            const isValidUV = freshPos[0] >= 0.0 && freshPos[0] <= 1.0 &&\n                              freshPos[1] >= 0.0 && freshPos[1] <= 1.0 &&\n                              freshPos[0] !== -10.0 && freshPos[1] !== -10.0;\n            \n            \n            if (!isValidUV) {\n                // Don't activate brush, just set target\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                brushPressed = 0;\n                return { shouldActivate: false, brushPressed: 0 };\n            }\n            \n            // Read height from fresh raycast position using bilinear interpolation\n            const brushUV = vec2.fromValues(freshPos[0], freshPos[1]);\n            \n            \n            const rawHeight = sampleHeightBilinear(brushUV, context.simres, context.HightMapCpuBuf);\n            // The shader uses currentHeight = cur.x directly, so currentHeight is in the same range as the texture\n            // The texture stores values in 0-simres range (based on terrain-vert.glsl dividing by u_SimRes)\n            // But if the value is exactly half, maybe the texture stores in a different range?\n            // Let's check: if rawHeight is in 0-simres (0-1024), and we want 0-500, we'd do rawHeight * 500 / simres\n            // But if it's exactly half, maybe we need rawHeight * 1000 / simres? Or maybe rawHeight is already in 0-500 range?\n            // Actually, the shader comparison is: (targetHeight - currentHeight) where both should be in the same range\n            // If currentHeight is in 0-simres range, then targetHeight should also be in 0-simres range\n            // But we're sending 0-500. So we need to convert rawHeight to 0-500 range to match what we're sending\n            // If the value is exactly half, maybe we need to multiply by 2?\n            const heightValue = (rawHeight * 1000.0) / context.simres; // Convert from 0-simres to 0-500, multiply by 2 to fix \"exactly half\" issue\n            \n            \n            if (heightValue !== undefined && !isNaN(heightValue) && isFinite(heightValue)) {\n                \n                // Update the controls object (shader expects 0-500 range)\n                controls.flattenTargetHeight = heightValue;\n                \n                \n                // Update the brush palette slider (this is the main UI the user sees)\n                const flattenContainer = document.querySelector('#flatten-controls') as HTMLElement;\n                if (flattenContainer) {\n                    const flattenInput = flattenContainer.querySelector('input[type=\"range\"]') as HTMLInputElement;\n                    const flattenLabel = flattenContainer.querySelector('label') as HTMLLabelElement;\n                    \n                    if (flattenInput) {\n                        flattenInput.value = heightValue.toString();\n                        flattenInput.setAttribute('value', heightValue.toString());\n                        // Trigger input event to update the label\n                        flattenInput.dispatchEvent(new Event('input', { bubbles: true }));\n                    }\n                    \n                    if (flattenLabel) {\n                        flattenLabel.textContent = `Target Height: ${heightValue.toFixed(1)}`;\n                    }\n                    \n                } else {\n                }\n                \n                // Also update DAT.GUI controller if it exists\n                const flattenTargetHeightController = (window as any).flattenTargetHeightController;\n                if (flattenTargetHeightController) {\n                    // Call updateDisplay to refresh the controller display\n                    flattenTargetHeightController.updateDisplay();\n                }\n            }\n            \n            // Don't activate brush, just set target\n            event.preventDefault();\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n            brushPressed = 0; // Don't activate brush\n            return { shouldActivate: false, brushPressed: 0 };\n            \n        } else if (brushTypeNum === 6) {\n            // Slope: Alt+click sets START point - DON'T change brushOperation for slope brush\n            // Alt is only used to set the start point, not to change operation mode\n            controls.slopeStartPos = vec2.clone(controls.posTemp);\n            \n            // Check if end point was already set\n            if (controls.slopeActive >= 1 && !vec2.equals(controls.slopeEndPos, vec2.fromValues(0.0, 0.0))) {\n                // End point was already set, now start is set - activate slope creation\n                controls.slopeActive = 2;\n                // Continue to activate brush (brushPressed = 1 is already set above)\n                // Keep brushOperation as set by palette - don't override it\n            } else {\n                // No end point set yet, just set start point and wait\n                controls.slopeActive = 1;\n                // Just set the point, don't activate brush yet\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                return { shouldActivate: false, brushPressed: 0 };\n            }\n        } else {\n            // For other brushes, Alt modifier sets brushOperation to 1 (subtract)\n            // Store original operation if not already stored (for restoration on release)\n            if (originalBrushOperation === null) {\n                originalBrushOperation = controls.brushOperation;\n            }\n            controls.brushOperation = 1; // Secondary button (temporary override)\n        }\n    } else {\n        // Don't override brushOperation - preserve the value set by palette\n        // The palette setting should be respected unless a modifier is used\n        \n        // Handle slope brush end point (primary click)\n        if (brushTypeNum === 6) {\n            controls.slopeEndPos = vec2.clone(controls.posTemp);\n            \n            // If both points were set and brush was active, just update the end point and deactivate\n            // This allows setting a new end point without activating the brush\n            if (controls.slopeActive === 2) {\n                // Keep slopeActive at 2 so both points remain set, but don't activate brush\n                // User can now Alt+click to set a new start point and drag\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                return { shouldActivate: false, brushPressed: 0 };\n            } else if (controls.slopeActive === 1 && !vec2.equals(controls.slopeStartPos, vec2.fromValues(0.0, 0.0))) {\n                // Start point was already set, now end point is set - activate slope creation\n                controls.slopeActive = 2;\n                // Continue to activate brush (brushPressed = 1 is already set above)\n            } else {\n                // End point set first, waiting for Alt+click to set start point\n                controls.slopeActive = 1;\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                return { shouldActivate: false, brushPressed: 0 };\n            }\n        }\n        \n        // Check for brush invert modifier - but not the secondary modifier (secondary modifier is for secondary operation)\n        const invertModifier = controlsConfig.modifiers.brushInvert;\n        if (invertModifier && invertModifier !== secondaryModifier) {\n            const modifierPressed = isModifierPressed(invertModifier, event);\n            \n            if (modifierPressed) {\n                originalBrushOperation = controls.brushOperation;\n                controls.brushOperation = controls.brushOperation === 0 ? 1 : 0;\n            }\n        }\n    }\n    \n    return { shouldActivate: true, brushPressed };\n}\n\n/**\n * Handle brush deactivation on mouse up\n */\nexport function handleBrushMouseUp(\n    event: MouseEvent | PointerEvent,\n    context: BrushContext\n): void {\n    const { controls } = context;\n    const action = getMouseButtonAction(event.button, context.controlsConfig);\n    \n    if (action === 'brushActivate') {\n        // For slope brush, keep both points set after releasing (slopeActive stays at 2)\n        // This allows setting a new start point with Alt+click without needing to set end point again\n        const brushTypeNum = Number(controls.brushType);\n        if (brushTypeNum === 6 && controls.slopeActive === 2) {\n            // slopeActive stays at 2, so both points remain available\n        }\n        \n        // Restore original brushOperation if it was inverted\n        if (originalBrushOperation !== null) {\n            controls.brushOperation = originalBrushOperation;\n            originalBrushOperation = null;\n        }\n    }\n}\n\n/**\n * Update brush state in tick loop\n */\nexport function updateBrushState(\n    pos: vec2,\n    context: BrushContext\n): void {\n    const { controls } = context;\n    const brushTypeNum = Number(controls.brushType);\n    \n    // Handle flatten brush target height setting (secondary modifier+click sets target to center height)\n    if (brushTypeNum === 5 && controls.brushPressed === 1 && controls.brushOperation === 1) {\n        // Secondary modifier is pressed - read target height from CPU buffer at brush center using bilinear interpolation\n        const brushUV = vec2.fromValues(pos[0], pos[1]);\n        const rawHeight = sampleHeightBilinear(brushUV, context.simres, context.HightMapCpuBuf);\n        const heightValue = rawHeight / context.simres; // Normalize height value\n        \n        if (heightValue !== undefined && !isNaN(heightValue)) {\n            // Set the value on the controls object\n            controls.flattenTargetHeight = heightValue;\n            \n            // Update the brush palette slider (this is the main UI the user sees)\n            const flattenContainer = document.querySelector('#flatten-controls') as HTMLElement;\n            if (flattenContainer) {\n                const flattenInput = flattenContainer.querySelector('input[type=\"range\"]') as HTMLInputElement;\n                const flattenLabel = flattenContainer.querySelector('label') as HTMLLabelElement;\n                \n                if (flattenInput) {\n                    flattenInput.value = heightValue.toString();\n                    flattenInput.setAttribute('value', heightValue.toString());\n                    // Trigger input event to update the label\n                    flattenInput.dispatchEvent(new Event('input', { bubbles: true }));\n                }\n                \n                if (flattenLabel) {\n                    flattenLabel.textContent = `Target Height: ${heightValue.toFixed(1)}`;\n                }\n            }\n            \n            // Also update DAT.GUI controller if it exists\n            const flattenTargetHeightController = (window as any).flattenTargetHeightController;\n            if (flattenTargetHeightController) {\n                flattenTargetHeightController.updateDisplay();\n            }\n        }\n    }\n    \n    // Handle slope brush - once both points are set, continuously apply slope\n    if (brushTypeNum === 6) {\n        // When both points are set and brush is active, apply slope continuously\n        if (controls.brushPressed === 1 && controls.slopeActive === 2) {\n            // Both points are set, slope is being applied\n            // The shader will handle the actual slope creation\n            // No need to update positions here - they're already set\n        }\n    }\n}\n\n","import {vec2} from 'gl-matrix';\n\n// Water source structure\nexport interface WaterSource {\n    position: vec2;  // Position on terrain (UV coordinates)\n    size: number;    // Source radius\n    strength: number; // Water emission strength\n}\n\n// Maximum number of water sources\nexport const MAX_WATER_SOURCES = 16;\n\n// Array to store multiple water sources\nexport let waterSources: WaterSource[] = [];\n\n// Functions to manage water sources\nexport function addWaterSource(position: vec2, size: number, strength: number): boolean {\n    if (waterSources.length < MAX_WATER_SOURCES) {\n        const newSource: WaterSource = {\n            position: vec2.clone(position),\n            size: size,\n            strength: strength\n        };\n        waterSources.push(newSource);\n        return true;\n    }\n    return false;\n}\n\nexport function removeWaterSource(index: number): void {\n    if (index >= 0 && index < waterSources.length) {\n        waterSources.splice(index, 1);\n    }\n}\n\nexport function removeNearestWaterSource(position: vec2): boolean {\n    if (waterSources.length === 0) return false;\n    \n    let nearestIndex = 0;\n    let nearestDist = Number.MAX_VALUE;\n    \n    for (let i = 0; i < waterSources.length; i++) {\n        const dist = vec2.distance(waterSources[i].position, position);\n        if (dist < nearestDist) {\n            nearestDist = dist;\n            nearestIndex = i;\n        }\n    }\n    \n    waterSources.splice(nearestIndex, 1);\n    return true;\n}\n\nexport function clearAllWaterSources(): void {\n    waterSources = [];\n}\n\nexport function getWaterSourceCount(): number {\n    return waterSources.length;\n}\n\n","import { vec2 } from 'gl-matrix';\nimport { \n    getKeyAction, \n    getMouseButtonAction, \n    isBrushActivate, \n    ControlsConfig, \n    isModifierPressed \n} from '../controls-config';\nimport { \n    handleBrushMouseDown, \n    handleBrushMouseUp, \n    BrushContext, \n    BrushControls,\n    getOriginalBrushOperation,\n    setOriginalBrushOperation\n} from '../brush-handler';\nimport { \n    MAX_WATER_SOURCES,\n    addWaterSource,\n    removeNearestWaterSource,\n    clearAllWaterSources,\n    getWaterSourceCount\n} from '../utils/water-sources';\nimport { simres, HightMapCpuBuf } from '../simulation/simulation-state';\nimport Camera from '../Camera';\n\nexport interface Controls {\n    [key: string]: any;\n    brushPressed: number;\n    brushOperation: number;\n    brushSize: number;\n    brushStrenth: number;\n    brushType: number;\n    posTemp: vec2;\n    sourceCount: number;\n    flattenTargetHeight: number;\n    slopeStartPos: vec2;\n    slopeEndPos: vec2;\n    slopeActive: number;\n}\n\nexport interface EventHandlers {\n    onKeyDown: (event: KeyboardEvent) => void;\n    onKeyUp: (event: KeyboardEvent) => void;\n    onMouseDown: (event: MouseEvent | PointerEvent) => void;\n    onMouseUp: (event: MouseEvent | PointerEvent) => void;\n}\n\nexport function createEventHandlers(\n    controls: Controls,\n    controlsConfig: ControlsConfig,\n    camera: Camera\n): EventHandlers {\n    function onKeyDown(event: KeyboardEvent) {\n        const key = event.key.toLowerCase();\n        const action = getKeyAction(key, controlsConfig);\n        \n        // Track WASD movement keys (don't interfere with brush controls)\n        if (controlsConfig.camera.movement.enableWASD) {\n            if (key === 'w' || key === 'a' || key === 's' || key === 'd') {\n                camera.addMovementKey(key);\n            }\n            // Space for up movement\n            if (key === ' ' && controlsConfig.camera.movement.enableVerticalMovement) {\n                camera.addMovementKey(' ');\n            }\n            // Shift for down movement (only if not used as brush modifier)\n            if (key === 'shift' && controlsConfig.camera.movement.enableVerticalMovement) {\n                // Only add if Shift is not being used as a brush modifier\n                if (controlsConfig.modifiers.brushInvert !== 'Shift' && \n                    controlsConfig.modifiers.brushSizeScroll !== 'Shift' &&\n                    controlsConfig.modifiers.brushSecondary !== 'Shift') {\n                    camera.addMovementKey('shift');\n                }\n            }\n        }\n        \n        // Check if this key is brushActivate (could be keyboard key OR mouse button string)\n        if (isBrushActivate(key, controlsConfig)) {\n            controls.brushPressed = 1;\n        } else if (action === 'brushActivate') {\n            controls.brushPressed = 1;\n        } else {\n            // Only reset if another key is pressed (not if mouse button is the activator)\n            if (controlsConfig.keys.brushActivate !== 'LEFT' && \n                controlsConfig.keys.brushActivate !== 'MIDDLE' && \n                controlsConfig.keys.brushActivate !== 'RIGHT') {\n                controls.brushPressed = 0;\n            }\n        }\n        \n        // If brush is active, check if modifier is pressed to invert operation\n        if (controls.brushPressed === 1) {\n            const invertModifier = controlsConfig.modifiers.brushInvert;\n            if (invertModifier) {\n                const modifierPressed = isModifierPressed(invertModifier, event);\n                \n                // Check if this is the modifier key being pressed\n                const isModifierKey = \n                    (invertModifier === 'Ctrl' && (key === 'control' || key === 'meta')) ||\n                    (invertModifier === 'Shift' && key === 'shift') ||\n                    (invertModifier === 'Alt' && key === 'alt');\n                \n                if (isModifierKey && modifierPressed && getOriginalBrushOperation() === null) {\n                    // Modifier just pressed while brush is active - invert operation\n                    setOriginalBrushOperation(controls.brushOperation);\n                    controls.brushOperation = controls.brushOperation === 0 ? 1 : 0;\n                    console.log('[DEBUG] Brush operation inverted on modifier press to:', controls.brushOperation === 0 ? 'Add' : 'Subtract');\n                }\n            }\n        }\n\n        if (action === 'permanentWaterSource') {\n            // Check if Shift is held for removal\n            if (event.shiftKey) {\n                // Remove nearest source to cursor\n                if (removeNearestWaterSource(controls.posTemp)) {\n                    controls.sourceCount = getWaterSourceCount();\n                    console.log(`Removed water source. Remaining: ${getWaterSourceCount()}`);\n                }\n            } else {\n                // Add new source at cursor position\n                if (addWaterSource(controls.posTemp, controls.brushSize, controls.brushStrenth)) {\n                    controls.sourceCount = getWaterSourceCount();\n                    console.log(`Added water source at (${controls.posTemp[0].toFixed(3)}, ${controls.posTemp[1].toFixed(3)}). Total: ${getWaterSourceCount()}`);\n                } else {\n                    console.log(`Maximum ${MAX_WATER_SOURCES} water sources reached`);\n                }\n            }\n        }\n        \n        if (action === 'removePermanentSource') {\n            // Remove all sources\n            clearAllWaterSources();\n            controls.sourceCount = 0;\n            console.log('Removed all water sources');\n        }\n    }\n\n    function onKeyUp(event: KeyboardEvent) {\n        const key = event.key.toLowerCase();\n        const action = getKeyAction(key, controlsConfig);\n        \n        // Remove WASD movement keys\n        if (controlsConfig.camera.movement.enableWASD) {\n            if (key === 'w' || key === 'a' || key === 's' || key === 'd') {\n                camera.removeMovementKey(key);\n            }\n            // Space for up movement\n            if (key === ' ') {\n                camera.removeMovementKey(' ');\n            }\n            // Shift for down movement\n            if (key === 'shift') {\n                camera.removeMovementKey('shift');\n            }\n        }\n        \n        // Only deactivate if this key was the brush activator (not if mouse button is the activator)\n        if (isBrushActivate(key, controlsConfig) || action === 'brushActivate') {\n            controls.brushPressed = 0;\n        }\n        \n        // If brush is active and modifier is released, restore original operation\n        if (controls.brushPressed === 1) {\n            const invertModifier = controlsConfig.modifiers.brushInvert;\n            if (invertModifier) {\n                const isModifierKey = \n                    (invertModifier === 'Ctrl' && (key === 'control' || key === 'meta')) ||\n                    (invertModifier === 'Shift' && key === 'shift') ||\n                    (invertModifier === 'Alt' && key === 'alt');\n                \n                if (isModifierKey && getOriginalBrushOperation() !== null) {\n                    const original = getOriginalBrushOperation();\n                    if (original !== null) {\n                        controls.brushOperation = original;\n                        setOriginalBrushOperation(null);\n                    }\n                    console.log('[DEBUG] Brush operation restored on modifier release to:', controls.brushOperation === 0 ? 'Add' : 'Subtract');\n                }\n            }\n        }\n    }\n\n    function onMouseDown(event: MouseEvent | PointerEvent) {\n        // ALWAYS log first thing - if this doesn't show, handler isn't being called\n        const buttonName = ['LEFT', 'MIDDLE', 'RIGHT'][event.button];\n        console.log('[DEBUG] onMouseDown CALLED - button:', event.button, 'buttonName:', buttonName, 'target:', event.target);\n        console.log('[DEBUG] Config - keys.brushActivate:', controlsConfig.keys.brushActivate, 'mouse.brushActivate:', controlsConfig.mouse.brushActivate);\n        \n        const action = getMouseButtonAction(event.button, controlsConfig);\n        console.log('[DEBUG] onMouseDown - action:', action, 'brushType:', controls.brushType);\n        \n        if (action === 'brushActivate') {\n            const brushContext: BrushContext = {\n                controls: controls as BrushControls,\n                controlsConfig: controlsConfig,\n                simres: Number(simres), // Ensure it's a number, not a string\n                HightMapCpuBuf: HightMapCpuBuf,\n                camera: camera\n            };\n            \n            const result = handleBrushMouseDown(event, brushContext);\n            \n            if (result.shouldActivate) {\n                controls.brushPressed = result.brushPressed;\n                // Prevent OrbitControls from handling this event\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n                console.log('[DEBUG] brushPressed set to:', controls.brushPressed);\n                return; // Exit early to prevent other handlers\n            } else {\n                // Brush handler already prevented default and stopped propagation\n                return;\n            }\n        } else {\n            console.log('[DEBUG] Not a brush action - button:', event.button, 'buttonName:', buttonName);\n            console.log('[DEBUG] Expected - keys.brushActivate:', controlsConfig.keys.brushActivate, 'mouse.brushActivate:', controlsConfig.mouse.brushActivate);\n        }\n    }\n\n    function onMouseUp(event: MouseEvent | PointerEvent) {\n        console.log('[DEBUG] onMouseUp CALLED - button:', event.button, 'target:', event.target);\n        const action = getMouseButtonAction(event.button, controlsConfig);\n        console.log('[DEBUG] onMouseUp - action:', action);\n        \n        if (action === 'brushActivate') {\n            console.log('[DEBUG] Deactivating brush - setting brushPressed = 0');\n            controls.brushPressed = 0;\n            \n            const brushContext: BrushContext = {\n                controls: controls as BrushControls,\n                controlsConfig: controlsConfig,\n                simres: Number(simres), // Ensure it's a number, not a string\n                HightMapCpuBuf: HightMapCpuBuf,\n                camera: camera\n            };\n            \n            handleBrushMouseUp(event, brushContext);\n            \n            // Prevent OrbitControls from handling this event\n            event.preventDefault();\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n        }\n    }\n\n    return {\n        onKeyDown,\n        onKeyUp,\n        onMouseDown,\n        onMouseUp\n    };\n}\n\n","import { BufferGeometry, BufferAttribute } from 'three';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { sampleHeightBilinear } from './raycast';\n\n/**\n * Creates a secondary Three.js BufferGeometry from heightmap data.\n * This geometry is used ONLY for BVH raycasting, not for rendering.\n * The rendering system continues to use the plane + heightmap texture approach.\n * \n * @param simres - Simulation resolution (heightmap size)\n * @param heightMapBuffer - CPU buffer containing height data (Float32Array)\n * @param scale - Scale factor for terrain (default: 1.0)\n * @returns Three.js BufferGeometry ready for BVH building\n */\nexport function createTerrainGeometry(\n    simres: number,\n    heightMapBuffer: Float32Array,\n    scale: number = 1.0\n): BufferGeometry {\n    const geometry = new BufferGeometry();\n    \n    // Calculate number of vertices (grid size)\n    const width = simres;\n    const height = simres;\n    const numVertices = width * height;\n    \n    // Create position array (x, y, z for each vertex)\n    const positions = new Float32Array(numVertices * 3);\n    // Create UV array for accurate UV interpolation from triangle hits\n    const uvs = new Float32Array(numVertices * 2);\n    const indices: number[] = [];\n    \n    // Generate vertices from heightmap\n    // Use bilinear interpolation to match shader texture sampling and heightmap raycast\n    let posIdx = 0;\n    const uv = vec2.create();\n    for (let z = 0; z < height; z++) {\n        for (let x = 0; x < width; x++) {\n            // Calculate UV coordinates in [0, 1] range\n            // Match Plane geometry UV calculation: uvs are x * normalize where normalize = 1.0 / width\n            const u = x / (width - 1);\n            const v = z / (height - 1);\n            \n            // Use bilinear interpolation to sample height (matches shader texture() and heightmap raycast)\n            uv[0] = u;\n            uv[1] = v;\n            const heightValue = sampleHeightBilinear(uv, simres, heightMapBuffer);\n            \n            // Convert height to world space (matching terrain-vert.glsl calculation)\n            // In shader: yval = texture(hightmap, vs_Uv).x / u_SimRes\n            const worldHeight = heightValue / simres;\n            \n            // Position vertices in world space\n            // Match coordinate system: terrain spans from -0.5 to 0.5 in X and Z\n            // This matches the Plane geometry: x * normalize * scale + center - scale * 0.5\n            // where center is (0,0,0) and scale is (1,1)\n            const worldX = (u - 0.5) * scale;\n            const worldY = worldHeight;\n            const worldZ = (v - 0.5) * scale;\n            \n            positions[posIdx++] = worldX;\n            positions[posIdx++] = worldY;\n            positions[posIdx++] = worldZ;\n            \n            // Store UV coordinates for this vertex (for accurate interpolation)\n            const uvIdx = (z * width + x) * 2;\n            uvs[uvIdx] = u;\n            uvs[uvIdx + 1] = v;\n        }\n    }\n    \n    // Generate indices for triangles (two triangles per quad)\n    for (let z = 0; z < height - 1; z++) {\n        for (let x = 0; x < width - 1; x++) {\n            const topLeft = z * width + x;\n            const topRight = z * width + x + 1;\n            const bottomLeft = (z + 1) * width + x;\n            const bottomRight = (z + 1) * width + x + 1;\n            \n            // First triangle: topLeft, bottomLeft, topRight\n            indices.push(topLeft, bottomLeft, topRight);\n            \n            // Second triangle: topRight, bottomLeft, bottomRight\n            indices.push(topRight, bottomLeft, bottomRight);\n        }\n    }\n    \n    // Set geometry attributes\n    geometry.setAttribute('position', new BufferAttribute(positions, 3));\n    geometry.setAttribute('uv', new BufferAttribute(uvs, 2));\n    geometry.setIndex(indices);\n    \n    // Compute bounding box for BVH\n    geometry.computeBoundingBox();\n    \n    return geometry;\n}\n\n/**\n * Updates an existing terrain geometry with new heightmap data.\n * This is more efficient than creating a new geometry each time.\n * \n * @param geometry - Existing BufferGeometry to update\n * @param simres - Simulation resolution\n * @param heightMapBuffer - Updated height data\n * @param scale - Scale factor\n */\nexport function updateTerrainGeometry(\n    geometry: BufferGeometry,\n    simres: number,\n    heightMapBuffer: Float32Array,\n    scale: number = 1.0\n): void {\n    const positionAttribute = geometry.getAttribute('position') as BufferAttribute;\n    const uvAttribute = geometry.getAttribute('uv') as BufferAttribute;\n    \n    if (!positionAttribute) {\n        console.warn('Terrain geometry has no position attribute');\n        return;\n    }\n    \n    const positions = positionAttribute.array as Float32Array;\n    const uvs = uvAttribute ? uvAttribute.array as Float32Array : null;\n    const width = simres;\n    const height = simres;\n    \n    // Update vertex positions using bilinear interpolation\n    let posIdx = 0;\n    let uvIdx = 0;\n    const uv = vec2.create();\n    for (let z = 0; z < height; z++) {\n        for (let x = 0; x < width; x++) {\n            const u = x / (width - 1);\n            const v = z / (height - 1);\n            \n            // Use bilinear interpolation to match shader sampling\n            uv[0] = u;\n            uv[1] = v;\n            const heightValue = sampleHeightBilinear(uv, simres, heightMapBuffer);\n            \n            const worldHeight = heightValue / simres;\n            const worldX = (u - 0.5) * scale;\n            const worldY = worldHeight;\n            const worldZ = (v - 0.5) * scale;\n            \n            positions[posIdx++] = worldX;\n            positions[posIdx++] = worldY;\n            positions[posIdx++] = worldZ;\n            \n            // Update UV coordinates if they exist\n            if (uvs) {\n                uvs[uvIdx++] = u;\n                uvs[uvIdx++] = v;\n            }\n        }\n    }\n    \n    // Mark attributes as needing update\n    positionAttribute.needsUpdate = true;\n    if (uvAttribute) {\n        uvAttribute.needsUpdate = true;\n    }\n    \n    // Recompute bounding box\n    geometry.computeBoundingBox();\n}\n\n","import { simres, shadowMapResolution } from './simulation-state';\n\n// We need to get gl_context from the caller, so we'll pass it as a parameter\nlet gl_context: WebGL2RenderingContext;\n\nexport function setGlContext(context: WebGL2RenderingContext): void {\n    gl_context = context;\n}\n\n// ================ frame buffers ============\nexport let frame_buffer: WebGLFramebuffer;\nexport let shadowMap_frame_buffer: WebGLFramebuffer;\nexport let deferred_frame_buffer: WebGLFramebuffer;\n\n// ================  render buffers ============\nexport let render_buffer: WebGLRenderbuffer;\nexport let shadowMap_render_buffer: WebGLRenderbuffer;\nexport let deferred_render_buffer: WebGLRenderbuffer;\n\n// ================ muti-renderpasses used textures ============\nexport let shadowMap_tex: WebGLTexture;\nexport let scene_depth_tex: WebGLTexture;\nexport let bilateral_filter_horizontal_tex: WebGLTexture;\nexport let bilateral_filter_vertical_tex: WebGLTexture;\nexport let color_pass_tex: WebGLTexture;\nexport let color_pass_reflection_tex: WebGLTexture;\nexport let scatter_pass_tex: WebGLTexture;\n\n// ================ simulation textures ===================\nexport let read_terrain_tex: WebGLTexture;\nexport let write_terrain_tex: WebGLTexture;\nexport let read_flux_tex: WebGLTexture;\nexport let write_flux_tex: WebGLTexture;\nexport let read_terrain_flux_tex: WebGLTexture; // thermal\nexport let write_terrain_flux_tex: WebGLTexture;\nexport let read_maxslippage_tex: WebGLTexture;\nexport let write_maxslippage_tex: WebGLTexture;\nexport let read_vel_tex: WebGLTexture;\nexport let write_vel_tex: WebGLTexture;\nexport let read_sediment_tex: WebGLTexture;\nexport let write_sediment_tex: WebGLTexture;\nexport let terrain_nor: WebGLTexture;\nexport let read_sediment_blend: WebGLTexture;\nexport let write_sediment_blend: WebGLTexture;\nexport let sediment_advect_a: WebGLTexture;\nexport let sediment_advect_b: WebGLTexture;\n\n// Height map texture for importing external height maps\nexport let heightmap_tex: WebGLTexture | null = null;\n\nfunction LE_create_texture(w: number, h: number, samplingType: number): WebGLTexture {\n    let new_tex = gl_context.createTexture();\n    gl_context.bindTexture(gl_context.TEXTURE_2D, new_tex);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, w, h, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, samplingType);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, samplingType);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n    return new_tex;\n}\n\nfunction LE_recreate_texture(w: number, h: number, samplingType: number, texHandle: WebGLTexture): void {\n    gl_context.bindTexture(gl_context.TEXTURE_2D, texHandle);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, w, h, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, samplingType);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, samplingType);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n}\n\nfunction LE_create_screen_texture(w: number, h: number, samplingType: number): WebGLTexture {\n    let new_tex = gl_context.createTexture();\n    gl_context.bindTexture(gl_context.TEXTURE_2D, new_tex);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, w, h, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, samplingType);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, samplingType);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n    return new_tex;\n}\n\nexport function resizeTextures4Simulation(context: WebGL2RenderingContext, simres: number): void {\n    gl_context = context;\n    let simulationTextureSampler = gl_context.LINEAR;\n    // recreate all textures related to simulation\n    LE_recreate_texture(simres, simres, simulationTextureSampler, read_terrain_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, write_terrain_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, read_flux_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, write_flux_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, read_terrain_flux_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, write_terrain_flux_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, read_maxslippage_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, write_maxslippage_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, read_vel_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, write_vel_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, read_sediment_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, write_sediment_tex);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, terrain_nor);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, read_sediment_blend);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, write_sediment_blend);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, sediment_advect_a);\n    LE_recreate_texture(simres, simres, simulationTextureSampler, sediment_advect_b);\n\n    // recreate all framebuffer/renderbuffer related to simulation\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, render_buffer);\n    gl_context.renderbufferStorage(gl_context.RENDERBUFFER, gl_context.DEPTH_COMPONENT16,\n        simres, simres);\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, null);\n\n    // recreate CPU read texture buffer for simulation & User interaction\n    // Note: HightMapCpuBuf is imported from simulation-state, but we need to update it\n    // This will be handled by the caller\n}\n\nexport function setupFramebufferandtextures(context: WebGL2RenderingContext, simres: number): void {\n    gl_context = context;\n    let simulationTextureSampler = gl_context.LINEAR;\n    // Noise generated data from GPU texture, include population density, water distribution, terrain elevation...\n    read_terrain_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n    write_terrain_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    read_flux_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n    write_flux_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    read_terrain_flux_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n    write_terrain_flux_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    read_maxslippage_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n    write_maxslippage_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    read_vel_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n    write_vel_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    read_sediment_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n    write_sediment_tex = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    terrain_nor = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    read_sediment_blend = LE_create_texture(simres, simres, simulationTextureSampler);\n    write_sediment_blend = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    sediment_advect_a = LE_create_texture(simres, simres, simulationTextureSampler);\n    sediment_advect_b = LE_create_texture(simres, simres, simulationTextureSampler);\n\n    shadowMap_tex = LE_create_screen_texture(shadowMapResolution, shadowMapResolution, gl_context.LINEAR);\n    scene_depth_tex = LE_create_screen_texture(window.innerWidth, window.innerHeight, gl_context.LINEAR);\n    bilateral_filter_horizontal_tex = LE_create_screen_texture(window.innerWidth, window.innerHeight, gl_context.LINEAR);\n    bilateral_filter_vertical_tex = LE_create_screen_texture(window.innerWidth, window.innerHeight, gl_context.LINEAR);\n    color_pass_tex = LE_create_screen_texture(window.innerWidth, window.innerHeight, gl_context.LINEAR);\n    color_pass_reflection_tex = LE_create_screen_texture(window.innerWidth, window.innerHeight, gl_context.LINEAR);\n    scatter_pass_tex = LE_create_screen_texture(window.innerWidth, window.innerHeight, gl_context.LINEAR);\n\n    shadowMap_frame_buffer = gl_context.createFramebuffer();\n    shadowMap_render_buffer = gl_context.createRenderbuffer();\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, shadowMap_render_buffer);\n    gl_context.renderbufferStorage(gl_context.RENDERBUFFER, gl_context.DEPTH_COMPONENT16,\n        shadowMapResolution, shadowMapResolution);\n\n    deferred_frame_buffer = gl_context.createFramebuffer();\n    deferred_render_buffer = gl_context.createRenderbuffer();\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, deferred_render_buffer);\n    gl_context.renderbufferStorage(gl_context.RENDERBUFFER, gl_context.DEPTH_COMPONENT16,\n        window.innerWidth, window.innerHeight);\n\n    frame_buffer = gl_context.createFramebuffer();\n    render_buffer = gl_context.createRenderbuffer();\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, render_buffer);\n    gl_context.renderbufferStorage(gl_context.RENDERBUFFER, gl_context.DEPTH_COMPONENT16,\n        simres, simres);\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, null);\n}\n\nexport function resizeScreenTextures(): void {\n    gl_context.bindTexture(gl_context.TEXTURE_2D, color_pass_reflection_tex);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, window.innerWidth, window.innerHeight, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D, scatter_pass_tex);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, window.innerWidth, window.innerHeight, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D, color_pass_tex);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, window.innerWidth, window.innerHeight, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D, bilateral_filter_vertical_tex);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, window.innerWidth, window.innerHeight, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D, bilateral_filter_horizontal_tex);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, window.innerWidth, window.innerHeight, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D, scene_depth_tex);\n    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, window.innerWidth, window.innerHeight, 0,\n        gl_context.RGBA, gl_context.FLOAT, null);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, gl_context.LINEAR);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, deferred_render_buffer);\n    gl_context.renderbufferStorage(gl_context.RENDERBUFFER, gl_context.DEPTH_COMPONENT16,\n        window.innerWidth, window.innerHeight);\n}\n\nexport function setHeightMapTexture(tex: WebGLTexture | null): void {\n    heightmap_tex = tex;\n}\n\nexport function getHeightMapTexture(): WebGLTexture | null {\n    return heightmap_tex;\n}\n\n// Functions to swap ping-pong textures\nexport function swapTerrainTextures(): void {\n    const tmp = read_terrain_tex;\n    read_terrain_tex = write_terrain_tex;\n    write_terrain_tex = tmp;\n}\n\nexport function swapFluxTextures(): void {\n    const tmp = read_flux_tex;\n    read_flux_tex = write_flux_tex;\n    write_flux_tex = tmp;\n}\n\nexport function swapVelTextures(): void {\n    const tmp = read_vel_tex;\n    read_vel_tex = write_vel_tex;\n    write_vel_tex = tmp;\n}\n\nexport function swapSedimentTextures(): void {\n    const tmp = read_sediment_tex;\n    read_sediment_tex = write_sediment_tex;\n    write_sediment_tex = tmp;\n}\n\nexport function swapSedimentBlendTextures(): void {\n    const tmp = read_sediment_blend;\n    read_sediment_blend = write_sediment_blend;\n    write_sediment_blend = tmp;\n}\n\nexport function swapMaxSlippageTextures(): void {\n    const tmp = read_maxslippage_tex;\n    read_maxslippage_tex = write_maxslippage_tex;\n    write_maxslippage_tex = tmp;\n}\n\nexport function swapTerrainFluxTextures(): void {\n    const tmp = read_terrain_flux_tex;\n    read_terrain_flux_tex = write_terrain_flux_tex;\n    write_terrain_flux_tex = tmp;\n}\n\nexport function swapBilateralFilterTextures(): void {\n    const tmp = bilateral_filter_horizontal_tex;\n    bilateral_filter_horizontal_tex = bilateral_filter_vertical_tex;\n    bilateral_filter_vertical_tex = tmp;\n}\n\n","import { getHeightMapTexture, setHeightMapTexture } from '../simulation/texture-management';\nimport { setTerrainGeometryDirty } from '../simulation/simulation-state';\n\nexport interface Controls {\n    TerrainHeight: number;\n}\n\nexport function createHeightMapLoader(\n    gl_context: any,\n    simres: number,\n    controls: Controls\n) {\n    function loadHeightMap() {\n        const input = document.createElement('input');\n        input.type = 'file';\n        input.accept = 'image/*';\n        input.onchange = (e: Event) => {\n            const file = (e.target as HTMLInputElement).files?.[0];\n            if (!file) return;\n            \n            const reader = new FileReader();\n            reader.onload = (event: ProgressEvent<FileReader>) => {\n                const img = new Image();\n                img.onload = () => {\n                    // Create a canvas to process the image\n                    const canvas = document.createElement('canvas');\n                    canvas.width = simres;\n                    canvas.height = simres;\n                    const ctx = canvas.getContext('2d');\n                    if (!ctx) return;\n                    \n                    // Draw and scale the image to match simulation resolution\n                    ctx.drawImage(img, 0, 0, simres, simres);\n                    const imageData = ctx.getImageData(0, 0, simres, simres);\n                    \n                    // Convert image data to height map texture\n                    // Use grayscale (red channel) as height, scale to terrain height range\n                    const heightData = new Float32Array(simres * simres * 4);\n                    const maxHeight = controls.TerrainHeight * 120.0;\n                    \n                    for (let i = 0; i < simres * simres; i++) {\n                        const r = imageData.data[i * 4];\n                        const g = imageData.data[i * 4 + 1];\n                        const b = imageData.data[i * 4 + 2];\n                        // Convert RGB to grayscale and normalize to 0-1, then scale\n                        const gray = (r * 0.299 + g * 0.587 + b * 0.114) / 255.0;\n                        const height = gray * maxHeight;\n                        \n                        heightData[i * 4] = height;      // R: terrain height\n                        heightData[i * 4 + 1] = 0.0;   // G: water (start with no water)\n                        heightData[i * 4 + 2] = 0.0;   // B: rock material\n                        heightData[i * 4 + 3] = 1.0;   // A: alpha\n                    }\n                    \n                    // Create or update height map texture\n                    let heightmap_tex = getHeightMapTexture();\n                    if (!heightmap_tex) {\n                        heightmap_tex = gl_context.createTexture();\n                    }\n                    \n                    gl_context.bindTexture(gl_context.TEXTURE_2D, heightmap_tex);\n                    gl_context.texImage2D(gl_context.TEXTURE_2D, 0, gl_context.RGBA32F, \n                        simres, simres, 0, gl_context.RGBA, gl_context.FLOAT, heightData);\n                    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MIN_FILTER, gl_context.LINEAR);\n                    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_MAG_FILTER, gl_context.LINEAR);\n                    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_S, gl_context.CLAMP_TO_EDGE);\n                    gl_context.texParameteri(gl_context.TEXTURE_2D, gl_context.TEXTURE_WRAP_T, gl_context.CLAMP_TO_EDGE);\n                    gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n                    \n                    // Store the height map texture\n                    setHeightMapTexture(heightmap_tex);\n                    \n                    // Mark terrain as dirty to regenerate\n                    setTerrainGeometryDirty(true);\n                    console.log('Height map loaded successfully');\n                };\n                img.src = event.target?.result as string;\n            };\n            reader.readAsDataURL(file);\n        };\n        input.click();\n    }\n\n    function clearHeightMap() {\n        const heightmap_tex = getHeightMapTexture();\n        if (heightmap_tex) {\n            gl_context.deleteTexture(heightmap_tex);\n            setHeightMapTexture(null);\n            setTerrainGeometryDirty(true);\n            console.log('Height map cleared, using procedural generation');\n        }\n    }\n\n    return {\n        loadHeightMap,\n        clearHeightMap\n    };\n}\n\n","import {gl} from '../globals';\n\n// Global cache for uniform locations per program\nconst uniformLocationCache = new Map<WebGLProgram, Map<string, WebGLUniformLocation | null>>();\n\n/**\n * Get a cached uniform location. This avoids expensive getUniformLocation calls.\n * @param prog The WebGL program\n * @param name The uniform name\n * @returns The uniform location, or null if not found\n */\nexport function getCachedUniformLocation(prog: WebGLProgram, name: string): WebGLUniformLocation | null {\n    let progCache = uniformLocationCache.get(prog);\n    if (!progCache) {\n        progCache = new Map();\n        uniformLocationCache.set(prog, progCache);\n    }\n    \n    if (!progCache.has(name)) {\n        const loc = gl.getUniformLocation(prog, name);\n        progCache.set(name, loc);\n        return loc;\n    }\n    \n    return progCache.get(name)!;\n}\n\n","import {vec3} from 'gl-matrix';\nimport Square from '../geometry/Square';\nimport OpenGLRenderer from './gl/OpenGLRenderer';\nimport Camera from '../Camera';\nimport ShaderProgram from './gl/ShaderProgram';\nimport { frame_buffer, render_buffer, getHeightMapTexture } from '../simulation/texture-management';\nimport { simres } from '../simulation/simulation-state';\n\nexport function Render2Texture(\n    renderer: OpenGLRenderer,\n    gl_context: WebGL2RenderingContext,\n    camera: Camera,\n    shader: ShaderProgram,\n    cur_texture: WebGLTexture,\n    square: Square,\n    noiseterrain: ShaderProgram | null\n): void {\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, render_buffer);\n    gl_context.renderbufferStorage(gl_context.RENDERBUFFER, gl_context.DEPTH_COMPONENT16,\n        simres, simres);\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT0, gl_context.TEXTURE_2D, cur_texture, 0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT1, gl_context.TEXTURE_2D, null, 0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT2, gl_context.TEXTURE_2D, null, 0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT3, gl_context.TEXTURE_2D, null, 0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER, gl_context.DEPTH_ATTACHMENT, gl_context.RENDERBUFFER, render_buffer);\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n    let status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n        console.log(\"frame buffer status:\" + status.toString());\n    }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, null);\n\n    gl_context.viewport(0, 0, simres, simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n    renderer.clear();\n    shader.use();\n\n    // Set height map texture if this is the initial terrain shader and height map exists\n    const heightmap_tex = getHeightMapTexture();\n    if (noiseterrain && shader === noiseterrain && heightmap_tex) {\n        const useHeightMap = 1;\n        gl_context.uniform1i(gl_context.getUniformLocation(shader.prog, \"u_UseHeightMap\"), useHeightMap);\n        gl_context.activeTexture(gl_context.TEXTURE0 + 10);\n        gl_context.bindTexture(gl_context.TEXTURE_2D, heightmap_tex);\n        gl_context.uniform1i(gl_context.getUniformLocation(shader.prog, \"u_HeightMap\"), 10);\n    } else if (noiseterrain && shader === noiseterrain) {\n        gl_context.uniform1i(gl_context.getUniformLocation(shader.prog, \"u_UseHeightMap\"), 0);\n    }\n\n    renderer.render(camera, shader, [square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n}\n\n","import {gl} from '../../../globals';\n\nexport function setTerrainType(prog: WebGLProgram, t: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_TerrainType\");\n    if (loc !== -1) {\n        gl.uniform1i(loc, t);\n    }\n}\n\nexport function setTerrainDebug(prog: WebGLProgram, t: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_TerrainDebug\");\n    if (loc !== -1) {\n        gl.uniform1i(loc, t);\n    }\n}\n\nexport function setTerrainScale(prog: WebGLProgram, t: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_TerrainScale\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, t);\n    }\n}\n\nexport function setTerrainHeight(prog: WebGLProgram, t: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_TerrainHeight\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, t);\n    }\n}\n\nexport function setRndTerrain(prog: WebGLProgram, r: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_RndTerrain\");\n    if (loc !== -1) {\n        gl.uniform1i(loc, r);\n    }\n}\n\n","import {vec2} from 'gl-matrix';\nimport {gl} from '../../../globals';\n\n// Cache for uniform locations per program\nconst uniformLocationCache = new Map<WebGLProgram, Map<string, WebGLUniformLocation>>();\n\nfunction getCachedUniformLocation(prog: WebGLProgram, name: string): WebGLUniformLocation | null {\n    let progCache = uniformLocationCache.get(prog);\n    if (!progCache) {\n        progCache = new Map();\n        uniformLocationCache.set(prog, progCache);\n    }\n    \n    if (!progCache.has(name)) {\n        const loc = gl.getUniformLocation(prog, name);\n        progCache.set(name, loc);\n        return loc;\n    }\n    \n    return progCache.get(name)!;\n}\n\nexport function setBrushType(prog: WebGLProgram, t: number): void {\n    const loc = getCachedUniformLocation(prog, \"u_BrushType\");\n    if (loc !== null && loc !== -1) {\n        gl.uniform1i(loc, t);\n    }\n}\n\nexport function setBrushSize(prog: WebGLProgram, t: number): void {\n    const loc = getCachedUniformLocation(prog, \"u_BrushSize\");\n    if (loc !== null && loc !== -1) {\n        gl.uniform1f(loc, t);\n    }\n}\n\nexport function setBrushStrength(prog: WebGLProgram, t: number): void {\n    const loc = getCachedUniformLocation(prog, \"u_BrushStrength\");\n    if (loc !== null && loc !== -1) {\n        gl.uniform1f(loc, t);\n    }\n}\n\nexport function setBrushOperation(prog: WebGLProgram, t: number): void {\n    const loc = getCachedUniformLocation(prog, \"u_BrushOperation\");\n    if (loc !== null && loc !== -1) {\n        gl.uniform1i(loc, t);\n    }\n}\n\nexport function setBrushPos(prog: WebGLProgram, t: vec2): void {\n    const loc = getCachedUniformLocation(prog, \"u_BrushPos\");\n    if (loc !== null && loc !== -1) {\n        gl.uniform2fv(loc, t);\n    }\n}\n\nexport function setBrushPressed(prog: WebGLProgram, t: number): void {\n    const loc = getCachedUniformLocation(prog, \"u_BrushPressed\");\n    if (loc !== null && loc !== -1) {\n        gl.uniform1i(loc, t);\n    }\n}\n\n","import {gl} from '../../../globals';\n\nexport function setSimres(prog: WebGLProgram, res: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_SimRes\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, res);\n    }\n}\n\nexport function setPipeLen(prog: WebGLProgram, len: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_PipeLen\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, len);\n    }\n}\n\nexport function setKs(prog: WebGLProgram, k: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_Ks\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, k);\n    }\n}\n\nexport function setKc(prog: WebGLProgram, k: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_Kc\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, k);\n    }\n}\n\nexport function setKd(prog: WebGLProgram, k: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_Kd\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, k);\n    }\n}\n\nexport function setRockErosionResistance(prog: WebGLProgram, resistance: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_RockErosionResistance\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, resistance);\n    }\n}\n\nexport function setTimestep(prog: WebGLProgram, t: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_timestep\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, t);\n    }\n}\n\nexport function setPipeArea(prog: WebGLProgram, a: number): void {\n    const loc = gl.getUniformLocation(prog, \"u_PipeArea\");\n    if (loc !== -1) {\n        gl.uniform1f(loc, a);\n    }\n}\n\n","import {vec2, vec4, mat4, vec3} from 'gl-matrix';\nimport Drawable from './Drawable';\nimport {gl} from '../../globals';\nimport * as TerrainUniforms from './uniforms/TerrainUniforms';\nimport * as BrushUniforms from './uniforms/BrushUniforms';\nimport * as SimulationUniforms from './uniforms/SimulationUniforms';\n\nvar activeProgram: WebGLProgram = null;\n\nexport class Shader {\n  shader: WebGLShader;\n\n  constructor(type: number, source: string) {\n    this.shader = gl.createShader(type);\n    gl.shaderSource(this.shader, source);\n    gl.compileShader(this.shader);\n\n    if (!gl.getShaderParameter(this.shader, gl.COMPILE_STATUS)) {\n      throw gl.getShaderInfoLog(this.shader);\n    }\n  }\n};\n\nclass ShaderProgram {\n  prog: WebGLProgram;\n\n  attrPos: number;\n  attrNor: number;\n  attrCol: number;\n  attrUv : number;\n\n  unifModel: WebGLUniformLocation;\n  unifModelInvTr: WebGLUniformLocation;\n  unifViewProj: WebGLUniformLocation;\n  unifColor: WebGLUniformLocation;\n  unifPlanePos: WebGLUniformLocation;\n  unifSpanwPos: WebGLUniformLocation;\n  unifMouseWorldPos : WebGLUniformLocation;\n  unifMouseWorldDir : WebGLUniformLocation;\n\n\n  unifSimRes : WebGLUniformLocation;\n  unifPipeLen : WebGLUniformLocation;\n  unifKs : WebGLUniformLocation;\n  unifKc : WebGLUniformLocation;\n  unifKd : WebGLUniformLocation;\n  unifRockErosionResistance : WebGLUniformLocation;\n  unifTimestep : WebGLUniformLocation;\n  unifPipeArea : WebGLUniformLocation;\n\n  unifRef: WebGLUniformLocation;\n  unifEye: WebGLUniformLocation;\n  unifUp: WebGLUniformLocation;\n  unifDimensions: WebGLUniformLocation;\n  unifTime : WebGLUniformLocation;\n  unifWaterTransparency : WebGLUniformLocation;\n\n  unifRndTerrain : WebGLUniformLocation;\n  unifTerrainType : WebGLUniformLocation;\n  unifTerrainDebug : WebGLUniformLocation;\n  unifTerrainScale : WebGLUniformLocation;\n  unifTerrainHeight : WebGLUniformLocation;\n\n  unifBrushType : WebGLUniformLocation;\n  unifBrushSize : WebGLUniformLocation;\n  unifBrushStrength : WebGLUniformLocation;\n  unifBrushOperation : WebGLUniformLocation;\n  unifBrushPressed : WebGLUniformLocation;\n  unifBrusPos : WebGLUniformLocation;\n\n  // Cache for uniform locations to avoid expensive getUniformLocation calls\n  private uniformLocationCache: Map<string, WebGLUniformLocation> = new Map();\n\n  constructor(shaders: Array<Shader>) {\n    this.prog = gl.createProgram();\n\n    for (let shader of shaders) {\n      gl.attachShader(this.prog, shader.shader);\n    }\n    gl.linkProgram(this.prog);\n    if (!gl.getProgramParameter(this.prog, gl.LINK_STATUS)) {\n      throw gl.getProgramInfoLog(this.prog);\n    }\n\n    this.attrPos = gl.getAttribLocation(this.prog, \"vs_Pos\");\n    this.attrNor = gl.getAttribLocation(this.prog, \"vs_Nor\");\n    this.attrCol = gl.getAttribLocation(this.prog, \"vs_Col\");\n    this.attrUv  = gl.getAttribLocation(this.prog,\"vs_Uv\");\n    this.unifModel      = gl.getUniformLocation(this.prog, \"u_Model\");\n    this.unifModelInvTr = gl.getUniformLocation(this.prog, \"u_ModelInvTr\");\n    this.unifViewProj   = gl.getUniformLocation(this.prog, \"u_ViewProj\");\n    this.unifPlanePos   = gl.getUniformLocation(this.prog, \"u_PlanePos\");\n    this.unifSpanwPos = gl.getUniformLocation(this.prog, \"u_SpawnPos\");\n    this.unifMouseWorldPos =  gl.getUniformLocation(this.prog, \"u_MouseWorldPos\");\n    this.unifMouseWorldDir = gl.getUniformLocation(this.prog, \"u_MouseWorldDir\");\n\n    this.unifSimRes = gl.getUniformLocation(this.prog, \"u_SimRes\");\n    this.unifPipeLen = gl.getUniformLocation(this.prog, \"u_PipeLen\");\n    this.unifKs = gl.getUniformLocation(this.prog, \"u_Ks\");\n    this.unifKc = gl.getUniformLocation(this.prog, \"u_Kc\");\n    this.unifKd = gl.getUniformLocation(this.prog, \"u_Kd\");\n    this.unifRockErosionResistance = gl.getUniformLocation(this.prog, \"u_RockErosionResistance\");\n    this.unifTimestep = gl.getUniformLocation(this.prog, \"u_timestep\");\n    this.unifPipeArea = gl.getUniformLocation(this.prog,\"u_PipeArea\");\n\n    this.unifEye   = gl.getUniformLocation(this.prog, \"u_Eye\");\n    this.unifRef   = gl.getUniformLocation(this.prog, \"u_Ref\");\n    this.unifUp   = gl.getUniformLocation(this.prog, \"u_Up\");\n    this.unifDimensions = gl.getUniformLocation(this.prog,\"u_Dimensions\");\n    this.unifTime = gl.getUniformLocation(this.prog,\"u_Time\");\n    this.unifWaterTransparency = gl.getUniformLocation(this.prog,\"u_WaterTransparency\");\n\n\n    this.unifRndTerrain = gl.getUniformLocation(this.prog,\"u_RndTerrain\");\n    this.unifTerrainType = gl.getUniformLocation(this.prog,\"u_TerrainType\");\n    this.unifTerrainDebug = gl.getUniformLocation(this.prog,\"u_TerrainDebug\");\n    this.unifTerrainScale = gl.getUniformLocation(this.prog,\"u_TerrainScale\");\n    this.unifTerrainHeight = gl.getUniformLocation(this.prog,\"u_TerrainHeight\");\n\n    this.unifBrushSize = gl.getUniformLocation(this.prog,\"u_BrushSize\");\n    this.unifBrushType = gl.getUniformLocation(this.prog,\"u_BrushType\");\n    this.unifBrushStrength = gl.getUniformLocation(this.prog,\"u_BrushStrength\");\n    this.unifBrushOperation = gl.getUniformLocation(this.prog,\"u_BrushOperation\");\n    this.unifBrushPressed = gl.getUniformLocation(this.prog,\"u_BrushPressed\");\n    this.unifBrusPos = gl.getUniformLocation(this.prog,\"u_BrushPos\");\n  }\n\n  use() {\n    if (activeProgram !== this.prog) {\n      gl.useProgram(this.prog);\n      activeProgram = this.prog;\n    }\n  }\n\n  setModelMatrix(model: mat4) {\n    this.use();\n    if (this.unifModel !== -1) {\n      gl.uniformMatrix4fv(this.unifModel, false, model);\n    }\n\n    if (this.unifModelInvTr !== -1) {\n      let modelinvtr: mat4 = mat4.create();\n      mat4.transpose(modelinvtr, model);\n      mat4.invert(modelinvtr, modelinvtr);\n      gl.uniformMatrix4fv(this.unifModelInvTr, false, modelinvtr);\n    }\n  }\n\n  setViewProjMatrix(vp: mat4) {\n    this.use();\n    if (this.unifViewProj !== -1) {\n      gl.uniformMatrix4fv(this.unifViewProj, false, vp);\n    }\n  }\n  // Get uniform location with caching\n  private getUniformLocation(name: string): WebGLUniformLocation | null {\n    if (!this.uniformLocationCache.has(name)) {\n      const loc = gl.getUniformLocation(this.prog, name);\n      this.uniformLocationCache.set(name, loc);\n      return loc;\n    }\n    return this.uniformLocationCache.get(name)!;\n  }\n\n  setInt(f : number, name : string){\n    this.use();\n    const loc = this.getUniformLocation(name);\n    if (loc !== null && loc !== -1) {\n      gl.uniform1i(loc, f);\n    }\n  }\n\n  setFloat(f : number, name : string){\n    this.use();\n    const loc = this.getUniformLocation(name);\n    if (loc !== null && loc !== -1) {\n      gl.uniform1f(loc, f);\n    }\n  }\n  setVec2(v : vec2, name : string){\n    this.use();\n    const loc = this.getUniformLocation(name);\n    if (loc !== null && loc !== -1) {\n      gl.uniform2fv(loc, v);\n    }\n  }\n  setTime(t:number){\n    this.use();\n    if(this.unifTime!==-1){\n      gl.uniform1f(this.unifTime,t);\n    }\n  }\n\n  setWaterTransparency(t:number){\n    this.use();\n    if(this.unifWaterTransparency!==-1){\n      gl.uniform1f(this.unifWaterTransparency,t);\n    }\n  }\n\n    setDimensions(width: number, height: number) {\n        this.use();\n        if(this.unifDimensions !== -1) {\n            gl.uniform2f(this.unifDimensions, width, height);\n        }\n    }\n\n    setTerrainType(t:number){\n    this.use();\n    TerrainUniforms.setTerrainType(this.prog, t);\n    }\n\n    setBrushType(t :number){\n    this.use();\n    BrushUniforms.setBrushType(this.prog, t);\n    }\n\n    setBrushSize(t:number){\n    this.use();\n    BrushUniforms.setBrushSize(this.prog, t);\n    }\n\n  setBrushStrength(t:number){\n    this.use();\n    BrushUniforms.setBrushStrength(this.prog, t);\n  }\n\n    setBrushOperation(t :number){\n      this.use();\n      BrushUniforms.setBrushOperation(this.prog, t);\n    }\n\n    setBrushPos(t:vec2){\n    this.use();\n    BrushUniforms.setBrushPos(this.prog, t);\n    }\n\n  setBrushPressed(t :number){\n    this.use();\n    BrushUniforms.setBrushPressed(this.prog, t);\n  }\n\n  setSourceCount(count: number) {\n    this.use();\n    const loc = this.getUniformLocation(\"u_SourceCount\");\n    if (loc !== null && loc !== -1) {\n      gl.uniform1i(loc, count);\n    }\n  }\n\n  setSourcePositions(positions: Float32Array) {\n    this.use();\n    const loc = this.getUniformLocation(\"u_SourcePositions\");\n    if (loc !== null && loc !== -1) {\n      gl.uniform2fv(loc, positions);\n    }\n  }\n\n  setSourceSizes(sizes: Float32Array) {\n    this.use();\n    const loc = this.getUniformLocation(\"u_SourceSizes\");\n    if (loc !== null && loc !== -1) {\n      gl.uniform1fv(loc, sizes);\n    }\n  }\n\n  setSourceStrengths(strengths: Float32Array) {\n    this.use();\n    const loc = this.getUniformLocation(\"u_SourceStrengths\");\n    if (loc !== -1) {\n      gl.uniform1fv(loc, strengths);\n    }\n  }\n\n  setTerrainDebug(t:number){\n    this.use();\n    TerrainUniforms.setTerrainDebug(this.prog, t);\n  }\n\n  setTerrainScale(t : number){\n    this.use();\n    TerrainUniforms.setTerrainScale(this.prog, t);\n  }\n\n  setTerrainHeight(t : number){\n    this.use();\n    TerrainUniforms.setTerrainHeight(this.prog, t);\n  }\n\n\n  setSpawnPos(pos: vec2) {\n    this.use();\n    if (this.unifSpanwPos !== -1) {\n      gl.uniform2fv(this.unifSpanwPos, pos);\n    }\n  }\n\n\n\n  setMouseWorldPos(pos : vec4){\n    this.use();\n    if(this.unifMouseWorldPos !== -1){\n      gl.uniform4fv(this.unifMouseWorldPos, pos);\n    }\n  }\n\n  setMouseWorldDir(dir : vec3){\n    this.use();\n    if(this.unifMouseWorldDir !== -1){\n      gl.uniform3fv(this.unifMouseWorldDir, dir);\n    }\n  }\n\n    setRndTerrain(r:number){\n    this.use();\n    TerrainUniforms.setRndTerrain(this.prog, r);\n    }\n  setPlanePos(pos: vec2) {\n    this.use();\n    if (this.unifPlanePos !== -1) {\n      gl.uniform2fv(this.unifPlanePos, pos);\n    }\n  }\n    setEyeRefUp(eye: vec3, ref: vec3, up: vec3) {\n        this.use();\n        if(this.unifEye !== -1) {\n            gl.uniform3f(this.unifEye, eye[0], eye[1], eye[2]);\n        }\n        if(this.unifRef !== -1) {\n            gl.uniform3f(this.unifRef, ref[0], ref[1], ref[2]);\n        }\n        if(this.unifUp !== -1) {\n            gl.uniform3f(this.unifUp, up[0], up[1], up[2]);\n        }\n    }\n  setPipeLen(len : number){\n    this.use();\n    SimulationUniforms.setPipeLen(this.prog, len);\n  }\n\n  setKs(k :number){\n    this.use();\n    SimulationUniforms.setKs(this.prog, k);\n  }\n\n  setKc(k :number){\n      this.use();\n      SimulationUniforms.setKc(this.prog, k);\n  }\n\n  setTimestep(t:number){\n    this.use();\n    SimulationUniforms.setTimestep(this.prog, t);\n  }\n\n  setPipeArea(a:number){\n    this.use();\n    SimulationUniforms.setPipeArea(this.prog, a);\n  }\n\n  setKd(k :number){\n      this.use();\n      SimulationUniforms.setKd(this.prog, k);\n  }\n\n  setRockErosionResistance(resistance: number) {\n    this.use();\n    SimulationUniforms.setRockErosionResistance(this.prog, resistance);\n  }\n\n  setSimres(res:number){\n    this.use();\n    SimulationUniforms.setSimres(this.prog, res);\n  }\n\n\n\n  draw(d: Drawable) {\n    this.use();\n\n    if (this.attrPos != -1 && d.bindPos()) {\n      gl.enableVertexAttribArray(this.attrPos);\n      gl.vertexAttribPointer(this.attrPos, 4, gl.FLOAT, false, 0, 0);\n    }\n\n    if (this.attrNor != -1 && d.bindNor()) {\n      gl.enableVertexAttribArray(this.attrNor);\n      gl.vertexAttribPointer(this.attrNor, 4, gl.FLOAT, false, 0, 0);\n    }\n\n    if(this.attrUv != -1 && d.bindUv()){\n      gl.enableVertexAttribArray(this.attrUv);\n      gl.vertexAttribPointer(this.attrUv,2, gl.FLOAT,false,0,0);\n    }\n\n    d.bindIdx();\n    gl.drawElements(d.drawMode(), d.elemCount(), gl.UNSIGNED_INT, 0);\n\n    if (this.attrPos != -1) gl.disableVertexAttribArray(this.attrPos);\n    if (this.attrNor != -1) gl.disableVertexAttribArray(this.attrNor);\n    if (this.attrUv != -1) gl.disableVertexAttribArray(this.attrUv);\n  }\n};\n\nexport default ShaderProgram;\n","export default \"#version 300 es\\n\\n\\nuniform mat4 u_Model;\\nuniform mat4 u_ModelInvTr;\\nuniform mat4 u_ViewProj;\\nuniform vec2 u_PlanePos; // Our location in the virtual world displayed by the plane\\n\\nuniform mat4 u_sproj;\\nuniform mat4 u_sview;\\n\\nuniform sampler2D hightmap;\\nuniform sampler2D sedimap;\\nuniform float u_SimRes;\\n\\nin vec4 vs_Pos;\\nin vec4 vs_Nor;\\nin vec4 vs_Col;\\nin vec2 vs_Uv;\\n\\nout vec3 fs_Pos;\\nout vec4 fs_Nor;\\nout vec4 fs_Col;\\nout vec2 fs_Uv;\\nout vec4 fs_shadowPos;\\n\\n\\n\\nvoid main()\\n{\\n\\n  fs_Uv = vs_Uv;\\n  float sval = 1.f*texture(sedimap,vs_Uv).x;\\n  float yval = 1.f*texture(hightmap,vs_Uv).x;\\n  float wval = 1.f*texture(hightmap,vs_Uv).y;\\n  vec4 modelposition = vec4(vs_Pos.x, (yval )/u_SimRes , vs_Pos.z, 1.0);\\n  fs_Pos = modelposition.xyz;\\n\\n\\n  modelposition = u_Model * modelposition;\\n\\n  fs_shadowPos = u_sproj * u_sview * modelposition;\\n\\n  gl_Position = u_ViewProj * modelposition;\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform vec2 u_PlanePos; // Our location in the virtual world displayed by the plane\\n\\n\\nin vec3 fs_Pos;\\nin vec4 fs_Nor;\\nin vec4 fs_Col;\\nin float fs_Sine;\\nin vec2 fs_Uv;\\nin vec4 fs_shadowPos;\\n\\nuniform sampler2D hightmap;\\nuniform sampler2D normap;\\nuniform sampler2D sedimap;\\nuniform sampler2D velmap;\\nuniform sampler2D fluxmap;\\nuniform sampler2D terrainfluxmap;\\nuniform sampler2D maxslippagemap;\\nuniform sampler2D sediBlend;\\nuniform sampler2D shadowMap;\\nuniform sampler2D sceneDepth;\\n\\n#define PI 3.1415926\\n\\n\\nlayout (location = 0) out vec4 out_Col; // This is the final output color that you will see on your\\nlayout (location = 1) out vec4 col_reflect;\\n                  // screen for the pixel that is currently being processed.\\nuniform vec3 u_Eye, u_Ref, u_Up;\\nuniform vec2 u_Dimensions;\\nuniform int u_TerrainDebug;\\nuniform int u_SedimentTrace;\\n\\nuniform vec4 u_MouseWorldPos;\\nuniform vec3 u_MouseWorldDir;\\nuniform float u_BrushSize;\\nuniform int u_BrushType;\\nuniform vec2 u_BrushPos;\\nuniform float u_SimRes;\\nuniform float u_SnowRange;\\nuniform float u_ForestRange;\\nuniform int u_TerrainPlatte;\\nuniform vec3 unif_LightPos;\\nuniform int u_SourceCount;\\nuniform vec2 u_SourcePositions[16];  // Max 16 sources\\nuniform float u_SourceSizes[16];\\nuniform int u_FlowTrace;\\n\\n\\nuniform mat4 u_sproj;\\nuniform mat4 u_sview;\\n\\nvec3 calnor(vec2 uv){\\n    float eps = 1.f/u_SimRes;\\n    vec4 cur = texture(hightmap,uv);\\n    vec4 r = texture(hightmap,uv+vec2(eps,0.f));\\n    vec4 t = texture(hightmap,uv+vec2(0.f,eps));\\n    vec4 b = texture(hightmap,uv+vec2(0.f,-eps));\\n    vec4 l = texture(hightmap,uv+vec2(-eps,0.f));\\n\\n    vec3 nor = vec3(l.x - r.x, 2.0, t.x - b.x);\\n    nor = -normalize(nor);\\n    return nor;\\n}\\n\\n    #define OCTAVES 12\\n\\nfloat random (in vec2 st) {\\n    return fract(sin(dot(st.xy,\\n    vec2(12.9898,78.233)))*\\n    43758.5453123);\\n}\\n\\n\\nfloat noise (in vec2 st) {\\n    vec2 i = floor(st);\\n    vec2 f = fract(st);\\n\\n    // Four corners in 2D of a tile\\n    float a = random(i);\\n    float b = random(i + vec2(1.0, 0.0));\\n    float c = random(i + vec2(0.0, 1.0));\\n    float d = random(i + vec2(1.0, 1.0));\\n\\n    vec2 u = f * f * (3.0 - 2.0 * f);\\n\\n    return mix(a, b, u.x) +\\n    (c - a)* u.y * (1.0 - u.x) +\\n    (d - b) * u.x * u.y;\\n}\\n\\n\\nfloat fbm (in vec2 st) {\\n    // Initial values\\n    float value = 0.0;\\n    float amplitude = .5;\\n    float frequency = 0.;\\n    //\\n    // Loop of octaves\\n    for (int i = 0; i < OCTAVES; i++) {\\n        value += amplitude * noise(st);//iqnoise(st,1.f,1.f);\\n        st *= 2.0;\\n        amplitude *= .33;\\n    }\\n    return value;\\n}\\n\\n\\nfloat computeTerrainAO(){\\n    vec4 HC = texture(hightmap,fs_Uv);\\n    return 1.0;\\n}\\n\\nvoid main()\\n{\\n\\n    vec3 sundir = unif_LightPos;\\n    sundir = normalize(sundir);\\n    float angle = dot(sundir,vec3(0.0,1.0,0.0));\\n    vec3 hue = mix(vec3(255.0,255.0,255.0)/256.0, vec3(255.0,120.0,20.0)/256.0, 1.0 - angle);\\n\\n    float shadowVal = 1.0f;\\n    vec3 shadowCol = vec3(1.0);\\n    vec3 ambientCol = vec3(0.01);\\n    vec3 shadowMapLoc = fs_shadowPos.xyz / fs_shadowPos.w;\\n    shadowMapLoc = shadowMapLoc*0.5+0.5;\\n    float texsize = 1.0/4096.0f;\\n    for(int x = -1; x <= 1; ++x)\\n    {\\n        for(int y = -1; y <= 1; ++y)\\n        {\\n            float pcfDepth = texture(shadowMap, shadowMapLoc.xy + vec2(x, y) * texsize).r;\\n            shadowVal += shadowMapLoc.z - 0.0001 > pcfDepth ? .1 : 1.;\\n            shadowCol += shadowMapLoc.z - 0.0001 > pcfDepth ? vec3(0.02,0.01,0.09) : vec3(1.0);\\n        }\\n    }\\n    shadowVal/=9.0;\\n    shadowCol/=9.0;\\n    float shadowColorVal = texture(shadowMap, fs_Uv.xy).x;\\n\\n    vec3 forestcol = vec3(63.0/255.0,155.0/255.0,7.0/255.0)*0.6;\\n    vec3 mtncolor = vec3(0.99,0.99,0.99);\\n    vec3 dirtcol = vec3(0.45,0.45,0.45);\\n    vec3 grass = vec3(193.0/255.0,235.0/255.0,27.0/255.0);\\n    vec3 sand = vec3(214.f/255.f,184.f/255.f,96.f/255.f);\\n    vec3 watercol = vec3(0.1,0.3,0.8);\\n    vec3 permanentCol = vec3(0.8,0.1,0.2);\\n    vec3 obsidian = vec3(0.2);\\n\\n    // Rock colors - distinct bluish-gray to clearly differentiate from soil\\n    vec3 rock1 = vec3(0.35, 0.38, 0.45);  // Light bluish-gray\\n    vec3 rock2 = vec3(0.25, 0.28, 0.35);  // Medium bluish-gray\\n    vec3 rock3 = vec3(0.15, 0.18, 0.25);   // Dark bluish-gray\\n\\n\\n\\n\\n    vec3 addcol = vec3(0.0);\\n    // Only calculate brush visualization if brush is active (brushType != 0)\\n    // Note: We don't check u_BrushPressed here because we want to show the brush preview\\n    // even when not actively painting, but we can optimize by checking brushType first\\n    if(u_BrushType != 0){\\n        vec2 pointOnPlane = u_BrushPos;\\n        float pdis2fragment = distance(pointOnPlane, fs_Uv);\\n        // Early exit: only do expensive calculations if fragment is within brush radius\\n        if (pdis2fragment < 0.01 * u_BrushSize){\\n            float dens = (0.01 * u_BrushSize - pdis2fragment) / (0.01 * u_BrushSize);\\n\\n            if(u_BrushType == 1){\\n                addcol = sand * 0.8;\\n            }else if(u_BrushType == 2){\\n                addcol = watercol * 0.8;\\n            }else if(u_BrushType == 3){\\n                // Rock brush preview - use the new bluish-gray rock color\\n                addcol = vec3(0.35, 0.38, 0.45) * 0.8;\\n            }else if(u_BrushType == 4){\\n                // Smooth brush - light blue\\n                addcol = vec3(0.5, 0.8, 1.0) * 0.8;\\n            }else if(u_BrushType == 5){\\n                // Flatten brush - yellow\\n                addcol = vec3(1.0, 1.0, 0.3) * 0.8;\\n            }else if(u_BrushType == 6){\\n                // Slope brush - green\\n                addcol = vec3(0.3, 1.0, 0.3) * 0.8;\\n            }\\n            addcol *= 1.0;\\n        }\\n\\n    }\\n\\n    // Visualize all water sources\\n    for(int i = 0; i < u_SourceCount; i++){\\n        vec2 pointOnPlane = u_SourcePositions[i];\\n        float pdis2fragment = distance(pointOnPlane, fs_Uv);\\n        float sourceSize = u_SourceSizes[i];\\n        \\n        if (pdis2fragment < 0.01 * sourceSize){\\n            float dens = (0.01 * sourceSize - pdis2fragment) / (0.01 * sourceSize);\\n            vec3 sourceCol = permanentCol * 0.8;\\n            addcol += sourceCol * dens * 5.0;\\n        }\\n    }\\n\\n\\n\\n\\n\\n    vec3 slopesin = texture(normap,fs_Uv).xyz;\\n    vec3 nor = -calnor(fs_Uv);\\n\\n\\n\\n    float lamb = dot(nor,vec3(sundir.x,sundir.y,-sundir.z));\\n\\n\\n    //lamb =1.f;\\n    vec4 fH = texture(hightmap,fs_Uv);\\n    float yval = fH.x * 4.0;\\n    float wval = fH.y;\\n    float rockVal = fH.z; // Rock material value (1.0 = rock, 0.0 = normal)\\n    float sval = texture(sediBlend, fs_Uv).x;\\n\\n    vec3 finalcol = vec3(0);\\n\\n    float lowH = 0.0;\\n    float midH = 300.0;\\n    float highH = 600.0;\\n\\n    if(u_TerrainPlatte == 1){\\n        forestcol = mtncolor;\\n    }else if(u_TerrainPlatte == 2){\\n        highH = 2000.0;\\n    }\\n\\n    if(yval<=midH){\\n        finalcol = forestcol;\\n    }else if(yval>midH&&yval<=highH){\\n        finalcol = mix(forestcol,mtncolor,(yval-midH)/(highH-midH));\\n    }else if(yval>highH){\\n\\n            finalcol = mtncolor;\\n\\n\\n    }\\n\\n    finalcol =  mix(mtncolor, finalcol, clamp( pow(abs(nor.y), u_ForestRange), 0.0, 1.0));\\n\\n    if(abs(nor.y)<0.75){\\n        finalcol = mix(dirtcol,finalcol,pow(abs(nor.y)/0.75,u_SnowRange));\\n    }\\n\\n    // Apply rock material color - make rock clearly distinct from soil\\n    if(rockVal > 0.1){\\n        // Use distinct bluish-gray rock colors - mix between rock3 (darkest) and rock1 (lightest) based on rock value\\n        vec3 rockCol = mix(rock3, rock1, clamp((rockVal - 0.1) / 0.9, 0.0, 1.0));\\n        \\n        // Check if there's sediment on top of rock\\n        float baseRockHeight = fH.w;\\n        float sedimentLayerThickness = 0.0;\\n        float sedimentBlendFactor = 0.0;\\n        \\n        // Check if base rock height is valid and current height is significantly above it\\n        // If base height is very close to current height (within 0.01), it means new rock was placed (no sediment)\\n        float heightDiff = fH.x - baseRockHeight;\\n        if(baseRockHeight > 0.001 && abs(heightDiff) > 0.01){\\n            // There's sediment on top of rock (height is significantly above base)\\n            // Only apply blending if height is above base (positive difference)\\n            if(heightDiff > 0.0){\\n                sedimentLayerThickness = heightDiff;\\n                // Blend factor: 0.0 = pure rock, 1.0 = pure dirt\\n                // Use a smooth curve - more sediment = more dirt color\\n                // At 0.1 units of sediment, it should be mostly dirt\\n                sedimentBlendFactor = smoothstep(0.0, 0.1, sedimentLayerThickness);\\n            }\\n        }\\n        // If abs(heightDiff) <= 0.01, treat as no sediment (new rock was placed, base was reset to current height)\\n        \\n        // Blend between rock color and dirt color based on sediment coverage\\n        vec3 surfaceCol = mix(rockCol, dirtcol, sedimentBlendFactor);\\n        \\n        // Apply the blended color - make rock much more visible and distinct\\n        // When sedimentBlendFactor is high, apply dirt color directly to look like normal dirt\\n        if(sedimentBlendFactor > 0.8){\\n            // Mostly covered with sediment - apply dirt color directly, no rock color\\n            finalcol = mix(finalcol, dirtcol, 0.9);\\n        } else {\\n            // Partially covered or no sediment - apply rock color strongly to make it clearly visible\\n            // Increase rock color strength significantly - rock should override base terrain color\\n            float rockColorStrength = clamp(rockVal * 2.0, 0.7, 1.0) * (1.0 - sedimentBlendFactor * 0.5);\\n            // Use a stronger mix - rock color should dominate when there's no sediment\\n            finalcol = mix(finalcol, surfaceCol, rockColorStrength);\\n        }\\n    }\\n\\n    vec3 normal = lamb*(finalcol) + ambientCol;\\n    vec3 fcol = normal;\\n    bool debug = true;\\n    //normal : 0, sediment : 1, velocity : 2, terrain : 3, flux : 4\\n    if(u_TerrainDebug == 0){\\n        fcol = normal;\\n        debug = false;\\n    }else if(u_TerrainDebug == 1){\\n        fcol = texture(sedimap,fs_Uv).xyz * 2.0;\\n    }else if(u_TerrainDebug == 2){\\n        fcol = abs(texture(velmap,fs_Uv).xyz/20.0);\\n    }else if(u_TerrainDebug == 9){\\n\\n        //fcol = vec3(length(texture(velmap,fs_Uv).xyz)/5.0);\\n\\n        float velSize = length(texture(velmap,fs_Uv).xyz) / 5.0;\\n        velSize = 1.0 - exp(-velSize); // 1 - pow(e, -x)\\n        float midVelBlend = 0.5;\\n        float highVelBlend = 1.0;\\n        float maxVelBlend = 1.0;\\n        if(velSize <= midVelBlend && velSize >= 0.0){\\n            fcol = mix(vec3(0.0,0.0,1.0), vec3(0.0,1.0,0.0), (velSize - 0.0) / (midVelBlend - 0.0));\\n        }else  if( velSize >=midVelBlend){\\n            fcol = mix(vec3(0.0,1.0,0.0), vec3(1.0,0.0,0.0), (velSize - midVelBlend) / (highVelBlend - midVelBlend));\\n        }\\n        if(wval < 0.0001){\\n            fcol = vec3(0.0);\\n        }\\n\\n        //fcol = nor1;\\n        //fcol.xy = fcol.xy / 2.0 + vec2(0.5);\\n    }else if(u_TerrainDebug == 3){\\n        fcol = texture(hightmap,fs_Uv).xyz;\\n        fcol.xy /= 200.0;\\n        fcol.y *= 80.0;\\n        //fcol = vec3(fcol.z);\\n    }else if(u_TerrainDebug == 4){\\n        fcol = texture(fluxmap,fs_Uv).xyz / 3.0;\\n        if(fcol == vec3(0.0)){\\n            fcol = vec3(texture(fluxmap,fs_Uv).w)/3.0;\\n        }\\n    }else if(u_TerrainDebug == 5){\\n        fcol = texture(terrainfluxmap, fs_Uv).xyz * 100000.0;\\n    }else if(u_TerrainDebug == 6){\\n        fcol = texture(maxslippagemap, fs_Uv).xyz / 13.0;\\n    }else if(u_TerrainDebug == 7){\\n        fcol = vec3(sval * 300.0);\\n    }else if(u_TerrainDebug == 8){\\n        fcol = slopesin;\\n    }else if(u_TerrainDebug == 10){\\n        // Rock/Soil material debug view\\n        // Rock (rockVal > 0.5): dark gray/black\\n        // Soil (rockVal <= 0.5): brown/tan\\n        // Sediment on rock: bright yellow/orange (clearly distinct)\\n        \\n        float baseRockHeight = fH.w;\\n        // Only show as sediment on rock if height is significantly above base (at least 0.05 units)\\n        // This prevents false positives from floating point errors\\n        bool hasSedimentOnRock = baseRockHeight > 0.001 && rockVal > 0.1 && (fH.x - baseRockHeight) > 0.05;\\n        \\n        if(hasSedimentOnRock){\\n            // Sediment on rock - bright yellow/orange to clearly distinguish from both rock and soil\\n            fcol = vec3(1.0, 0.8, 0.2); // Bright yellow-orange\\n        } else if(rockVal > 0.5){\\n            // Rock - dark gray, intensity based on rock value\\n            fcol = vec3(0.2, 0.2, 0.2) * (0.5 + rockVal * 0.5);\\n        } else {\\n            // Soil - brown/tan\\n            fcol = vec3(0.6, 0.5, 0.4);\\n        }\\n    }\\n\\n\\n    fcol = clamp(fcol, vec3(0.0), vec3(1.0));\\n\\n\\n\\n\\n    // realistic color\\n//    vec3 lightSedimentCol = vec3(0.9,0.9,0.6);\\n//    vec3 mediumSedimentCol = vec3(0.6, 0.6, 0.5);\\n//    vec3 deepSedimentCol = vec3(0.4, 0.2, 0.0);\\n    // vibrant color\\n    vec3 lightSedimentCol = vec3(0.0,0.5,0.3);\\n    vec3 mediumSedimentCol = vec3(0.0, 0.5, 0.5);\\n    vec3 deepSedimentCol = vec3(0.0, 0.0, 0.99);\\n    if(!debug){\\n\\n        // flow traces : showing flow map in the final render\\n        if(u_FlowTrace == 0){\\n            float sedimentTrace = 0.0;\\n            sedimentTrace = 1.0 - exp( -sval*300.0);\\n            fcol = mix(fcol, vec3(240.f/255.f,230.f/255.f,140.f/255.f) * lamb + ambientCol,sedimentTrace * 1.50);\\n            //sedimentTrace *= pow(abs(nor.y), 1.0);\\n        }\\n        //fcol += lamb * clamp(sval * vec3(0.5,0.2,0.0) * 550.0, vec3(0.0), vec3(1.0));\\n\\n        // sediment traces : showing movement of sediments on the terrain\\n        if(u_SedimentTrace == 0){\\n            float ssval = texture(sedimap, fs_Uv).x;\\n            //ssval = max(min(pow(3.0 * ssval, 0.6), 1.0), 0.0);\\n            ssval = 1.0 - exp(-ssval * 7.0);\\n            vec3 ss = vec3(0.8, 0.8, 0.8);\\n            ss = fcol;\\n            float small = 0.4, large = 0.7;\\n            if (ssval <=small){\\n                ss = mix(ss, lightSedimentCol, ssval/small);\\n\\n            } else if (ssval > small && ssval <= large){\\n                ss = mix(lightSedimentCol, mediumSedimentCol, (ssval - small)/(large - small));\\n            }\\n            else if (ssval > large){\\n                ss = mix(mediumSedimentCol, deepSedimentCol, (ssval - large)/(1.0 - large));\\n            }\\n            fcol = mix(fcol, max(ss * lamb, vec3(0.0)), ssval);\\n        }\\n\\n\\n\\n\\n\\n        fcol *= shadowCol * hue;\\n\\n    }\\n\\n\\n\\n\\n    vec3 tmpCol = fcol;\\n    fcol += addcol;\\n\\n//    float groundfog = 1.0 - min(yval / 200.0,1.0);\\n//    groundfog = (1.0 - exp(-groundfog * 0.4));\\n//    fcol = mix(fcol, vec3(0.8,0.8,0.8), groundfog);\\n\\n\\n\\n\\n    out_Col = vec4(vec3(fcol)*1.0 ,1.f);\\n    col_reflect = vec4(tmpCol,1.0);\\n    //out_Col = vec4(vec3(shadowColorVal),1.0);\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\n\\nin vec4 vs_Pos;\\nout vec2 fs_Pos;\\n\\nvoid main() {\\n  fs_Pos = vs_Pos.xy;\\n  vec4 pos = vs_Pos;\\n\\n  gl_Position = pos;\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D hightmap;\\nuniform sampler2D sceneDepth;\\nuniform sampler2D shadowMap;\\n\\n\\nuniform vec3 u_Eye, u_Ref, u_Up;\\nuniform vec2 u_Dimensions;\\nuniform float u_Time;\\nuniform vec3  unif_LightPos;\\nuniform int u_showScattering;\\n\\nuniform mat4 u_Model;\\nuniform mat4 u_ModelInvTr;\\nuniform mat4 u_ViewProj;\\nuniform mat4 u_sproj;\\nuniform mat4 u_sview;\\nuniform float u_far;\\nuniform float u_near;\\n\\n\\nin vec2 fs_Pos;\\nout vec4 out_Col;\\n\\n\\n#define FOV 45.f\\nvec3 sky(in vec3 rd){\\n    return 1.0 * mix(vec3(0.6,0.6,0.6),vec3(0.3,0.5,0.9),clamp(rd.y,0.f,1.f));\\n}\\n\\nfloat getSun(in vec3 rd){\\n    vec3 lightpos = normalize(unif_LightPos);\\n    float cosine = normalize(dot(lightpos, rd));\\n    float sine = sqrt(1.0 - cosine * cosine);\\n    return max(0.0, sine - 0.7);\\n}\\n\\nfloat linearDepth(float depthSample)\\n{\\n    depthSample = 2.0 * depthSample - 1.0;\\n    float zLinear = 2.0 * u_near * u_far / (u_far + u_near - depthSample * (u_far - u_near));\\n    return zLinear;\\n}\\n\\n//bayer matrix for dithering\\n\\n    //maxiterations for bayer matrix, maximum value is number of bits of your data type?\\n    //for crepuscular ray dithering [1..3] iterations are enough\\n    //because it is basically \\\"noisy scattering\\\" so  any patterns in it are \\\"just fine\\\"\\n#define iterBayerMat 1\\n#define bayer2x2(a) (4-(a).x-((a).y<<1))%4\\n//return bayer matris (bitwise operands for speed over compatibility)\\nfloat GetBayerFromCoordLevel(vec2 pixelpos)\\n{   ivec2 p=ivec2(pixelpos);\\n    int a=0;\\n    for(int i=0; i<iterBayerMat; i++)\\n    {\\n        a+=bayer2x2(p>>(iterBayerMat-1-i)&1)<<(2*i);\\n\\n    }\\n    return float(a)/float(2<<(iterBayerMat*2-1));\\n}\\n//https://www.shadertoy.com/view/XtV3RG\\n\\n//analytic bayer over 2 domains, is unrolled loop of GetBayerFromCoordLevel().\\n//but in terms of reusing subroutines, which is faster,while it does not extend as nicely.\\nfloat bayer2  (vec2 a){a=floor(a);return fract(dot(a,vec2(.5, a.y*.75)));}\\nfloat bayer4  (vec2 a){return bayer2 (  .5*a)*.25    +bayer2(a);}\\nfloat bayer8  (vec2 a){return bayer4 (  .5*a)*.25    +bayer2(a);}\\nfloat bayer16 (vec2 a){return bayer4 ( .25*a)*.0625  +bayer4(a);}\\nfloat bayer32 (vec2 a){return bayer8 ( .25*a)*.0625  +bayer4(a);}\\nfloat bayer64 (vec2 a){return bayer8 (.125*a)*.015625+bayer8(a);}\\nfloat bayer128(vec2 a){return bayer16(.125*a)*.015625+bayer8(a);}\\n#define dither2(p)   (bayer2(  p)-.375      )\\n#define dither4(p)   (bayer4(  p)-.46875    )\\n#define dither8(p)   (bayer8(  p)-.4921875  )\\n#define dither16(p)  (bayer16( p)-.498046875)\\n#define dither32(p)  (bayer32( p)-.499511719)\\n#define dither64(p)  (bayer64( p)-.49987793 )\\n#define dither128(p) (bayer128(p)-.499969482)\\n//https://www.shadertoy.com/view/4ssfWM\\n\\n//3 ways to approach a bayer matrix for dithering (or for loops within permutations)\\nfloat iib(vec2 u){\\n    return dither16(u);//analytic bayer, base2\\n    //return GetBayerFromCoordLevel(u*999.);//iterative bayer\\n    //optionally: instad just use bitmap of a bayer matrix: (LUT approach)\\n    //return texture(iChannel1,u/iChannelResolution[1].xy).x;\\n}\\n\\n// ====================== Raleigh scattering ========================\\n// reference https://github.com/wwwtyro/glsl-atmosphere\\n\\n#define PI 3.141592\\n#define iSteps 8\\n#define jSteps 1\\n\\nvec2 rsi(vec3 r0, vec3 rd, float sr) {\\n    // ray-sphere intersection that assumes\\n    // the sphere is centered at the origin.\\n    // No intersection when result.x > result.y\\n    float a = dot(rd, rd);\\n    float b = 2.0 * dot(rd, r0);\\n    float c = dot(r0, r0) - (sr * sr);\\n    float d = (b*b) - 4.0*a*c;\\n    if (d < 0.0) return vec2(1e5,-1e5);\\n    return vec2(\\n    (-b - sqrt(d))/(2.0*a),\\n    (-b + sqrt(d))/(2.0*a)\\n    );\\n}\\n\\nvec3 atmosphere(vec3 r, vec3 r0, vec3 pSun, float iSun, float rPlanet, float rAtmos, vec3 kRlh, float kMie, float shRlh, float shMie, float g) {\\n    // Normalize the sun and view directions.\\n    pSun = normalize(pSun);\\n    r = normalize(r);\\n\\n    // Calculate the step size of the primary ray.\\n    vec2 p = rsi(r0, r, rAtmos);\\n    if (p.x > p.y) return vec3(0,0,0);\\n    p.y = min(p.y, rsi(r0, r, rPlanet).x);\\n    float iStepSize = (p.y - p.x) / float(iSteps);\\n\\n    // Initialize the primary ray time.\\n    float iTime = 0.0;\\n\\n    // Initialize accumulators for Rayleigh and Mie scattering.\\n    vec3 totalRlh = vec3(0,0,0);\\n    vec3 totalMie = vec3(0,0,0);\\n\\n    // Initialize optical depth accumulators for the primary ray.\\n    float iOdRlh = 0.0;\\n    float iOdMie = 0.0;\\n\\n    // Calculate the Rayleigh and Mie phases.\\n    float mu = dot(r, pSun);\\n    float mumu = mu * mu;\\n    float gg = g * g;\\n    float pRlh = 3.0 / (16.0 * PI) * (1.0 + mumu);\\n    float pMie = 3.0 / (8.0 * PI) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));\\n\\n\\n    // Sample the primary ray.\\n    for (int i = 0; i < iSteps; i++) {\\n\\n        // Calculate the primary ray sample position.\\n        vec3 iPos = r0 + r * (iTime + iStepSize * 0.5);\\n\\n\\n\\n        // Calculate the height of the sample.\\n        float iHeight = length(iPos) - rPlanet;\\n\\n        // Calculate the optical depth of the Rayleigh and Mie scattering for this step.\\n        float odStepRlh = exp(-iHeight / shRlh) * iStepSize;\\n        float odStepMie = exp(-iHeight / shMie) * iStepSize;\\n\\n        // Accumulate optical depth.\\n        iOdRlh += odStepRlh;\\n        iOdMie += odStepMie;\\n\\n        // Calculate the step size of the secondary ray.\\n        float jStepSize = rsi(iPos, pSun, rAtmos).y / float(jSteps);\\n\\n        // Initialize the secondary ray time.\\n        float jTime = 0.0;\\n\\n        // Initialize optical depth accumulators for the secondary ray.\\n        float jOdRlh = 0.0;\\n        float jOdMie = 0.0;\\n\\n        // Sample the secondary ray.\\n        for (int j = 0; j < jSteps; j++) {\\n\\n            // Calculate the secondary ray sample position.\\n            vec3 jPos = iPos + pSun * (jTime + jStepSize * 0.5);\\n\\n            // Calculate the height of the sample.\\n            float jHeight = length(jPos) - rPlanet;\\n\\n            // Accumulate the optical depth.\\n            jOdRlh += exp(-jHeight / shRlh) * jStepSize;\\n            jOdMie += exp(-jHeight / shMie) * jStepSize;\\n\\n            // Increment the secondary ray time.\\n            jTime += jStepSize;\\n        }\\n\\n        // Calculate attenuation.\\n        vec3 attn = exp(-(kMie * (iOdMie + jOdMie) + kRlh * (iOdRlh + jOdRlh)));\\n\\n        // Accumulate scattering.\\n        totalRlh += odStepRlh * attn;\\n        totalMie += odStepMie * attn;\\n\\n        // Increment the primary ray time.\\n        iTime += iStepSize;\\n\\n    }\\n\\n    // Calculate and return the final color.\\n    return iSun * (pRlh * kRlh * totalRlh + pMie * kMie * totalMie);\\n}\\n\\n\\n\\n// my ray march\\n\\n\\nvec4 Wrld2Screen(vec3 pos){\\n    vec4 clipSpacePos =  u_ViewProj * vec4(pos,1.0);\\n    clipSpacePos = clipSpacePos/ clipSpacePos.w;\\n    clipSpacePos.x = (clipSpacePos.x + 1.0) / 2.0;\\n    clipSpacePos.y = (1.0 - clipSpacePos.y) / 2.0;\\n    clipSpacePos.z = (clipSpacePos.z + 1.0) / 2.0;// d\\n    return clipSpacePos;\\n}\\n\\nvec4 Screen2Light(vec3 pos){\\n    vec4 lightSpacePos = u_sproj * u_sview * vec4(pos,1.0);\\n    lightSpacePos = lightSpacePos / lightSpacePos.w;\\n    lightSpacePos = lightSpacePos * 0.5 + 0.5;\\n    return lightSpacePos;\\n}\\n\\n#define SCATTER_MARCH_STEPS 10\\n#define SCATTER_MARCH_STEP_SIZE 0.1\\n\\nvec4 scatter_m(vec3 ro, vec3 rd){\\n\\n    vec2 uv = 0.5*fs_Pos+0.5;\\n    vec3 sceneDepthValue = texture(sceneDepth,uv).xyz;\\n    float linearSceneDepthVal = linearDepth(sceneDepthValue.x); // max length can travel for this specific ray\\n    float rayAttenuation = 1.0 * linearSceneDepthVal;\\n\\n\\n    float stepSize = ((linearSceneDepthVal + 0.01) / float(SCATTER_MARCH_STEPS)) ;\\n    if(sceneDepthValue.x == 0.0){\\n        stepSize = 0.2;\\n        rayAttenuation = 1.0;\\n    }\\n    //rayAttenuation = clamp(rayAttenuation, 0.0, 1.0);\\n\\n    vec4 col = vec4(0.0);\\n    vec3 fog_col = 1.50 *  vec3(0.6,0.6,0.6) * clamp(rayAttenuation,0.0,1.0);\\n    float fog_alpha = 1.0 * rayAttenuation;\\n    float scatter_alpha_acc_all = fog_alpha / float(SCATTER_MARCH_STEPS);\\n    float scatter_alpha_acc = scatter_alpha_acc_all*1.0/ 14.0;\\n    float scatter_alpha_acc_out = scatter_alpha_acc_all * 13.0/ 14.0;\\n\\n    vec3 scatter_col_acc_all = fog_col/float(SCATTER_MARCH_STEPS);\\n    vec3 scatter_col_acc = scatter_col_acc_all*1.0 / 4.0;\\n    vec3 scatter_col_acc_out = scatter_col_acc_all * 13.0 / 14.0;\\n\\n\\n\\n    float dither = iib(gl_FragCoord.xy);\\n    vec3 pos = ro + rd * stepSize * dither;\\n   //pos = ro;\\n    int i = 1;\\n    for(i = 1;i<SCATTER_MARCH_STEPS; ++i){\\n\\n        float heightAtten = 1.0 * exp(-pos.y);\\n        col += heightAtten * vec4(scatter_col_acc,scatter_alpha_acc);\\n\\n\\n        pos += rd * stepSize;\\n\\n        vec4 clipSpacePos =  Wrld2Screen(pos);\\n//        vec3 clipSpaceRdVec = Wrld2Screen(rd * stepSize).xyz;\\n//        float clipSpaceStepSize = length(clipSpaceRdVec);\\n\\n        vec4 lightSpacePos = Screen2Light(pos);\\n        float texsize = 1.0/4096.0f;\\n        float shadowMapDepth = texture(shadowMap, lightSpacePos.xy).x;\\n\\n        if(lightSpacePos.x <= 0.0 || lightSpacePos.x >= 1.0 || lightSpacePos.y <= 0.0 || lightSpacePos.y >= 1.0){\\n            shadowMapDepth = 0.0f;\\n        }\\n        if(lightSpacePos.z < shadowMapDepth || shadowMapDepth==0.0){\\n            col += vec4(scatter_col_acc_out,scatter_alpha_acc_out);\\n        }else{\\n            float diff = linearDepth(lightSpacePos.z) - linearDepth(shadowMapDepth);\\n            col -= 2.0 * diff * vec4(scatter_col_acc_out,scatter_alpha_acc_out) / SCATTER_MARCH_STEP_SIZE;\\n\\n        }\\n\\n\\n        if(sceneDepthValue.x < clipSpacePos.z  && sceneDepthValue.x != 0.0){\\n\\n            //col -= diff * vec4(scatter_col_acc,scatter_alpha_acc) / SCATTER_MARCH_STEP_SIZE;\\n           break;\\n        }\\n        //vec3 attn = exp( -)\\n\\n    }\\n\\n\\n\\n    col = clamp(col, vec4(0.0),vec4(1.0));\\n\\n    return col;\\n}\\n\\n\\nvoid main() {\\n    vec2 uv = 0.5*fs_Pos+0.5;\\n    vec3 sceneDepthValue = texture(sceneDepth,uv).xyz;\\n    float vsceneDepthValue = linearDepth(sceneDepthValue.x);\\n\\n\\n    float sx = (2.f*gl_FragCoord.x/u_Dimensions.x)-1.f;\\n    float sy = 1.f-(2.f*gl_FragCoord.y/u_Dimensions.y);\\n    float len = length(u_Ref - u_Eye);\\n    vec3 forward = normalize(u_Ref - u_Eye);\\n    vec3 right = cross(forward,u_Up);\\n    vec3 V = u_Up * len * tan(FOV/2.f);\\n    vec3 H = right * len * (u_Dimensions.x/u_Dimensions.y) * tan(FOV/2.f);\\n    vec3 p = u_Ref + sx * H - sy * V;\\n\\n\\n\\n    vec3 rd = normalize(p - u_Eye);\\n    vec3 ro = u_Eye;\\n\\n\\n    float planetScale = 1.0;\\n\\n\\n\\n    gl_FragDepth = 0.01;\\n\\n    float angle = dot(normalize(unif_LightPos),vec3(0.0,1.0,0.0));\\n    vec3 hue = mix(vec3(255.0,255.0,240.0)/256.0, vec3(255.0,100.0,20.0)/256.0, 1.0 - angle);\\n\\n    vec4 finalCol = vec4(0.0,0.0,0.0,1.0);//vec4(0.0,0.0,0.0,1.0);\\n    if(u_showScattering == 0){\\n        finalCol = vec4(0.0,0.0,0.0,0.0);\\n        gl_FragDepth = 0.99999;\\n    }else{\\n        finalCol = scatter_m(ro,rd);\\n        finalCol.xyz = vec3(1.0) - exp(-finalCol.xyz * 2.0 ); //fog fall off\\n        finalCol.xyz = pow(finalCol.xyz, vec3(2.0)); // make fog more esay to accumulate based on dis\\n        float sunAmount = max(dot(rd, normalize(unif_LightPos)),0.0);\\n        finalCol.xyz *= mix(vec3(0.6,0.6,0.6) * 0.6,hue, pow(sunAmount, 8.0));\\n        finalCol.w *= 1.0;\\n        finalCol.w = clamp(finalCol.w, 0.0, 1.0);\\n        //finalCol.w *=  1.0 - exp(-finalCol.w * 2.0);\\n    }\\n    if(sceneDepthValue.x==0.0){\\n        vec3 color = sky(rd);\\n        //finalCol.w = 0.0;\\n        if(u_showScattering == 1){\\n            color = atmosphere(\\n                normalize(rd), // normalized ray direction\\n                vec3(0, 6371e3, 0) * planetScale + vec3(0.0, 0.0, 0.0) + ro, // ray origin\\n                unif_LightPos, // position of the sun\\n                20.0, // intensity of the sun\\n                6371e3 * planetScale, // radius of the planet in meters\\n                6871e3 * planetScale, // radius of the atmosphere in meters\\n                1.0 * vec3(5.5e-6, 13.0e-6, 22.4e-6), // Rayleigh scattering coefficient\\n                1.0 * 21e-6, // Mie scattering coefficient\\n                8e3 * planetScale, // Rayleigh scale height\\n                2.4e3 * planetScale, // Mie scale height\\n                0.958// Mie preferred scattering direction\\n                );\\n            finalCol.xyz  = mix(max(color,vec3(0.0,0.0,0.0)) , finalCol.xyz, 0.8 * finalCol.w);\\n            finalCol.w = 1.0;\\n        }else{\\n            finalCol.xyz = color;\\n            finalCol.w = 1.0;\\n        }\\n\\n    }\\n\\n\\n    //finalCol = mix(finalCol, vec4(1.0,1.0,0.9,1.0), 3.0 * getSun(rd));\\n\\n    out_Col = vec4(  pow(vec3(finalCol.xyz), vec3(1.0/2.0)), finalCol.w);\\n    //out_Col = vec4(sceneDepthValue,1.0);\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\n\\nin vec4 vs_Pos;\\nout vec2 fs_Pos;\\n\\nvoid main() {\\n  fs_Pos = vs_Pos.xy;\\n  gl_Position = vs_Pos;\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\n\\nin vec2 fs_Pos;\\nuniform float u_Time;\\nuniform float u_TerrainScale;\\nuniform float u_TerrainHeight;\\nuniform int u_terrainBaseType;\\nuniform int u_TerrainMask;\\nuniform sampler2D u_HeightMap; // Optional height map texture\\nuniform int u_UseHeightMap; // 0 = procedural, 1 = use height map\\n\\nlayout (location = 0) out vec4 initial;\\nlayout (location = 1) out vec4 initial2;\\n\\n//voroni=========================================================================\\n\\nvec3 hash3( vec2 p ){\\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)),\\n\\t\\t\\t\\t   dot(p,vec2(269.5,183.3)),\\n\\t\\t\\t\\t   dot(p,vec2(419.2,371.9)) );\\n\\treturn fract(sin(q)*43758.5453);\\n}\\n\\nfloat iqnoise( in vec2 x, float u, float v ){\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n\\n\\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\\n\\n\\tfloat va = 0.0;\\n\\tfloat wt = 0.0;\\n    for( int j=-2; j<=2; j++ )\\n    for( int i=-2; i<=2; i++ )\\n    {\\n        vec2 g = vec2( float(i),float(j) );\\n\\t\\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\\n\\t\\tvec2 r = g - f + o.xy;\\n\\t\\tfloat d = dot(r,r);\\n\\t\\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\\n\\t\\tva += o.z*ww;\\n\\t\\twt += ww;\\n    }\\n\\n    return va/wt;\\n}\\n//voroni=========================================================================\\n\\n\\n\\n//smooth========================================================================\\nvec2 random2(vec2 st){\\n    st = vec2( dot(st,vec2(127.1,311.7)),\\n              dot(st,vec2(269.5,183.3)) );\\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\\n}\\n\\n// Value Noise by Inigo Quilez - iq/2013\\n// https://www.shadertoy.com/view/lsf3WH\\nfloat noise2(vec2 st) {\\n    vec2 i = floor(st);\\n    vec2 f = fract(st);\\n\\n    vec2 u = f*f*(3.0-2.0*f);\\n\\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\\n}\\n\\n\\n//smooth========================================================================\\n\\n#define OCTAVES 12\\n\\nfloat random (in vec2 st) {\\n    return fract(sin(dot(st.xy,\\n                         vec2(12.9898,78.233)))*\\n        43758.5453123);\\n}\\n\\n\\nfloat noise (in vec2 st) {\\n    vec2 i = floor(st);\\n    vec2 f = fract(st);\\n\\n    // Four corners in 2D of a tile\\n    float a = random(i);\\n    float b = random(i + vec2(1.0, 0.0));\\n    float c = random(i + vec2(0.0, 1.0));\\n    float d = random(i + vec2(1.0, 1.0));\\n\\n    vec2 u = f * f * (3.0 - 2.0 * f);\\n\\n    return mix(a, b, u.x) +\\n            (c - a)* u.y * (1.0 - u.x) +\\n            (d - b) * u.x * u.y;\\n}\\n\\n\\nfloat fbm (in vec2 st) {\\n    // Initial values\\n    float value = 0.0;\\n    float amplitude = .5;\\n    float frequency = 0.;\\n    //\\n    // Loop of octaves\\n    for (int i = 0; i < OCTAVES; i++) {\\n        value += amplitude * noise(st);//iqnoise(st,1.f,1.f);\\n        st *= 2.0;\\n        amplitude *= .47;\\n    }\\n    return value;\\n}\\n\\nfloat voroni(in vec2 ss){\\n    float qq = iqnoise(ss * 2.0, 2.0f, 2.0f);\\n    return qq;\\n}\\n\\nfloat teR(float h) {\\n    float W = 0.04; // width of terracing bands\\n    float k = floor(h / W);\\n    float f = (h - k*W) / W;\\n    float s = min(100.0 * f, 1.0);\\n    return (k+s) * W;\\n}\\n\\nfloat domainwarp(vec2 p){\\n    return fbm(p+fbm(p+fbm(p)));\\n}\\n\\nfloat test(vec2 p){\\n    return abs(pow(2.0,-length(p - vec2(0.5))*2.0));\\n}\\n\\nfloat circle_mask(vec2 p){\\n    return max(0.5 - distance(p, vec2(0.5)), 0.0) ;\\n}\\n\\nfloat square_mask(vec2 p){\\n    vec2 center = vec2(0.5);\\n    vec2 d = abs(p - center);\\n    float size = 0.4;\\n    return max(0.0, 1.0 - max(d.x, d.y) / size);\\n}\\n\\nfloat ring_mask(vec2 p){\\n    float dist = distance(p, vec2(0.5));\\n    float inner = 0.2;\\n    float outer = 0.4;\\n    return smoothstep(outer, inner, dist) * smoothstep(inner - 0.1, inner, dist);\\n}\\n\\nfloat radial_gradient_mask(vec2 p){\\n    float dist = distance(p, vec2(0.5));\\n    return 1.0 - smoothstep(0.0, 0.7, dist);\\n}\\n\\nfloat corner_mask(vec2 p){\\n    return (1.0 - p.x) * (1.0 - p.y);\\n}\\n\\nfloat diagonal_mask(vec2 p){\\n    return abs(p.x - p.y);\\n}\\n\\nfloat cross_mask(vec2 p){\\n    vec2 center = vec2(0.5);\\n    vec2 d = abs(p - center);\\n    float width = 0.15;\\n    return max(smoothstep(width, 0.0, d.x), smoothstep(width, 0.0, d.y));\\n}\\n\\nfloat ridgenoise(float p) {\\n    return 0.8 * (0.3 - abs(0.3 - p));\\n}\\n\\n//nice one 5.3f*uv+vec2(178.f,27.f);\\n\\n// 6.f*vec2(uv.x,uv.y)+vec2(121.f,41.f);\\nvoid main() {\\n\\n  vec2 rdp1 = vec2(0.2,0.5);\\n  vec2 rdp2 = vec2(0.1,0.8);\\n  vec2 uv = 0.5f*fs_Pos+vec2(0.5f);\\n\\n    float terrain_hight;\\n    float rainfall = .0f;\\n    \\n    // Check if we should use the imported height map\\n    if(u_UseHeightMap == 1){\\n        // Sample from the height map texture\\n        vec4 heightMapSample = texture(u_HeightMap, uv);\\n        terrain_hight = heightMapSample.x; // R channel contains terrain height\\n        // Optionally preserve water and rock from height map if they exist\\n        // rainfall = heightMapSample.y; // G channel for water (currently 0.0)\\n        // rock material = heightMapSample.z; // B channel for rock (currently 0.0)\\n    } else {\\n        // Procedural generation (original code)\\n        float c_mask = circle_mask(uv);\\n        vec2 cpos = 1.5 * uv * u_TerrainScale;\\n        cpos = cpos + vec2(1.f*sin(u_Time / 3.0) + 2.1,1.0 * cos(u_Time/17.0)+3.6);\\n\\n        terrain_hight = fbm(cpos*2.0)*1.1;\\n        float base_height = fbm(cpos*6.2)/1.0;\\n\\n        terrain_hight = pow(terrain_hight,3.0)/1.0;\\n        //terrain_hight = ridgenoise(terrain_hight);\\n        if(u_terrainBaseType == 2){\\n            terrain_hight = teR(terrain_hight / 1.2);\\n        }else if(u_terrainBaseType == 1){\\n            terrain_hight = domainwarp(cpos * 2.0)/1.0;\\n        }else if(u_terrainBaseType == 3){\\n            terrain_hight = voroni(cpos * 2.0)/3.0;\\n        }else if(u_terrainBaseType == 4){\\n            terrain_hight =  ridgenoise(pow(fbm(cpos*1.5),2.0));\\n        }\\n\\n        terrain_hight *= u_TerrainHeight*120.0;\\n        if(u_TerrainMask == 1){\\n            // Sphere mask - circular gradient from center\\n            terrain_hight *= 2.0 * pow(c_mask, 1.0);\\n        }else if(u_TerrainMask == 2){\\n            // Slope mask - diagonal gradient\\n            terrain_hight *= (uv.x + uv.y) * 1.0;\\n        }else if(u_TerrainMask == 3){\\n            // Square mask - square gradient from center\\n            float sq_mask = square_mask(uv);\\n            terrain_hight *= 2.0 * pow(sq_mask, 1.0);\\n        }else if(u_TerrainMask == 4){\\n            // Ring mask - donut shape\\n            float ring = ring_mask(uv);\\n            terrain_hight *= 2.0 * ring;\\n        }else if(u_TerrainMask == 5){\\n            // Radial gradient - smooth falloff from center\\n            float radial = radial_gradient_mask(uv);\\n            terrain_hight *= 2.0 * radial;\\n        }else if(u_TerrainMask == 6){\\n            // Corner mask - highest in bottom-left corner\\n            float corner = corner_mask(uv);\\n            terrain_hight *= 2.0 * corner;\\n        }else if(u_TerrainMask == 7){\\n            // Diagonal mask - diagonal stripe pattern\\n            float diag = diagonal_mask(uv);\\n            terrain_hight *= 1.0 + diag * 0.5;\\n        }else if(u_TerrainMask == 8){\\n            // Cross mask - cross pattern from center\\n            float cross = cross_mask(uv);\\n            terrain_hight *= 1.0 + cross * 0.5;\\n        }\\n        //terrain_hight = test(uv) * 500.0;\\n    }\\n\\n//    if(uv.x > 0.5)\\n//    terrain_hight = (40.0 * (uv.x - 0.5));\\n//    else\\n//    terrain_hight = 0.0;\\n\\n  //if(uv.x>0.6||uv.x<0.5||uv.y>0.6||uv.y<0.5) rainfall = 0.f;\\n    initial = vec4(terrain_hight,rainfall,0.0,1.f);\\n    initial2= vec4(terrain_hight,rainfall,0.0,1.f);\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readTerrain;//water and hight map R: hight map, G: water map, B: , A:\\nuniform sampler2D readFlux;\\nuniform sampler2D readSedi;\\n\\n\\nuniform float u_SimRes;\\nuniform float u_PipeLen;\\nuniform float u_timestep;\\nuniform float u_PipeArea;\\n\\nlayout (location = 0) out vec4 writeFlux;\\n\\n\\nin vec2 fs_Pos;\\n\\n#define useMullerPath false\\n\\n\\n// normal centered grid vec4(x, y, z, w)\\n//\\n//      x\\n//  w   c   y\\n//      z\\n//\\n// staggered grid vec4(r,t,0,1);\\n//     t.()\\n//     c         r.()\\n\\n\\n\\nvoid main() {\\n\\n\\n\\n\\n\\n  vec2 curuv = 0.5f*fs_Pos+0.5f;\\n  float div = 1.f/u_SimRes;\\n  float g = 0.80;\\n  float pipelen = u_PipeLen;\\n\\n  float sediImpact = 1.0;\\n\\n  vec4 top = texture(readTerrain,curuv+vec2(0.f,div));\\n  vec4 right = texture(readTerrain,curuv+vec2(div,0.f));\\n  vec4 bottom = texture(readTerrain,curuv+vec2(0.f,-div));\\n  vec4 left = texture(readTerrain,curuv+vec2(-div,0.f));\\n\\n\\n\\n  float damping = 1.0;\\n  vec4 curTerrain = texture(readTerrain,curuv);\\n  vec4 curFlux = texture(readFlux,curuv) * damping;\\n\\n  // Check if this is rock material - rock surfaces are smoother, so water flows faster\\n  float rockVal = curTerrain.z;\\n  bool isRock = rockVal > 0.1; // Consistent with sediment shader threshold\\n  // Rock has lower roughness/friction, so water flows faster\\n  // Reduce effective pipe length on rock to simulate lower friction (smoother surface)\\n  // Rock typically has 2-3x lower roughness coefficient than soil\\n  float effectivePipeLen = pipelen;\\n  if (isRock) {\\n    // Reduce pipe length on rock by factor of 2-3 (representing lower friction)\\n    // This makes flow faster on rock surfaces\\n    effectivePipeLen = pipelen * 0.4; // Water flows ~2.5x faster on rock\\n  }\\n\\n  // Calculate height differences for flow (terrain height + water height)\\n  // Flow is based on height differences, but rock affects flow speed through reduced friction\\n  float Htopout = (curTerrain.y+curTerrain.x )-(top.y+top.x );\\n  float Hrightout = (curTerrain.y+curTerrain.x)-(right.y+right.x);\\n  float Hbottomout = (curTerrain.y+curTerrain.x)-(bottom.x+bottom.y);\\n  float Hleftout = (curTerrain.y+curTerrain.x)-(left.y+left.x);\\n//\\n//  Htopout = max(0.0, Htopout);\\n//  Hbottomout = max(0.0, Hbottomout);\\n//  Hrightout = max(0.0, Hrightout);\\n//  Hleftout = max(0.0, Hleftout);\\n\\n  //out flow readFlux\\n//  float ftopout = max(0.f,(u_timestep*g*u_PipeArea*Htopout)/pipelen);\\n//  float frightout = max(0.f,(u_timestep*g*u_PipeArea*Hrightout)/pipelen);\\n//  float fbottomout = max(0.f,(u_timestep*g*u_PipeArea*Hbottomout)/pipelen);\\n//  float fleftout = max(0.f,(u_timestep*g*u_PipeArea*Hleftout)/pipelen);\\n\\n  float ftopout = max(0.f,curFlux.x+(u_timestep*g*u_PipeArea*Htopout)/effectivePipeLen);\\n  float frightout = max(0.f,curFlux.y+(u_timestep*g*u_PipeArea*Hrightout)/effectivePipeLen);\\n  float fbottomout = max(0.f,curFlux.z+(u_timestep*g*u_PipeArea*Hbottomout)/effectivePipeLen);\\n  float fleftout = max(0.f,curFlux.w+(u_timestep*g*u_PipeArea*Hleftout)/effectivePipeLen);\\n\\n  float waterOut = u_timestep*(ftopout+frightout+fbottomout+fleftout);\\n  //damping = 1.0;\\n  float k = min(1.f,((curTerrain.y )*u_PipeLen*u_PipeLen)/waterOut) ;\\n\\n  //k = 1.0;\\n  //rescale outflow readFlux so that outflow don't exceed current water volume\\n  ftopout *= k;\\n  frightout *= k;\\n  fbottomout *= k;\\n  fleftout *= k;\\n\\n  //boundary conditions\\n  if(curuv.x<=div) fleftout = 0.f;\\n  if(curuv.x>=1.f - 2.0 * div) frightout = 0.f;\\n  if(curuv.y<=div) ftopout = 0.f;\\n  if(curuv.y>=1.f - 2.0 * div) fbottomout = 0.f;\\n\\n  if(curuv.x<=div || (curuv.x>=1.f - 2.0 * div) ||(curuv.y<=div) ||(curuv.y>=1.f - 2.0 * div) ){\\n    ftopout = 0.0;\\n    frightout = 0.0;\\n    fbottomout = 0.0;\\n    fleftout = 0.0;\\n  }\\n\\n\\n\\n//  float divs = min(abs(veloci.x), abs(veloci.y))/max(abs(veloci.x), abs(veloci.y));\\n//\\n//  veloci *= max(0.01,divs / 1.0);\\n\\n  writeFlux = vec4(ftopout,frightout,fbottomout,fleftout);\\n\\n\\n  // for muller path\\n\\n\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readTerrain;//water and hight map R: hight map, G: water map, B: , A:\\nuniform sampler2D readFlux;//flux map R: top, G: right, B: bottom, A: left\\nuniform sampler2D readSedi;\\nuniform sampler2D readVel;\\n\\nuniform float u_SimRes;\\nuniform float u_PipeLen;\\nuniform float u_timestep;\\nuniform float u_PipeArea;\\nuniform float u_VelMult;\\nuniform float u_Time;\\nuniform float u_VelAdvMag;\\n\\nlayout (location = 0) out vec4 writeTerrain;\\nlayout (location = 1) out vec4 writeVel;\\n\\n#define useMullerPath false\\n\\nin vec2 fs_Pos;\\n#define PI 3.1415926\\n#define SQRT2 1.414\\n\\nfloat random (in vec2 st) {\\n  return fract(sin(dot(st.xy,\\n  vec2(12.9898,78.233)))*\\n  43758.5453123);\\n}\\n\\nvoid main(){\\n\\n\\n\\n\\n\\n\\n\\n\\n  vec2 curuv = 0.5f*fs_Pos+0.5f;\\n  float div = 1.f/u_SimRes;\\n  float pipelen = u_PipeLen;\\n  float sediImpact = 1.0;\\n  float g = 0.80;\\n  //\\n  //      x\\n  //  w   c   y\\n  //      z\\n  //\\n\\n  vec4 curflux = texture(readFlux, curuv);\\n  vec4 cur = texture(readTerrain, curuv);\\n  vec4 curvel = texture(readVel, curuv);\\n\\n\\n  vec4 topflux = texture(readFlux, curuv+vec2(0.f, div));\\n  vec4 rightflux = texture(readFlux, curuv+vec2(div, 0.f));\\n  vec4 bottomflux = texture(readFlux, curuv+vec2(0.f, -div));\\n  vec4 leftflux = texture(readFlux, curuv+vec2(-div, 0.f));\\n\\n\\n\\n  //out flow flux\\n  float ftopout = curflux.x;\\n  float frightout = curflux.y;\\n  float fbottomout = curflux.z;\\n  float fleftout = curflux.w;\\n\\n  vec4 outputflux = curflux;\\n  vec4 inputflux = vec4(topflux.z, rightflux.w, bottomflux.x, leftflux.y);\\n\\n  float fout = ftopout+frightout+fbottomout+fleftout;\\n  float fin = topflux.z+rightflux.w+bottomflux.x+leftflux.y;\\n\\n\\n  float deltavol = u_timestep*(fin-fout)/(u_PipeLen*u_PipeLen);\\n\\n\\n  //float velFactor = pow((length(curvel.xy) * 0.2 + 1.0), -2.0);// emperical function for self aware velocity calculation\\n\\n\\n  //  vec2 randTime = vec2(1.f*sin(u_Time / 3.0) + 2.1,1.0 * cos(u_Time/17.0)+3.6) + curuv * 10.0;\\n  //  float rnd = random(randTime);\\n\\n  float d1 = cur.y;\\n  float d2 = max(d1 + deltavol, 0.0);\\n  float da = (d1 + d2)/2.0f;\\n  vec2 veloci = vec2(leftflux.y-outputflux.w+outputflux.y-rightflux.w, bottomflux.x-outputflux.z+outputflux.x-topflux.z)/2.0;\\n  if (cur.y == 0.0 && deltavol == 0.0) veloci = vec2(0.0, 0.0);\\n\\n\\n  if (da <= 0.0001) {\\n    veloci = vec2(0.0);\\n  } else {\\n    veloci = veloci/(da * u_PipeLen);\\n  }\\n\\n  //veloci += curvel.xy * 0.9;\\n\\n  // my attempts trying to mitigate axis aligning problem, none worked :(\\n  //    vec2 velnorm = normalize(veloci);\\n  //    float lvel = abs(velnorm.x) >= abs(velnorm.y) ? abs(velnorm.x) : abs(velnorm.y);\\n  //    float svel = abs(velnorm.x) < abs(velnorm.y) ? abs(velnorm.x) : abs(velnorm.y);\\n  //    float sl = sqrt(velnorm.x * velnorm.x + velnorm.y * velnorm.y);\\n\\n\\n  //veclocity advection\\n    vec4 useVel = curvel/u_SimRes;\\n    useVel *= 0.5;\\n\\n\\n    vec2 oldloc = vec2(curuv.x-useVel.x*u_timestep,curuv.y-useVel.y*u_timestep);\\n    vec2 oldvel = texture(readVel, oldloc).xy;\\n\\n    veloci += oldvel * u_VelAdvMag;//(1.0 - exp(- cur.y * 20.0));\\n\\n  // !!! very important !!! : disregard really small body of water as it will disrupt the sediment advection step (since advection is only dependent on velocity, small water body will\\n  // be the numerical limitation for the lower threshold of simulation can handle, any value below it will be treated qually regardless of their own differences, and this is really bad\\n  // , it can make the sediment go entirely randomly and chaoticly when water happen to be very shallow, and I have been quite troubled by this issue for a while)\\n  //\\n  if (cur.y < 0.01){\\n    //veloci *= pow(cur.y/0.01,3.0);\\n    veloci = vec2(0.0);\\n  }\\n  else {\\n    //veloci *= (1.0 - exp(65.0 * (-cur.y + 0.01)));\\n  }\\n\\n\\n\\n//    // muller height field integration\\n//\\n//    vec4 curTerrain = texture(readTerrain, curuv);\\n//    vec4 RTerrain = texture(readTerrain, curuv + vec2(div, 0.0));\\n//    vec4 TTerrain = texture(readTerrain, curuv + vec2(0.0, div));\\n//    vec4 BTerrain = texture(readTerrain, curuv - vec2(0.0, div));\\n//    vec4 LTerrain = texture(readTerrain, curuv - vec2(div, 0.0));\\n//\\n//\\n//    vec4 leftvel = texture(readVel, curuv - vec2(div, 0.0));\\n//    vec4 bottomvel = texture(readVel, curuv - vec2(0.0, div));\\n//\\n//    float deltaH = 0.0;\\n//\\n//    float waterHeightRight = 0.0, waterHeightLeft = 0.0;\\n//    float waterHeightTop = 0.0, waterHeightBottom = 0.0;\\n//\\n//    if(curvel.z <= 0.0){\\n//      deltaH += (RTerrain.y * curvel.z / 1.0);\\n//    }else{\\n//      deltaH += curTerrain.y * curvel.z / 1.0;\\n//    }\\n//\\n//    if(curvel.w <= 0.0){\\n//      deltaH += (TTerrain.y * curvel.w / 1.0);\\n//    }else{\\n//      deltaH += curTerrain.y * curvel.w / 1.0;\\n//    }\\n//\\n//    if(leftvel.z <= 0.0){\\n//      deltaH -= curTerrain.y * leftvel.z/1.0;\\n//    }else{\\n//      deltaH -= LTerrain.y * leftvel.z / 1.0;\\n//    }\\n//\\n//    if(bottomvel.w <= 0.0){\\n//      deltaH -= curTerrain.y * bottomvel.w / 1.0;\\n//    }else{\\n//      deltaH -= BTerrain.y * bottomvel.w / 1.0;\\n//    }\\n//\\n//    deltaH = -deltaH * u_timestep * 1.0;\\n//\\n//\\n//   // float hadj = max(0.0, (RTerrain.y + TTerrain.y + BTerrain.y + LTerrain.y)/4.0 - (2.0 * 1.0 / (g * u_timestep)));\\n//\\n//    // muller velocity integration\\n//\\n//\\n//    float velr = curvel.z+ (curTerrain.x + curTerrain.y - RTerrain.x - RTerrain.y)*g*u_timestep/1.0;\\n//    float velt = curvel.w + (curTerrain.x + curTerrain.y - TTerrain.x - TTerrain.y)*g*u_timestep/1.0;\\n//\\n//    velr = min(0.50/u_timestep, velr);\\n//    velt = min(0.50/u_timestep, velt);\\n//\\n//\\n//    float threshold = 0.0001;\\n//    if(curTerrain.y <= threshold && TTerrain.y <=threshold){\\n//      velt = 0.0;\\n//    }if(curTerrain.y <= threshold && RTerrain.y <=threshold){\\n//      velr = 0.0;\\n//    }\\n\\n\\n  //writeVel = vec4(veloci * u_VelMult, velr, velt);\\n  writeVel = vec4(veloci * u_VelMult, curvel.z, curvel.w);\\n  //writeTerrain = vec4(cur.x, max(0.0, deltaH + curTerrain.y ), 0.0, 1.0);\\n  // Preserve B channel (rock material) and A channel\\n  writeTerrain = vec4(cur.x, max(cur.y+deltavol, 0.0), cur.z, cur.w);\\n\\n\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readTerrain;//water and hight map R: hight map, G: water map, B: , A:\\nuniform sampler2D readVelocity;\\nuniform sampler2D readSediment;\\n\\nuniform float u_SimRes;\\nuniform float u_PipeLen;\\nuniform float u_Ks;\\nuniform float u_Kc;\\nuniform float u_Kd;\\nuniform float u_timestep;\\nuniform float u_Time;\\nuniform float u_RockErosionResistance;\\n\\nlayout (location = 0) out vec4 writeTerrain;\\nlayout (location = 1) out vec4 writeSediment;\\nlayout (location = 2) out vec4 writeTerrainNormal;\\nlayout (location = 3) out vec4 writeVelocity;\\n\\n\\n\\n\\n\\nin vec2 fs_Pos;\\n\\n#define OCTAVES 10\\n\\nfloat random (in vec2 st) {\\n  return fract(sin(dot(st.xy,\\n  vec2(12.9898,78.233)))*\\n  43758.5453123);\\n}\\nfloat noise (in vec2 st) {\\n  vec2 i = floor(st);\\n  vec2 f = fract(st);\\n\\n  // Four corners in 2D of a tile\\n  float a = random(i);\\n  float b = random(i + vec2(1.0, 0.0));\\n  float c = random(i + vec2(0.0, 1.0));\\n  float d = random(i + vec2(1.0, 1.0));\\n\\n  vec2 u = f * f * (3.0 - 2.0 * f);\\n\\n  return mix(a, b, u.x) +\\n  (c - a)* u.y * (1.0 - u.x) +\\n  (d - b) * u.x * u.y;\\n}\\n\\n\\nfloat fbm (in vec2 st) {\\n  // Initial values\\n  float value = 0.0;\\n  float amplitude = .5;\\n  float frequency = 0.;\\n  //\\n  // Loop of octaves\\n  for (int i = 0; i < OCTAVES; i++) {\\n    value += amplitude * noise(st);//iqnoise(st,1.f,1.f);\\n    st *= 2.0;\\n    amplitude *= .47;\\n  }\\n  return value;\\n}\\nvec3 calnor(vec2 uv){\\n  float eps = 1.f/u_SimRes;\\n//  vec4 cur = texture(readTerrain,uv);\\n  vec4 r = texture(readTerrain,uv+vec2(eps,0.f));\\n  vec4 t = texture(readTerrain,uv+vec2(0.f,eps));\\n  vec4 b = texture(readTerrain,uv+vec2(0.f,-eps));\\n  vec4 l = texture(readTerrain,uv+vec2(-eps,0.f));\\n\\n//  vec4 rs = texture(readSediment,uv+vec2(eps,0.f));\\n//  vec4 ts = texture(readSediment,uv+vec2(0.f,eps));\\n//  vec4 bs = texture(readSediment,uv+vec2(0.f,-eps));\\n//  vec4 ls = texture(readSediment,uv+vec2(-eps,0.f));\\n\\n\\n  //vec3 nor = vec3(l.x + l.y  - r.x - r.y , 2.0, t.x + t.y - b.x - b.y );\\n  //vec3 nor = vec3(l.x + ls.x - r.x - rs.x, 2.0, t.x + ts.x - b.x - bs.x);\\n  vec3 nor = vec3(l.x - r.x , 2.0, t.x - b.x);\\n  nor = normalize(nor);\\n  return nor;\\n}\\n\\nvoid main() {\\n\\n  vec2 curuv = 0.5f*fs_Pos+0.5f;\\n  float div = 1.f/u_SimRes;\\n  float Kc = u_Kc;\\n  float Ks = u_Ks;\\n  float Kd = u_Kd;\\n  float alpha = 5.0;\\n  \\n  // Check if this is rock material (B channel > 0.1) and apply erosion resistance\\n  vec4 curTerrain = texture(readTerrain,curuv);\\n  float rockMaterialValue = curTerrain.z;\\n  bool isRock = rockMaterialValue > 0.1; // Consistent threshold for rock detection\\n  \\n  // Track base rock surface height (A channel stores the height of the rock surface\\n  // before any sediment was deposited on top)\\n  float baseRockSurfaceHeight = curTerrain.w;\\n  // If A channel is 0 or uninitialized and this is rock, initialize it to current height\\n  if (isRock && baseRockSurfaceHeight < 0.001) {\\n    baseRockSurfaceHeight = curTerrain.x;\\n  }\\n  \\n  // Rock should maintain constant resistance until fully converted to soil\\n  // u_RockErosionResistance: 0.0 = no resistance (erodes normally), 1.0 = maximum resistance (doesn't erode)\\n  // So we invert it: rockFactor = 1.0 - resistance (higher resistance = lower factor = less erosion)\\n  // Apply resistance based on rock material value - stronger rock = more resistance\\n  float rockStrength = clamp((rockMaterialValue - 0.1) / 0.9, 0.0, 1.0); // Normalize 0.1-1.0 to 0.0-1.0\\n  float rockFactor = isRock ? (1.0 - u_RockErosionResistance * rockStrength) : 1.0;\\n  \\n  // Check if there's sediment on top of rock\\n  // If current height is above base rock surface, there's sediment on top\\n  bool hasSedimentOnRock = isRock && curTerrain.x > baseRockSurfaceHeight + 0.001;\\n  \\n  // Check neighboring cells for rock to boost erosion in non-rock areas between rock sections\\n  // This creates crevices/valleys between rock areas\\n  // IMPORTANT: Don't boost erosion for recently converted soil (was rock) - this causes excessive sediment\\n  float neighborRockFactor = 1.0;\\n  float capacityBoost = 1.0; // Boost sediment capacity for soil between rock\\n  \\n  // Check if this was recently rock (to prevent boosting recently converted soil)\\n  // Use a lower threshold to catch more recently converted soil\\n  bool wasRecentlyRock = curTerrain.z > 0.05; // Lower threshold to prevent boosting recently converted soil\\n  \\n  if (!isRock && !wasRecentlyRock) {\\n    // Sample neighboring cells to see if any are rock\\n    vec4 topTerrain = texture(readTerrain, curuv + vec2(0.0, div));\\n    vec4 rightTerrain = texture(readTerrain, curuv + vec2(div, 0.0));\\n    vec4 bottomTerrain = texture(readTerrain, curuv + vec2(0.0, -div));\\n    vec4 leftTerrain = texture(readTerrain, curuv + vec2(-div, 0.0));\\n    \\n    int rockNeighbors = 0;\\n    \\n    // Check each neighbor for rock (use consistent threshold)\\n    if (topTerrain.z > 0.1) rockNeighbors++;\\n    if (rightTerrain.z > 0.1) rockNeighbors++;\\n    if (bottomTerrain.z > 0.1) rockNeighbors++;\\n    if (leftTerrain.z > 0.1) rockNeighbors++;\\n    \\n    // Moderate boost for soil between rock to create crevices\\n    // The more rock neighbors, the faster the soil should erode away\\n    // BUT: Only apply to soil that was never rock, not recently converted soil\\n    if (rockNeighbors > 0) {\\n      // Moderate erosion boost - soil between rock should erode faster but not excessively\\n      neighborRockFactor = 1.0 + float(rockNeighbors) * 0.5; // 1.5x to 3x erosion rate (reduced from 4x-13x)\\n      // Also boost capacity moderately so more material can be picked up\\n      capacityBoost = 1.0 + float(rockNeighbors) * 0.3; // 1.3x to 2.2x capacity boost (reduced from 3x-9x)\\n    }\\n  }\\n  \\n  // Apply erosion resistance to rock - reduce both erosion (Ks) and capacity (Kc)\\n  // Rock erodes slower AND produces less sediment capacity when it does erode\\n  // This ensures rock produces less total sediment overall\\n  // The capacity reduction should be proportional to the erosion resistance\\n  // BUT: If there's sediment on top of rock, use normal capacity for the sediment layer\\n  float effectiveCapacityRockFactor = hasSedimentOnRock ? 1.0 : rockFactor;\\n  \\n  // Boost erosion in non-rock areas adjacent to rock to create crevices\\n  // NOTE: Don't apply rockFactor here - it's applied later in the erosion calculation (line 232)\\n  // to avoid applying it twice. Only apply neighborRockFactor for soil between rock.\\n  Ks *= neighborRockFactor; // Boost for non-rock near rock (rockFactor applied later)\\n  Kc *= capacityBoost; // Boost capacity for soil between rock so it erodes faster\\n  // IMPORTANT: Reduce sediment capacity for rock proportionally to erosion resistance\\n  // Rock produces less fine sediment when it erodes, scaled by the same factor as erosion resistance\\n  // This ensures sediment production is proportional to erosion rate\\n  // But use normal capacity if there's sediment on top\\n  Kc *= effectiveCapacityRockFactor; // Reduce capacity for rock, but not for sediment on rock\\n\\n  vec3 nor = calnor(curuv);\\n  float slopeSin;\\n  slopeSin = abs(sqrt(1.0 - nor.y*nor.y));\\n\\n\\n\\n//  vec4 topvel = texture(readVelocity,curuv+vec2(0.f,div));\\n//  vec4 rightvel = texture(readVelocity,curuv+vec2(div,0.f));\\n//  vec4 bottomvel = texture(readVelocity,curuv+vec2(0.f,-div));\\n//  vec4 leftvel = texture(readVelocity,curuv+vec2(-div,0.f));\\n  vec4 curvel = texture(readVelocity,curuv);\\n//\\n//  float sumlen = length(topvel) + length(rightvel) + length(bottomvel) + length(leftvel);\\n//  //velocity diffussion\\n//  vec4 newVel = (topvel + rightvel + bottomvel + leftvel + alpha * curvel)/(4.0 + alpha);\\n//\\n//  newVel = curvel;\\n\\n  vec4 curSediment = texture(readSediment,curuv);\\n  // curTerrain already read above for rock check\\n\\n\\n\\n\\n  float velo = length(curvel.xy);\\n  float slopeMulti = 5.0 * pow(abs(slopeSin),4.0);\\n  float slope = max(0.1f, abs(slopeSin)) ;//max(0.05f,sqrt(1.f- nor.y * nor.y));\\n  float volC = 1.0 - exp(-curTerrain.y* (100.0));\\n  float sedicap = Kc*pow(slope,1.0)*pow(velo,1.0);// * pow(curTerrain.y,0.2) ;\\n\\n//  float lmax = 0.0f;\\n//  float maxdepth = 0.8;\\n//  if(curTerrain.y > maxdepth){ // max river bed depth\\n//    lmax = 0.0f;\\n//  }else{\\n//    lmax = (max(maxdepth - curTerrain.y,0.0)/maxdepth);\\n//  }\\n//  sedicap *= (1.0 - exp(-1.0 * lmax));\\n\\n\\n\\n\\n  float cursedi = curSediment.x;\\n  float hight = curTerrain.x;\\n  float outsedi = curSediment.x;\\n\\n  float water = curTerrain.y;\\n  \\n  // Track if erosion is happening (height decrease)\\n  float heightChange = 0.0;\\n\\n  // Track original rock material value before erosion\\n  float originalRockMaterial = curTerrain.z;\\n  \\n  if(sedicap >cursedi){\\n    // Check if we're eroding sediment on top of rock or the rock itself\\n    bool erodingSedimentLayer = hasSedimentOnRock && hight > baseRockSurfaceHeight;\\n    \\n    // Only apply rock resistance if we're eroding the actual rock, not sediment on top\\n    float effectiveRockFactor = erodingSedimentLayer ? 1.0 : rockFactor;\\n    \\n    // Calculate erosion with correct resistance\\n    float changesedi = (sedicap -cursedi) * (Ks * effectiveRockFactor);\\n    //changesedi = min(changesedi, curTerrain.y);\\n\\n      hight = hight - changesedi;\\n      heightChange = -changesedi; // Negative = erosion\\n      \\n      // If we've eroded down to the base rock surface, reset the base surface height\\n      if (hasSedimentOnRock && hight <= baseRockSurfaceHeight) {\\n        baseRockSurfaceHeight = hight; // Update base to current height\\n      }\\n      \\n      // water = water + (sedicap-cursedi)*Ks;\\n      // IMPORTANT: Rock produces less sediment when it erodes\\n      // Apply additional reduction to sediment output for rock erosion\\n      // Rock is harder and produces less fine sediment than soil\\n      float sedimentOutputFactor = erodingSedimentLayer ? 1.0 : effectiveCapacityRockFactor;\\n      outsedi = outsedi + changesedi * sedimentOutputFactor;\\n      \\n      // When rock erodes, gradually convert it to regular soil\\n      // Rock should erode into normal sediment, but conversion should be very slow so rock resistance actually matters\\n      // Only convert if we're actually eroding rock, not sediment on top\\n      if (rockMaterialValue > 0.1 && changesedi > 0.0 && !erodingSedimentLayer) {\\n        // Convert rock to soil proportionally to the amount eroded\\n        // IMPORTANT: Conversion should be very slow so rock stays rock longer and erosion resistance has effect\\n        // More erosion = more rock converted to soil, but at a much slower rate\\n        float erosionAmount = changesedi;\\n        // Convert rock to soil very slowly - scales with erosion but much slower\\n        // This ensures rock stays rock long enough for the resistance to matter\\n        float conversionRate = min(erosionAmount * 0.05, originalRockMaterial * 0.01); // Convert up to 1% of rock per frame, scales with erosion\\n        originalRockMaterial = max(0.0, originalRockMaterial - conversionRate); // Reduce rock value, convert to soil\\n      }\\n\\n  }else {\\n    float changesedi = (cursedi-sedicap)*Kd;\\n    //changesedi = min(changesedi, curTerrain.y);\\n    \\n    // If sediment is depositing on rock, store the base rock surface height\\n    // Store the height BEFORE deposition as the base surface\\n    if (isRock && baseRockSurfaceHeight < 0.001) {\\n      // Initialize base surface to height before this deposition\\n      baseRockSurfaceHeight = curTerrain.x;\\n    }\\n    \\n    hight = hight + changesedi;\\n    heightChange = changesedi; // Positive = deposition\\n    //water = water - (cursedi-sedicap)*Kd;\\n    outsedi = outsedi - changesedi;\\n  }\\n\\n  // Apply rock material spreading - rock fills in where terrain has eroded\\n  // Only spread when terrain has eroded down to the lowest PAINTED rock that is CONTIGUOUS\\n  // (directly touching/adjacent) to the neighboring terrain sections\\n  // IMPORTANT: Don't spread rock when water is present or flowing to prevent damming\\n  // Start with the eroded rock material value (rock converts to soil when it erodes)\\n  float finalRockMaterial = originalRockMaterial;\\n  float waterLevel = curTerrain.y; // Water height in this cell\\n  float waterVelocity = length(curvel.xy); // Water flow velocity\\n  \\n  // Check if this area is below the water surface by comparing total height (terrain + water)\\n  // to neighboring rock's total height\\n  float currentTotalHeight = hight + waterLevel; // Current terrain + water height\\n  \\n  // Only spread rock if:\\n  // 1. There's little or no water (water < 0.1) AND\\n  // 2. Water is not actively flowing (velocity < 0.5) AND\\n  // 3. Erosion is happening\\n  // 4. The area was NOT recently rock (to prevent converting eroded rock back to rock)\\n  // This prevents rock from creating barriers that dam up water\\n  // IMPORTANT: Don't spread rock into areas that were recently rock - rock should erode to soil and stay soil\\n  bool canSpreadRock = waterLevel < 0.1 && waterVelocity < 0.5;\\n  // wasRecentlyRock is already defined earlier in the function\\n  \\n  if (!isRock && heightChange < 0.0 && canSpreadRock && !wasRecentlyRock) { // Only if erosion is happening AND water conditions allow AND wasn't recently rock\\n    // Sample neighboring cells for rock (these are the contiguous/adjacent cells)\\n    // Use the ORIGINAL terrain height (before this frame's erosion) to find the painted rock edge\\n    vec4 topTerrain = texture(readTerrain, curuv + vec2(0.0, div));\\n    vec4 rightTerrain = texture(readTerrain, curuv + vec2(div, 0.0));\\n    vec4 bottomTerrain = texture(readTerrain, curuv + vec2(0.0, -div));\\n    vec4 leftTerrain = texture(readTerrain, curuv + vec2(-div, 0.0));\\n    \\n    float lowestContiguousRockHeight = 999999.0; // Find the lowest contiguous painted rock edge\\n    float bestRockValue = 0.0;\\n    int contiguousRockCount = 0;\\n    \\n    // Find the lowest PAINTED edge of rock that is CONTIGUOUS (directly adjacent/touching)\\n    // to this terrain cell. Use the ORIGINAL height (curTerrain.x) of rock neighbors,\\n    // not the current height after erosion, to find where rock was originally painted.\\n    if (topTerrain.z > 0.5) {\\n      // This rock neighbor is contiguous - it's directly touching this cell\\n      // Use the rock's original height to find the painted edge\\n      if (topTerrain.x < lowestContiguousRockHeight) {\\n        lowestContiguousRockHeight = topTerrain.x;\\n        bestRockValue = topTerrain.z;\\n      }\\n      contiguousRockCount++;\\n    }\\n    if (rightTerrain.z > 0.5) {\\n      if (rightTerrain.x < lowestContiguousRockHeight) {\\n        lowestContiguousRockHeight = rightTerrain.x;\\n        bestRockValue = rightTerrain.z;\\n      }\\n      contiguousRockCount++;\\n    }\\n    if (bottomTerrain.z > 0.5) {\\n      if (bottomTerrain.x < lowestContiguousRockHeight) {\\n        lowestContiguousRockHeight = bottomTerrain.x;\\n        bestRockValue = bottomTerrain.z;\\n      }\\n      contiguousRockCount++;\\n    }\\n    if (leftTerrain.z > 0.5) {\\n      if (leftTerrain.x < lowestContiguousRockHeight) {\\n        lowestContiguousRockHeight = leftTerrain.x;\\n        bestRockValue = leftTerrain.z;\\n      }\\n      contiguousRockCount++;\\n    }\\n    \\n    // Only spread if:\\n    // 1. There are contiguous rock neighbors (rock sections directly touching this terrain)\\n    // 2. Current cell's ORIGINAL height (before erosion) was above the rock, and\\n    //    has now eroded significantly below the lowest CONTIGUOUS painted rock edge\\n    //    Compare original terrain height to rock height to see if it was originally above\\n    float originalTerrainHeight = curTerrain.x; // Original height before this frame's erosion\\n    \\n    // Only spread if original terrain was above rock and has eroded well below it\\n    if (contiguousRockCount > 0 && originalTerrainHeight > lowestContiguousRockHeight) {\\n      // Calculate how far the CURRENT height is below the lowest contiguous painted edge\\n      float depthBelowContiguousEdge = lowestContiguousRockHeight - hight;\\n      \\n      // Check if this area is below the water surface by comparing total height (terrain + water)\\n      // to neighboring rock's total height - if water would need to flow through here, don't spread rock\\n      float lowestRockTotalHeight = 999999.0;\\n      if (topTerrain.z > 0.5) {\\n        float rockTotalHeight = topTerrain.x + topTerrain.y; // Rock terrain + water\\n        if (rockTotalHeight < lowestRockTotalHeight) lowestRockTotalHeight = rockTotalHeight;\\n      }\\n      if (rightTerrain.z > 0.5) {\\n        float rockTotalHeight = rightTerrain.x + rightTerrain.y;\\n        if (rockTotalHeight < lowestRockTotalHeight) lowestRockTotalHeight = rockTotalHeight;\\n      }\\n      if (bottomTerrain.z > 0.5) {\\n        float rockTotalHeight = bottomTerrain.x + bottomTerrain.y;\\n        if (rockTotalHeight < lowestRockTotalHeight) lowestRockTotalHeight = rockTotalHeight;\\n      }\\n      if (leftTerrain.z > 0.5) {\\n        float rockTotalHeight = leftTerrain.x + leftTerrain.y;\\n        if (rockTotalHeight < lowestRockTotalHeight) lowestRockTotalHeight = rockTotalHeight;\\n      }\\n      \\n      // Don't spread rock if current area's total height (terrain + water) is below or near\\n      // the water surface level of neighboring rock - this would block water flow\\n      bool isBelowWaterSurface = currentTotalHeight < lowestRockTotalHeight + 0.3;\\n      \\n      // Only spread if we're significantly below the painted edge (at least 0.2 units)\\n      // AND not below the water surface (to allow water to flow through)\\n      if (depthBelowContiguousEdge >= 0.2 && !isBelowWaterSurface) {\\n        // Spread amount based on depth below contiguous painted edge and erosion rate\\n        float erosionAmount = abs(heightChange);\\n        \\n        // Very gradual spreading - scales with depth below the contiguous painted edge\\n        // Only count depth beyond the 0.2 threshold\\n        float effectiveDepth = depthBelowContiguousEdge - 0.2;\\n        float depthFactor = clamp(effectiveDepth * 2.0, 0.0, 1.0);\\n        float spreadFactor = min(erosionAmount * 0.5 * (1.0 + depthFactor * 0.2), 0.01); // Max 1% per frame, very slow\\n        \\n        // Calculate how much rock material is being added\\n        float currentRockValue = curTerrain.z;\\n        float newRockValue = max(currentRockValue, mix(currentRockValue, 1.0, spreadFactor));\\n        float rockMaterialAdded = newRockValue - currentRockValue;\\n        \\n        // IMPORTANT: When rock spreads, we must maintain material conservation\\n        // Rock spreading converts existing soil/sediment into rock material\\n        // To prevent creating material out of thin air, we need to:\\n        // 1. Reduce sediment (we're converting sediment into rock)\\n        // 2. Slightly adjust height (rock is denser, but we want to be conservative)\\n        \\n        if (rockMaterialAdded > 0.0) {\\n          // Reduce sediment proportionally to rock material added\\n          // When soil converts to rock, the sediment that was in that soil is consumed\\n          float sedimentConsumed = rockMaterialAdded * outsedi * 0.5; // Consume up to 50% of sediment for rock conversion\\n          outsedi = max(0.0, outsedi - sedimentConsumed);\\n          \\n          // Rock is denser than soil, so converting soil to rock should slightly increase height\\n          // But be very conservative - only small adjustment to prevent material creation\\n          float rockDensityRatio = 1.1; // Rock is 10% denser than soil (conservative)\\n          float heightAdjustment = rockMaterialAdded * effectiveDepth * 0.05 * rockDensityRatio; // Very small adjustment\\n          hight = hight + heightAdjustment;\\n        }\\n        \\n        // Use max to ensure rock value increases (doesn't decrease if already partially rock)\\n        finalRockMaterial = newRockValue;\\n        \\n        // When rock spreads, set the base rock surface height to current height\\n        // This marks where the rock surface is before any future sediment deposition\\n        baseRockSurfaceHeight = hight;\\n      }\\n    }\\n  }\\n  \\n  // If this cell became rock (through spreading), ensure base surface is initialized\\n  if (finalRockMaterial > 0.5 && baseRockSurfaceHeight < 0.001) {\\n    baseRockSurfaceHeight = hight;\\n  }\\n  \\n  writeTerrainNormal = vec4(vec3(abs(slopeSin)),1.f);\\n  writeSediment = vec4(outsedi,0.0f,0.0f,1.0f);\\n  writeTerrain = vec4(hight,curTerrain.y,finalRockMaterial,baseRockSurfaceHeight);\\n  writeVelocity = curvel;\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D vel;\\nuniform sampler2D sedi;\\nuniform sampler2D sediBlend;\\nuniform sampler2D terrain;\\n\\nuniform float u_SimRes;\\nuniform float u_timestep;\\nuniform float unif_advectionSpeedScale;\\nuniform float unif_advectMultiplier;\\n\\n\\nlayout (location = 0) out vec4 writeSediment;\\nlayout (location = 1) out vec4 writeVel;\\nlayout (location = 2) out vec4 writeSediBlend;\\n\\n\\n\\nin vec2 fs_Pos;\\n\\n\\n\\nfloat samplebilinear(vec2 uv, float sampleKernelSize){\\n    vec2 cur_loc = sampleKernelSize*uv;\\n    vec2 uva = floor(cur_loc);\\n    vec2 uvb = ceil(cur_loc);\\n\\n    vec2 id00 = uva;\\n    vec2 id10 = vec2(uvb.x,uva.y);\\n    vec2 id01 = vec2(uva.x,uvb.y);\\n    vec2 id11 = uvb;\\n\\n    vec2 d = cur_loc - uva;\\n\\n    float res =  (texture(sedi,id00/sampleKernelSize).x*(1.f-d.x)*(1.f-d.y)+\\n    texture(sedi,id10/sampleKernelSize).x*d.x*(1.f-d.y)+\\n    texture(sedi,id01/sampleKernelSize).x*(1.f-d.x)*d.y+\\n    texture(sedi,id11/sampleKernelSize).x*d.x*d.y);\\n\\n    return res;\\n}\\n\\n \\n\\n\\nvoid main() {\\n \\n    vec2 curuv = 0.5f*fs_Pos+0.5f;\\n    float div = 1.f/u_SimRes;\\n    float alpha = 1.0;\\n    float velscale = 1.0/1.0;\\n\\n    vec4 curvel = (texture(vel,curuv));\\n    vec4 cursedi = texture(sedi,curuv);\\n    vec4 curterrain = texture(terrain,curuv);\\n\\n\\n\\n    vec4 useVel = curvel/u_SimRes;\\n    useVel *= unif_advectMultiplier * 0.5;\\n\\n\\n\\n    vec2 oldloc = vec2(curuv.x-useVel.x*u_timestep,curuv.y-useVel.y*u_timestep);\\n    float oldsedi = texture(sedi, oldloc).x;\\n    //oldsedi = samplebilinear(oldloc,u_SimRes   );\\n\\n    float curSediVal = cursedi.x * curterrain.y * 0.1;\\n\\n    float sediBlendVal = texture(sediBlend, curuv).x;\\n\\n\\n    sediBlendVal = (sediBlendVal*1660.0 + curSediVal) / 1661.0;\\n\\n\\n    writeSediment = vec4(oldsedi, 0.0, 0.0, 1.0);\\n    writeVel = curvel;\\n    writeSediBlend = vec4(sediBlendVal, 0.0, 0.0, 1.0);\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D vel;\\nuniform sampler2D sedi;\\nuniform sampler2D sediadvecta;\\nuniform sampler2D sediadvectb;\\n\\nuniform float u_SimRes;\\nuniform float u_timestep;\\nuniform float unif_advectionSpeedScale;\\n\\n\\nlayout (location = 0) out vec4 writeSediment;\\n\\n\\n\\n\\nin vec2 fs_Pos;\\n\\n\\nvoid main() {\\n \\n    vec2 curuv = 0.5f*fs_Pos+0.5f;\\n    float div = 1.f/u_SimRes;\\n    float alpha = 1.0;\\n    float velscale = 1.0/1.0;\\n\\n    vec4 curvel = (texture(vel,curuv));\\n    vec4 cursedi = texture(sedi,curuv);\\n\\n    vec2 targetPos = curuv * u_SimRes - u_timestep * curvel.xy;\\n\\n    vec4 st;\\n    st.xy = floor(targetPos - 0.5) + 0.5;\\n    st.zw = st.xy + 1.0;\\n\\n    float nodeVal[4];\\n    nodeVal[0] = texture(sedi, st.xy/u_SimRes).x;\\n    nodeVal[1] = texture(sedi, st.zy/u_SimRes).x;\\n    nodeVal[2] = texture(sedi, st.xw/u_SimRes).x;\\n    nodeVal[3] = texture(sedi, st.zw/u_SimRes).x;\\n\\n    float clampMin = min(min(min(nodeVal[0],nodeVal[1]),nodeVal[2]),nodeVal[3]);\\n    float clampMax = max(max(max(nodeVal[0],nodeVal[1]),nodeVal[2]),nodeVal[3]);\\n\\n    float sediment = texture(sedi,curuv).x;\\n\\n\\n    float res = texture(sediadvecta,curuv).x + 0.5 * (sediment - texture(sediadvectb,curuv).x);\\n\\n    sediment = max(min(res,clampMax), clampMin);\\n\\n\\n\\n//    vec4 useVel = curvel/u_SimRes;\\n//    useVel *= unif_advectionSpeedScale;\\n//\\n//\\n//\\n//    vec2 oldloc = vec2(curuv.x-useVel.x*velscale*u_timestep,curuv.y-useVel.y*velscale*u_timestep);\\n//    float oldsedi = texture(sedi, oldloc).x;\\n\\n\\n\\n    writeSediment = vec4(sediment, 0.0, 0.0, 1.0);\\n\\n\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readTerrain;\\n\\nuniform float u_Time;\\nuniform float raindeg;\\nuniform float u_SimRes; // Simulation resolution for neighbor sampling\\n\\nuniform vec4 u_MouseWorldPos;\\nuniform vec3 u_MouseWorldDir;\\nuniform float u_BrushSize;\\nuniform float u_BrushStrength;\\nuniform int u_BrushType;\\nuniform int u_BrushPressed;\\nuniform vec2 u_BrushPos;\\nuniform int u_BrushOperation;\\nuniform int u_RainErosion;\\nuniform float u_RainErosionStrength;\\nuniform float u_RainErosionDropSize;\\nuniform float u_FlattenTargetHeight; // Target height for flatten brush (will be set from center)\\nuniform vec2 u_SlopeStartPos; // Start position for slope brush\\nuniform vec2 u_SlopeEndPos; // End position for slope brush\\nuniform int u_SlopeActive; // 0 = not active, 1 = start set, 2 = end set\\n\\nuniform int u_SourceCount;\\nuniform vec2 u_SourcePositions[16];  // Max 16 sources\\nuniform float u_SourceSizes[16];\\nuniform float u_SourceStrengths[16];\\n\\nlayout (location = 0) out vec4 writeTerrain;\\n\\n#define OCTAVES 6\\n\\nfloat random (in vec2 st) {\\n      return fract(sin(dot(st.xy,\\n      vec2(12.9898,78.233)))*\\n      43758.5453123);\\n}\\n\\n\\nfloat noise (in vec2 st) {\\n      vec2 i = floor(st);\\n      vec2 f = fract(st);\\n\\n      // Four corners in 2D of a tile\\n      float a = random(i);\\n      float b = random(i + vec2(1.0, 0.0));\\n      float c = random(i + vec2(0.0, 1.0));\\n      float d = random(i + vec2(1.0, 1.0));\\n\\n      vec2 u = f * f * (3.0 - 2.0 * f);\\n\\n      return mix(a, b, u.x) +\\n      (c - a)* u.y * (1.0 - u.x) +\\n      (d - b) * u.x * u.y;\\n}\\n\\n\\nfloat fbm (in vec2 st) {\\n      // Initial values\\n      float value = 0.0;\\n      float amplitude = .5;\\n      float frequency = 0.;\\n      //\\n      // Loop of octaves\\n      for (int i = 0; i < OCTAVES; i++) {\\n            value += amplitude * noise(st);//iqnoise(st,1.f,1.f);\\n            st *= 2.0;\\n            amplitude *= .53;\\n      }\\n      return value;\\n}\\n\\n\\n//generic noise from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\\n\\nfloat noise(vec3 p){\\n      vec3 a = floor(p);\\n      vec3 d = p - a;\\n      d = d * d * (3.0 - 2.0 * d);\\n\\n      vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\\n      vec4 k1 = perm(b.xyxy);\\n      vec4 k2 = perm(k1.xyxy + b.zzww);\\n\\n      vec4 c = k2 + a.zzzz;\\n      vec4 k3 = perm(c);\\n      vec4 k4 = perm(c + 1.0);\\n\\n      vec4 o1 = fract(k3 * (1.0 / 41.0));\\n      vec4 o2 = fract(k4 * (1.0 / 41.0));\\n\\n      vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\\n      vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\\n\\n      return o4.y * d.y + o4.x * (1.0 - d.y);\\n}\\n\\n//float random (in vec2 st) {\\n//      return fract(sin(dot(st.xy,\\n//      vec2(12.9898,78.233)))*\\n//      43758.5453123);\\n//}\\n\\nin vec2 fs_Pos;\\n\\n\\nstruct BrushTmp{\\n      float bStrength;\\n      float bSize;\\n      vec2 bPos;\\n};\\n\\nvoid main() {\\n\\n      vec2 curuv = 0.5f*fs_Pos+0.5f;\\n      vec3 sand = vec3(214.f/255.f,164.f/255.f,96.f/255.f);\\n      vec3 watercol = vec3(0.1,0.3,0.8);\\n\\n\\n      float addterrain = 0.0;\\n      float addwater = 0.0;\\n      float amount = 0.0006 * u_BrushStrength;\\n      float aw = fbm(curuv*10.0 + vec2(sin(u_Time * 35.0), cos(u_Time*115.0)));\\n      float div = 1.0 / u_SimRes; // Pixel size in UV space\\n      \\n      // Read current terrain\\n      vec4 cur = texture(readTerrain, curuv);\\n      float currentHeight = cur.x;\\n      \\n      // normal water brush\\n      // Early exit: only do brush calculations if brush is active AND pressed\\n      // This avoids expensive distance calculations when not brushing\\n      if(u_BrushType != 0 && u_BrushPressed == 1){\\n            vec3 ro = u_MouseWorldPos.xyz;\\n            vec3 rd = u_MouseWorldDir;\\n            vec2 pointOnPlane = u_BrushPos;\\n            float pdis2fragment = distance(pointOnPlane, curuv);\\n            if (pdis2fragment < 0.01 * u_BrushSize){\\n                  float dens = (0.01 * u_BrushSize - pdis2fragment * 0.5) / (0.01 * u_BrushSize);\\n                  dens = max(0.0, dens); // Clamp density\\n\\n                  if(u_BrushType == 1){\\n                        // Shift Terrain - Elevate with primary button, lower with secondary (Alt+brush)\\n                        // u_BrushOperation: 0 = primary (elevate), 1 = secondary (lower)\\n                        addterrain =  amount * 1.0 * 280.0;\\n                        addterrain = u_BrushOperation == 0 ? addterrain : -addterrain;\\n                  }else if(u_BrushType == 2){\\n                        // Water brush\\n                        addwater =  amount * dens * 200.0;\\n                        addwater *= aw;\\n                        addwater = u_BrushOperation == 0 ? addwater : -addwater;\\n                  }else if(u_BrushType == 3){\\n                        // Rock brush - will be handled in output to set B channel\\n                  }else if(u_BrushType == 4){\\n                        // Soften Terrain - gentle smoothing (primary button only)\\n                        if (u_BrushOperation == 0) {\\n                              vec4 top = texture(readTerrain, curuv + vec2(0.0, div));\\n                              vec4 right = texture(readTerrain, curuv + vec2(div, 0.0));\\n                              vec4 bottom = texture(readTerrain, curuv + vec2(0.0, -div));\\n                              vec4 left = texture(readTerrain, curuv + vec2(-div, 0.0));\\n                              \\n                              float avgHeight = (top.x + right.x + bottom.x + left.x) / 4.0;\\n                              float smoothAmount = dens * u_BrushStrength * 0.1; // Smoothing strength\\n                              addterrain = (avgHeight - currentHeight) * smoothAmount;\\n                        }\\n                  }else if(u_BrushType == 5){\\n                        // Flatten Terrain - secondary button (Alt) sets target, primary flattens\\n                        // Only flatten when primary button is pressed (brushOperation == 0)\\n                        // Alt+click (brushOperation == 1) should NOT flatten, just set target in JS\\n                        if (u_BrushOperation == 0) {\\n                              // Primary button: flatten to target height\\n                              float targetHeight = u_FlattenTargetHeight;\\n                              float flattenAmount = dens * u_BrushStrength * 0.2; // Flattening strength\\n                              addterrain = (targetHeight - currentHeight) * flattenAmount;\\n                        }\\n                        // When Alt is pressed (brushOperation == 1), don't do anything - JS will set target\\n                  }else if(u_BrushType == 6){\\n                        // Slope Terrain - click sets end point, Alt+click sets start point\\n                        // Once both points are set (u_SlopeActive == 2), create slope between them\\n                        // Only apply when brush is pressed AND near the slope line\\n                        if (u_SlopeActive == 2) {\\n                              // Both points are set - create slope from start to end\\n                              vec2 slopeDir = u_SlopeEndPos - u_SlopeStartPos;\\n                              float slopeLength = length(slopeDir);\\n                              \\n                              if (slopeLength > 0.001) {\\n                                    // Normalize direction\\n                                    vec2 slopeDirNorm = normalize(slopeDir);\\n                                    \\n                                    // Project brush position onto the slope line to see where we are along it\\n                                    vec2 brushToStart = u_BrushPos - u_SlopeStartPos;\\n                                    float brushProjDist = dot(brushToStart, slopeDirNorm);\\n                                    \\n                                    // Project current fragment position onto the slope line\\n                                    vec2 toCurrent = curuv - u_SlopeStartPos;\\n                                    float projDist = dot(toCurrent, slopeDirNorm);\\n                                    \\n                                    // Get heights at start and end points\\n                                    vec4 startTerrain = texture(readTerrain, u_SlopeStartPos);\\n                                    vec4 endTerrain = texture(readTerrain, u_SlopeEndPos);\\n                                    float startHeight = startTerrain.x;\\n                                    float endHeight = endTerrain.x;\\n                                    \\n                                    // Calculate target height based on position along slope\\n                                    float t = clamp(projDist / slopeLength, 0.0, 1.0);\\n                                    float targetHeight = mix(startHeight, endHeight, t);\\n                                    \\n                                    // Check if current fragment is within brush radius of the brush position\\n                                    float distToBrush = distance(curuv, u_BrushPos);\\n                                    float brushRadius = 0.01 * u_BrushSize;\\n                                    \\n                                    // Only apply slope when fragment is within brush radius\\n                                    if (distToBrush < brushRadius) {\\n                                          // Calculate density based on distance from brush center\\n                                          float dens = (brushRadius - distToBrush) / brushRadius;\\n                                          dens = max(0.0, dens);\\n                                          \\n                                          // Apply slope with moderate strength - lower than before to avoid over-correction\\n                                          float slopeAmount = dens * u_BrushStrength * 0.3;\\n                                          addterrain = (targetHeight - currentHeight) * slopeAmount;\\n                                    }\\n                              }\\n                        }\\n                  }\\n\\n            }\\n\\n      }\\n\\n      // rain erosion\\n      if(u_RainErosion == 1 && mod(u_Time, 5.0) == 1.0 ){\\n            float smallradius = 0.025  * u_RainErosionDropSize;\\n            float rdx = random(vec2(30.0, cos(u_Time)));\\n            float rdy = random(vec2(u_Time, 10.0));\\n            float rdr = random(vec2(20.0,u_Time * 10.0));\\n\\n            float str = 1.0;\\n            if(mod(u_Time, 20.0) == 1.0) str = 9.0;\\n\\n            float dis2small = distance(vec2(rdx, rdy), curuv);\\n            if (dis2small < smallradius ){\\n                  addwater +=  0.06 * u_RainErosionStrength* (1.0 + 5.0 * rdr);\\n            }\\n\\n\\n\\n      }\\n\\n//                  if(mod(u_Time, 10.0) == 1.0)\\n//                  addwater += 0.006 * aw;\\n\\n\\n      // permanent water source brush - handle multiple sources\\n      for(int i = 0; i < u_SourceCount; i++){\\n            vec2 pointOnPlane = u_SourcePositions[i];\\n            float pdis2fragment = distance(pointOnPlane, curuv);\\n            float sourceSize = u_SourceSizes[i];\\n            float sourceStrength = u_SourceStrengths[i];\\n            \\n            if (pdis2fragment < 0.01 * sourceSize){\\n                  float dens = (0.01 * sourceSize - pdis2fragment) / (0.01 * sourceSize);\\n                  float sourceAmount = 0.0006 * sourceStrength;\\n                  float sourceWater = sourceAmount * dens * 280.0;\\n                  float aw = fbm(curuv*200.0 + vec2(sin(u_Time * 5.0), cos(u_Time*15.0)));\\n                  sourceWater *= aw;\\n                  addwater += sourceWater;\\n            }\\n      }\\n\\n\\n\\n\\n\\n\\n      // cur already declared at top of main()\\n      float rain = raindeg;\\n\\n\\n\\n      float epsilon = 0.000001f;\\n\\n\\n      float nrain = noise(vec3(curuv * 100.0, u_Time));\\n      nrain = fbm(curuv*1.0 + vec2(sin(u_Time * 5.0), cos(u_Time*15.0)));\\n\\n      rain = nrain/100.0;\\n\\n//      if(mod(u_Time, 10.0) <= 1.0){\\n//            rain = 0.0f;\\n//            addwater = 0.0f;\\n//      }\\n\\n      //if(mod(u_Time,100.0)!=9.0)\\n      rain = 0.0f;\\n\\n      epsilon = 0.0f;\\n//      if(curuv.x<maxx && curuv.x>minx && curuv.y<maxy&&curuv.y>miny){\\n//            rain += 0.001;\\n//      }\\n//      else{\\n//            rain = raindeg;\\n//      }\\n\\n\\n      // Handle rock material placement (store in B channel: 1.0 = rock, 0.0 = normal terrain)\\n      float rockMaterial = cur.z;\\n      float baseRockSurfaceHeight = cur.w; // A channel stores base rock surface height\\n      \\n      // Check for rock brush - handle it separately since it modifies the B channel\\n      // Early exit: only do brush calculations if brush is active AND pressed\\n      if(u_BrushType == 3 && u_BrushPressed == 1){\\n            vec2 pointOnPlane = u_BrushPos;\\n            float pdis2fragment = distance(pointOnPlane, curuv);\\n            if (pdis2fragment < 0.01 * u_BrushSize){\\n                  float dens = (0.01 * u_BrushSize - pdis2fragment * 0.5) / (0.01 * u_BrushSize);\\n                  // Use a much stronger mix factor for rock placement - make it clearly visible\\n                  // Clamp dens to ensure it's positive and meaningful\\n                  dens = max(0.0, dens);\\n                  float mixFactor = dens * u_BrushStrength * 2.0; // Strong multiplier for immediate effect\\n                  mixFactor = min(mixFactor, 1.0); // Clamp to 1.0\\n                  if(u_BrushOperation == 0){\\n                        // Add rock material - use max to ensure it increases\\n                        float oldRockMaterial = rockMaterial;\\n                        rockMaterial = max(rockMaterial, mix(rockMaterial, 1.0, mixFactor));\\n                        \\n                        // If we're placing rock (and rock material is significant), reset base rock surface height\\n                        // This makes the new rock surface the base, even if there was sediment on top\\n                        // Reset whenever we're painting rock, not just when it increases (handles already-high rock)\\n                        if(rockMaterial > 0.5 && mixFactor > 0.01){\\n                              // Calculate final height after terrain modifications\\n                              float finalHeight = min(max(cur.x + addterrain, -0.10),2000.30);\\n                              // Reset base rock surface to current height - new rock becomes the base\\n                              baseRockSurfaceHeight = finalHeight;\\n                        }\\n                  } else {\\n                        // Remove rock material - use min to ensure it decreases\\n                        rockMaterial = min(rockMaterial, mix(rockMaterial, 0.0, mixFactor));\\n                        // If rock is removed, clear the base rock surface height\\n                        if(rockMaterial < 0.1){\\n                              baseRockSurfaceHeight = 0.0;\\n                        }\\n                  }\\n            }\\n      }\\n      \\n      writeTerrain = vec4(min(max(cur.x + addterrain, -0.10),2000.30),max(cur.y+rain * raindeg + addwater, 0.0f),rockMaterial,baseRockSurfaceHeight);\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D terrain;\\nuniform float evapod;\\n\\nlayout (location = 0) out vec4 writeTerrain;\\n\\n\\nin vec2 fs_Pos;\\n\\n\\nfloat timestep = 0.0001;\\n\\n\\nvoid main() {\\n      float Ke = 0.4;\\n      vec2 curuv = 0.5f*fs_Pos+0.5f;\\n      vec4 cur = texture(terrain,curuv);\\n      float eva = 1.f-evapod;\\n      writeTerrain = vec4(cur.x,cur.y*eva,cur.z,cur.w);\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readTerrain;\\nuniform sampler2D readSedi;\\n\\n// this render pass was used soley for smoothing sharp ridges & ravines which would potentially introduce corruption\\n// thanks to the references https://github.com/Huw-man/Interactive-Erosion-Simulator-on-GPU & https://github.com/karhu/terrain-erosion\\n\\nlayout (location = 0) out vec4 writeTerrain;\\nlayout (location = 1) out vec4 writeAvg;\\n\\nuniform float u_SimRes;\\nuniform int unif_ErosionMode;\\nuniform int unif_rainMode;\\nin vec2 fs_Pos;\\n\\n\\nvec3 calnor(vec2 uv){\\n    float eps = 1.f/u_SimRes;\\n    vec4 cur = texture(readTerrain,uv);\\n    vec4 r = texture(readTerrain,uv+vec2(eps,0.f));\\n    vec4 t = texture(readTerrain,uv+vec2(0.f,eps));\\n    vec4 b = texture(readTerrain,uv+vec2(0.f,-eps));\\n    vec4 l = texture(readTerrain,uv+vec2(-eps,0.f));\\n\\n    vec3 nor = vec3(l.x - r.x, 2.0, t.x - b.x);\\n    nor = -normalize(nor);\\n    return nor;\\n}\\n\\nvoid main() {\\n\\n    float diagonalWeight = 0.707;\\n    float threathhold = 0.1f;\\n    //if(unif_rainMode == 1) threathhold = 5.0;\\n    float div = 1.0/u_SimRes;\\n    vec2 curuv = 0.5f*fs_Pos+0.5f;\\n    vec4 cur = texture(readTerrain,curuv);\\n    //float curs = texture(readSedi,curuv).x;\\n    //threathhold = clamp(curs * 2.0, 0.1, 2.0);\\n    vec3 nor = calnor(curuv);\\n    //float dval = abs(dot(nor, vec3(0.0, 1.0, 0.0)));\\n    //threathhold *= dval;\\n\\n    vec4 top = texture(readTerrain,curuv+vec2(0.f,div));\\n    vec4 topright = texture(readTerrain,curuv+vec2(div,div));\\n    vec4 right = texture(readTerrain,curuv+vec2(div,0.f));\\n    vec4 bottomright = texture(readTerrain,curuv+vec2(div,-div));\\n    vec4 bottom = texture(readTerrain,curuv+vec2(0.f,-div));\\n    vec4 bottomleft = texture(readTerrain,curuv+vec2(-div,-div));\\n    vec4 left = texture(readTerrain,curuv+vec2(-div,0.f));\\n    vec4 topleft = texture(readTerrain,curuv+vec2(-div,div));\\n\\n    float t_d = cur.x - top.x;\\n    float r_d = cur.x - right.x;\\n    float b_d = cur.x - bottom.x;\\n    float l_d = cur.x - left.x;\\n    float tr_d = cur.x - topright.x;\\n    float br_d = cur.x - bottomright.x;\\n    float bl_d = cur.x - bottomleft.x;\\n    float tl_d = cur.x - topleft.x;\\n\\n\\n\\n    float avg_hdiff = t_d + r_d + b_d + l_d + (tr_d + br_d + bl_d + tl_d) * diagonalWeight;\\n    avg_hdiff/=(4.0 * (1.0 + diagonalWeight));\\n    avg_hdiff = abs(avg_hdiff);\\n\\n    float avg_hdiff_4 = t_d + r_d + b_d + l_d;\\n    avg_hdiff_4/=4.0;\\n    avg_hdiff_4 = abs(avg_hdiff_4);\\n    // for mountain erosion mode, will create flatter plains and sharper ridges, but will lose detail in flatter regeion\\n    if(unif_ErosionMode == 1){\\n        threathhold = avg_hdiff / 2.0;\\n    }\\n    // for polygonal looking terrain\\n    else if(unif_ErosionMode == 2){\\n        threathhold = pow(avg_hdiff,3.0);\\n    }\\n    float cur_h = cur.x;\\n    float col = 0.0;\\n    float curWeight = 8.0;\\n\\n\\n    //eight dir average\\n    if(((abs(r_d) > threathhold && abs(l_d) > threathhold)&& r_d*l_d > 0.0)||\\n    ((abs(t_d) > threathhold && abs(b_d) > threathhold) && t_d * b_d > 0.0)||\\n    ((abs(tr_d) > threathhold && abs(bl_d) > threathhold) && tr_d * bl_d > 0.0)||\\n    ((abs(tl_d) > threathhold && abs(br_d) > threathhold) && tl_d * br_d > 0.0)){\\n        cur_h = (cur.x * curWeight + top.x + right.x + bottom.x + left.x + topright.x * diagonalWeight + topleft.x * diagonalWeight + bottomleft.x * diagonalWeight + bottomright.x * diagonalWeight)/(4.0 * (1.0 + diagonalWeight) + curWeight);\\n        col = 1.0;\\n    }\\n\\n//    //four diagnal dirs\\n//    if(((abs(tr_d) > threathhold && abs(bl_d) > threathhold) && tr_d * bl_d > 0.0)||\\n//    ((abs(tl_d) > threathhold && abs(br_d) > threathhold) && tl_d * br_d > 0.0)){\\n//        cur_h = (cur.x * curWeight + topright.x * diagonalWeight + topleft.x * diagonalWeight + bottomleft.x * diagonalWeight + bottomright.x * diagonalWeight)/(4.0 * ( diagonalWeight) + curWeight);\\n//        col = 1.0;\\n//    }\\n    //four dir average\\n//    if(((pow(abs(r_d),1.0) > threathhold || pow(abs(l_d),1.0) > threathhold)&& r_d*l_d > 0.0)||\\n//    ((pow(abs(t_d),1.0) > threathhold || pow(abs(b_d),1.0) > threathhold) && t_d * b_d > 0.0)){\\n//        cur_h = (cur.x * curWeight + top.x + right.x + bottom.x + left.x )/(4.0+curWeight);\\n//        col = 1.0;\\n//    }else{\\n//        col = 0.0;\\n//    }\\n\\n    //four dir average\\n//    if(((pow(abs(r_d),1.0) > threathhold && pow(abs(l_d),1.0) > threathhold)&& r_d*l_d > 0.0)||\\n//    ((pow(abs(t_d),1.0) > threathhold && pow(abs(b_d),1.0) > threathhold) && t_d * b_d > 0.0)){\\n//        cur_h = (cur.x * curWeight + top.x + right.x + bottom.x + left.x )/(4.0+curWeight);\\n//        col = 1.0;\\n//    }\\n\\n\\n//    threathhold = 0.1;\\n//    if((abs(r_d) > threathhold) && (abs(l_d) > threathhold) && (abs(b_d) > threathhold) && (abs(t_d) > threathhold) && ((l_d > 0.0 && b_d > 0.0&& t_d > 0.0 && r_d > 0.0) || (l_d < 0.0 && b_d < 0.0&& t_d < 0.0 && r_d < 0.0))){\\n//                cur_h = (cur.x * curWeight + top.x + right.x + bottom.x + left.x )/(4.0+curWeight);\\n//                col = 1.0;\\n//    }\\n\\n    writeTerrain = vec4(cur_h,cur.y,cur.z,cur.w);\\n    writeAvg = vec4(vec3(col), 1.0);\\n}\"","export default \"#version 300 es\\nprecision highp float;\\nlayout (location = 0) out vec4 writeTerrain;\\n\\nvoid main() {\\n\\n      writeTerrain = vec4(0.0, 0.0, 0.0, 0.0);\\n}\"","export default \"#version 300 es\\n\\n\\nuniform mat4 u_Model;\\nuniform mat4 u_ModelInvTr;\\nuniform mat4 u_ViewProj;\\nuniform vec2 u_PlanePos; // Our location in the virtual world displayed by the plane\\n\\nuniform sampler2D hightmap;\\nuniform sampler2D sedimap;\\nuniform float u_SimRes;\\n\\nin vec4 vs_Pos;\\nin vec4 vs_Nor;\\nin vec4 vs_Col;\\nin vec2 vs_Uv;\\n\\nout vec3 fs_Pos;\\nout vec4 fs_Nor;\\nout vec4 fs_Col;\\n\\nout vec2 fs_Uv;\\n\\n\\n\\nvoid main()\\n{\\n\\n  fs_Uv = vs_Uv;\\n  float sval = 1.f*texture(sedimap,vs_Uv).x;\\n  float yval = 1.f*texture(hightmap,vs_Uv).x;\\n  float wval = 1.f*texture(hightmap,vs_Uv).y;\\n  vec4 modelposition = vec4(vs_Pos.x, (yval + sval + wval)/u_SimRes, vs_Pos.z, 1.0);\\n  fs_Pos = modelposition.xyz;\\n\\n\\n  modelposition = u_Model * modelposition;\\n  gl_Position = u_ViewProj * modelposition;\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform vec2 u_PlanePos; // Our location in the virtual world displayed by the plane\\n\\nin vec3 fs_Pos;\\nin vec4 fs_Nor;\\nin vec4 fs_Col;\\n\\nuniform sampler2D hightmap;\\nuniform sampler2D normap;\\nuniform sampler2D sceneDepth;\\nuniform sampler2D colorReflection;\\nuniform sampler2D sedimap;\\n\\nin float fs_Sine;\\nin vec2 fs_Uv;\\nlayout (location = 0) out vec4 out_Col; // This is the final output color that you will see on your\\nlayout (location = 1) out vec4 col_reflect;\\n                  // screen for the pixel that is currently being processed.\\nuniform vec3 u_Eye, u_Ref, u_Up;\\n\\n\\nuniform int u_TerrainType;\\nuniform float u_WaterTransparency;\\nuniform float u_SimRes;\\nuniform vec2 u_Dimensions;\\nuniform vec3 unif_LightPos;\\nuniform float u_far;\\nuniform float u_near;\\n\\nvec3 calnor(vec2 uv){\\n    float eps = 1.0/u_SimRes;\\n    vec4 cur = texture(hightmap,uv);\\n    vec4 r = texture(hightmap,uv+vec2(eps,0.f));\\n    vec4 t = texture(hightmap,uv+vec2(0.f,eps));\\n\\n    vec3 n1 = normalize(vec3(-1.0, cur.y + cur.x - r.y - r.x, 0.f));\\n    vec3 n2 = normalize(vec3(-1.0, t.x + t.y - r.y - r.x, 1.0));\\n\\n    vec3 nor = -cross(n1,n2);\\n    nor = normalize(nor);\\n    return nor;\\n}\\n\\nvec3 sky(in vec3 rd){\\n    return mix(vec3(0.6,0.6,0.6),vec3(0.3,0.5,0.9),clamp(rd.y,0.f,1.f));\\n}\\n\\nfloat linearDepth(float depthSample)\\n{\\n    depthSample = 2.0 * depthSample - 1.0;\\n    float zLinear = 2.0 * u_near * u_far / (u_far + u_near - depthSample * (u_far - u_near));\\n    return zLinear;\\n}\\n\\nvoid main()\\n{\\n\\n    vec2 uv = vec2(gl_FragCoord.xy/u_Dimensions);\\n    float terrainDepth = texture(sceneDepth,uv).x;\\n    float sediment = texture(sedimap,fs_Uv).x;\\n    float waterDepth = gl_FragCoord.z;\\n\\n    terrainDepth = linearDepth(terrainDepth);\\n    waterDepth = linearDepth(waterDepth);\\n\\n    float dpVal = 180.0 * max(0.0,terrainDepth - waterDepth);\\n    dpVal = clamp(dpVal, 0.0,4.0);\\n    //dpVal = pow(dpVal, 0.1);\\n\\n    dpVal = 1.0 - exp(-dpVal * 1.0);\\n\\n\\n    float fbias = 0.2;\\n    float fscale = 0.2;\\n    float fpow = 22.0;\\n    vec3 sundir = unif_LightPos;\\n\\n    sundir = normalize(sundir);\\n\\n    vec3 nor = -calnor(fs_Uv);\\n    vec3 viewdir = normalize(u_Eye - fs_Pos);\\n    vec3 lightdir = normalize(sundir);\\n    vec3 halfway = normalize(lightdir + viewdir);\\n    vec3 reflectedSky = sky(halfway);\\n    float spec = pow(max(dot(nor, halfway), 0.0), 333.0);\\n\\n\\n    float R = max(0.0, min(1.0, fbias + fscale * pow(1.0 + dot(viewdir, -nor), fpow)));\\n\\n    //lamb =1.f;\\n\\n    float wval = texture(hightmap,fs_Uv).y;\\n    wval /= 1.0;\\n\\n    // Check if underlying terrain is rock (B channel > 0.1)\\n    vec4 terrainSample = texture(hightmap, fs_Uv);\\n    float rockVal = terrainSample.z;\\n    bool isRock = rockVal > 0.1;\\n\\n    vec3 watercolor = mix(vec3(0.8,0.0,0.0), vec3(0.0,0.0,0.8), sediment * 2.0);\\n    vec3 watercolorspec = vec3(1.0);\\n    watercolorspec *= spec;\\n\\n    // Base water color - make it brighter on rock for better visibility\\n    vec3 baseWaterColor = vec3(0.0, 0.3, 0.5);\\n    if (isRock) {\\n        // Make water brighter and more saturated on rock for better contrast\\n        // Rock is dark, so water should be lighter to stand out\\n        baseWaterColor = mix(baseWaterColor, vec3(0.2, 0.5, 0.8), 0.5); // Brighter blue on rock\\n    }\\n\\n    out_Col = vec4(baseWaterColor + R * reflectedSky + watercolorspec  , min((1.8 + spec) * u_WaterTransparency * dpVal,1.0));\\n    col_reflect = vec4(1.0);\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readTerrain;//water and hight map R: hight map, G: water map, B: , A:\\nuniform sampler2D readMaxSlippage;\\n\\nuniform float u_SimRes;\\nuniform float u_PipeLen;\\nuniform float u_timestep;\\nuniform float u_PipeArea;\\n\\n\\nuniform float unif_thermalRate;\\n\\n\\nlayout (location = 0) out vec4 writeFlux;\\n\\nin vec2 fs_Pos;\\n\\n\\n\\n//\\n//      x\\n//  w   c   y\\n//      z\\n//\\n\\n\\nvoid main() {\\n\\n  vec2 curuv = 0.5f*fs_Pos+0.5f;\\n  float div = 1.0 / u_SimRes;\\n  float thermalRate = unif_thermalRate;\\n  float hardness = 1.0;\\n\\n\\n\\n  vec4 terraintop = texture(readTerrain,curuv+vec2(0.f,div));\\n  vec4 terrainright = texture(readTerrain,curuv+vec2(div,0.f));\\n  vec4 terrainbottom = texture(readTerrain,curuv+vec2(0.f,-div));\\n  vec4 terrainleft = texture(readTerrain,curuv+vec2(-div,0.f));\\n  vec4 terraincur = texture(readTerrain,curuv);\\n\\n  float slippagetop = texture(readMaxSlippage,curuv+vec2(0.f,div)).x;\\n  float slippageright = texture(readMaxSlippage,curuv+vec2(div,0.f)).x;\\n  float slippagebottom = texture(readMaxSlippage,curuv+vec2(0.f,-div)).x;\\n  float slippageleft = texture(readMaxSlippage,curuv+vec2(-div,0.f)).x;\\n  float slippagecur = texture(readMaxSlippage,curuv).x;\\n\\n  vec4 diff;\\n  diff.x = terraincur.x - terraintop.x - (slippagecur + slippagetop) * 0.5;\\n  diff.y = terraincur.x - terrainright.x - (slippagecur + slippageright) * 0.5;\\n  diff.z = terraincur.x - terrainbottom.x - (slippagecur + slippagebottom) * 0.5;\\n  diff.w = terraincur.x - terrainleft.x - (slippagecur + slippageleft) * 0.5;\\n\\n  diff = max(vec4(0.0), diff);\\n\\n  vec4 newFlow = diff * 1.2;\\n\\n  float outfactor = (newFlow.x + newFlow.y + newFlow.z + newFlow.w)*u_timestep;\\n\\n  if(outfactor>1e-5){\\n    outfactor = terraincur.x / outfactor;\\n    if(outfactor > 1.0) outfactor = 1.0;\\n    newFlow = newFlow * outfactor;\\n  }\\n\\n\\n  vec4 outputflux = newFlow;\\n  writeFlux = outputflux;\\n\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readTerrainFlux;//water and hight map R: hight map, G: water map, B: , A:\\nuniform sampler2D readTerrain;\\n\\nuniform float u_SimRes;\\nuniform float u_PipeLen;\\nuniform float u_timestep;\\nuniform float u_PipeArea;\\nuniform float unif_thermalErosionScale;\\n\\nlayout (location = 0) out vec4 writeTerrain;\\n\\nin vec2 fs_Pos;\\n\\n\\n\\n//\\n//      x\\n//  w   c   y\\n//      z\\n//\\n\\n\\nvoid main() {\\n\\n  vec2 curuv = 0.5f*fs_Pos+0.5f;\\n  float div = 1.f/u_SimRes;\\n  float thermalErosionScale = unif_thermalErosionScale;\\n\\n  vec4 topflux = texture(readTerrainFlux,curuv+vec2(0.f,div));\\n  vec4 rightflux = texture(readTerrainFlux,curuv+vec2(div,0.f));\\n  vec4 bottomflux = texture(readTerrainFlux,curuv+vec2(0.f,-div));\\n  vec4 leftflux = texture(readTerrainFlux,curuv+vec2(-div,0.f));\\n\\n  vec4 inputflux = vec4(topflux.z,rightflux.w,bottomflux.x,leftflux.y);\\n  vec4 outputflux = texture(readTerrainFlux,curuv);\\n\\n  float vol = inputflux.x + inputflux.y + inputflux.z + inputflux.w - outputflux.x - outputflux.y - outputflux.z - outputflux.w;\\n\\n  float tdelta = min(50.0, u_timestep * thermalErosionScale) * vol;\\n\\n  vec4 curTerrain = texture(readTerrain, curuv);\\n\\n  //writeTerrain = vec4(curTerrain.x ,curTerrain.y,curTerrain.z,curTerrain.w);\\n  writeTerrain = vec4(curTerrain.x  + tdelta,curTerrain.y,curTerrain.z,curTerrain.w);\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readTerrain;//water and hight map R: hight map, G: water map, B: , A:\\n\\n\\nuniform float u_SimRes;\\nuniform float u_PipeLen;\\nuniform float u_timestep;\\nuniform float u_PipeArea;\\nuniform float unif_thermalErosionScale;\\nuniform float unif_TalusScale;\\nuniform int unif_rainMode;\\n\\nlayout (location = 0) out vec4 writeMaxslippage;\\n\\nin vec2 fs_Pos;\\n\\n\\n\\n//\\n//      x\\n//  w   c   y\\n//      z\\n//\\n\\n\\nvoid main() {\\n\\n  vec2 curuv = 0.5f*fs_Pos+0.5f;\\n  float div = 1.f/u_SimRes;\\n  float _maxHeightDiff = unif_TalusScale;\\n  //if(unif_rainMode == 1) _maxHeightDiff = 2.0; // lock talus angle here if rain mode\\n\\n  vec4 terraintop = texture(readTerrain,curuv+vec2(0.f,div));\\n  vec4 terrainright = texture(readTerrain,curuv+vec2(div,0.f));\\n  vec4 terrainbottom = texture(readTerrain,curuv+vec2(0.f,-div));\\n  vec4 terrainleft = texture(readTerrain,curuv+vec2(-div,0.f));\\n  vec4 terraincur = texture(readTerrain,curuv);\\n\\n  float maxLocalDiff = _maxHeightDiff * 0.01;\\n  float avgDiff = (terraintop.x + terrainright.x + terrainbottom.x + terrainleft.x) * 0.25 - terraincur.x;\\n  avgDiff = 10.0 * max(abs(avgDiff) - maxLocalDiff,0.0);\\n\\n  writeMaxslippage = vec4(max(_maxHeightDiff - avgDiff,0.0),0.0,0.0,1.0);\\n\\n}\\n\"","export default \"#version 300 es\\n\\n\\n\\nuniform mat4 u_view;\\nuniform mat4 u_proj;\\nuniform mat4 u_Model;\\n\\nuniform sampler2D hightmap;\\nuniform sampler2D sedimap;\\nuniform float u_SimRes;\\n\\nin vec4 vs_Pos;\\nin vec4 vs_Nor;\\nin vec4 vs_Col;\\nin vec2 vs_Uv;\\n\\nout vec3 fs_Pos;\\nout vec4 fs_Nor;\\nout vec4 fs_Col;\\n\\nout vec2 fs_Uv;\\n\\n\\n\\nvoid main()\\n{\\n\\n  fs_Uv = vs_Uv;\\n  float sval = 1.f*texture(sedimap,vs_Uv).x;\\n  float yval = 1.f*texture(hightmap,vs_Uv).x;\\n  float wval = 1.f*texture(hightmap,vs_Uv).y;\\n  vec4 modelposition = vec4(vs_Pos.x, (yval )/u_SimRes , vs_Pos.z, 1.0);\\n  fs_Pos = modelposition.xyz;\\n\\n\\n  modelposition = u_Model * modelposition;\\n  gl_Position = u_proj * u_view * modelposition;\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\n\\n\\n\\nin vec3 fs_Pos;\\nin vec4 fs_Nor;\\nin vec4 fs_Col;\\n\\n\\nuniform sampler2D hightmap;\\n\\nuniform sampler2D sedimap;\\n\\nlayout (location = 0) out vec4 shadowtex;\\n\\nin float fs_Sine;\\nin vec2 fs_Uv;\\n\\nuniform vec3 u_Eye, u_Ref, u_Up;\\nuniform vec2 u_Dimensions;\\nuniform int u_TerrainDebug;\\n\\nuniform vec4 u_MouseWorldPos;\\nuniform vec3 u_MouseWorldDir;\\nuniform float u_BrushSize;\\nuniform int u_BrushType;\\nuniform vec2 u_BrushPos;\\nuniform float u_SimRes;\\nuniform float u_SnowRange;\\n\\n\\n\\n\\nvoid main()\\n{\\n\\n    shadowtex = vec4(vec3(gl_FragCoord.z),1.f);\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform vec2 u_PlanePos; // Our location in the virtual world displayed by the plane\\n\\n\\n\\n\\n\\nout vec4 out_Col; // This is the final output color that you will see on your\\n                  // screen for the pixel that is currently being processed.\\n\\nuniform float u_SimRes;\\n\\n\\n\\n\\n\\nvoid main()\\n{\\n\\n\\n    out_Col = vec4(vec3(gl_FragCoord.z),1.f);\\n}\\n\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D color_tex;\\nuniform sampler2D bi_tex;\\nuniform sampler2D sceneDepth_tex;\\n\\nuniform float evapod;\\n\\nlayout (location = 0) out vec4 result;\\n\\n\\nin vec2 fs_Pos;\\n\\n\\nvoid main() {\\n\\n      vec2 curuv = 0.5f*fs_Pos+0.5f;\\n      vec4 geometry = texture(color_tex,curuv);\\n      vec4 scatter = texture(bi_tex,curuv);\\n      vec4 s_depth = texture(sceneDepth_tex, curuv);\\n\\n      float scatter_alpha = clamp(scatter.w,0.0,1.0);\\n\\n      vec4 color = vec4((1.0 - scatter.w) * geometry.xyz + (scatter.w)* scatter.xyz,1.0);\\n\\n\\n\\n      float scatteralpha = clamp(scatter.x, 0.0, 1.0);\\n\\n      if(s_depth.x == 0.0){\\n            color = vec4(geometry.xyz + scatter.xyz, 1.0);\\n      }else{\\n            color = vec4(geometry.xyz + scatter.xyz * 0.9, 1.0);\\n      }\\n\\n\\n      // simple tone mapping\\n      float gamma = 0.8;\\n      float exposure = 1.5;\\n\\n      vec3 mapped = vec3(1.0) - exp(-color.xyz * exposure);\\n\\n      mapped = pow(mapped, vec3(1.0 / gamma));\\n\\n\\n      result = vec4(mapped, 1.0);\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D scatter_tex;\\nuniform sampler2D scene_depth;\\n\\n\\nuniform float evapod;\\nuniform vec2 u_Dimensions;\\nuniform int u_isHorizontal;\\nuniform float u_far;\\nuniform float u_near;\\n\\nlayout (location = 0) out vec4 result;\\n\\n\\n\\n\\nin vec2 fs_Pos;\\n\\n#define GAUSS_BLUR_DEVIATION 1.5\\n#define FULL_RES_BLUR_KERNEL_SIZE 3\\n#define PI 3.1415926\\n#define BLUR_DEPTH_FACTOR 0.5\\n\\nfloat GaussianWeight(float offset, float deviation)\\n{\\n      float weight = 1.0f / sqrt(2.0f * PI * deviation * deviation);\\n      weight *= exp(-(offset * offset) / (2.0f * deviation * deviation));\\n      return weight;\\n}\\n\\nfloat linearDepth(float depthSample)\\n{\\n      depthSample = 2.0 * depthSample - 1.0;\\n      float zLinear = 2.0 * u_near * u_far / (u_far + u_near - depthSample * (u_far - u_near));\\n      return zLinear;\\n}\\n\\nvec4 BilateralBlur(vec2 curuv, vec2 dir){\\n      const float deviation = float(FULL_RES_BLUR_KERNEL_SIZE) / float(GAUSS_BLUR_DEVIATION);\\n      vec4 centerColor = texture(scatter_tex,curuv);\\n      float centerDepth = linearDepth(texture(scene_depth,curuv).x);\\n      vec4 color = centerColor;\\n      float weightSum = 0.0;\\n      float weight = GaussianWeight(0.0, deviation);\\n      float al = centerColor.w;\\n      color *= weight;\\n      weightSum += weight;\\n      for(int i = -FULL_RES_BLUR_KERNEL_SIZE; i< 0; i+= 1){\\n            vec2 offset = dir * float(i);\\n            vec4 sampleColor = texture(scatter_tex,curuv + offset / u_Dimensions);\\n\\n            float sampleDepth = linearDepth(texture(scene_depth,curuv + offset / u_Dimensions).x);\\n            float deptDiff = abs(centerDepth - sampleDepth);\\n            float dpFactor = deptDiff * BLUR_DEPTH_FACTOR;\\n            float w = exp(-(dpFactor * dpFactor));\\n\\n            weight = GaussianWeight(float(i), deviation) * w;\\n            color += weight * sampleColor;\\n            al += weight * sampleColor.w;\\n            weightSum += weight;\\n      }\\n      for(int i = 1; i< FULL_RES_BLUR_KERNEL_SIZE; i+= 1){\\n            vec2 offset = dir * float(i);\\n            vec4 sampleColor = texture(scatter_tex,curuv + offset / u_Dimensions);\\n\\n            float sampleDepth = linearDepth(texture(scene_depth,curuv + offset / u_Dimensions).x);\\n            float deptDiff = abs(centerDepth - sampleDepth);\\n            float dpFactor = deptDiff * BLUR_DEPTH_FACTOR;\\n            float w = exp(-(dpFactor * dpFactor));\\n\\n\\n            weight = GaussianWeight(float(i), deviation) * w;\\n            color += weight * sampleColor;\\n            al += weight * sampleColor.w;\\n            weightSum += weight;\\n      }\\n      color /= weightSum;\\n      al /= weightSum;\\n\\n      color.w = 1.0;\\n      return color;\\n\\n}\\n\\nvoid main() {\\n\\n      vec2 curuv = 0.5f*fs_Pos+0.5f;\\n\\n      vec4 scatter = texture(scatter_tex,curuv);\\n\\n      vec4 final_colour = vec4(0.0);\\n\\n      if(u_isHorizontal==0){\\n            final_colour = BilateralBlur(curuv, vec2(1.0,0.0));\\n      }else{\\n            final_colour = BilateralBlur(curuv, vec2(0.0,1.0));\\n      }\\n\\n      result = final_colour;\\n}\"","export default \"#version 300 es\\nprecision highp float;\\n\\nuniform sampler2D readVel;\\n\\n\\nuniform float u_SimRes;\\nuniform float u_timestep;\\n\\n\\n\\nlayout (location = 0) out vec4 writeVel;\\n\\n#define useMullerPath false\\n\\nin vec2 fs_Pos;\\n\\n\\n\\n\\n\\nvoid main() {\\n \\n    vec2 curuv = 0.5f*fs_Pos+0.5f;\\n    float div = 1.f/u_SimRes;\\n    float alpha = 1.0;\\n    float velscale = 1.0/1.0;\\n\\n    vec4 curvel = texture(readVel,curuv);\\n\\n\\n\\n    vec4 useVel = curvel/u_SimRes;\\n    //useVel *= unif_advectMultiplier * 0.5;\\n    useVel *= 0.5;\\n\\n\\n    vec2 oldloc = vec2(curuv.x-useVel.x*u_timestep,curuv.y-useVel.y*u_timestep);\\n    vec2 oldvel = texture(readVel, oldloc).xy;\\n    //oldsedi = samplebilinear(oldloc,u_SimRes   );\\n\\n\\n\\n    writeVel = vec4(oldvel.xy, curvel.zw);\\n}\"","import ShaderProgram, { Shader } from './gl/ShaderProgram';\n\n// GLSL shader imports\nimport terrainVert from '../shaders/terrain-vert.glsl?raw';\nimport terrainFrag from '../shaders/terrain-frag.glsl?raw';\nimport flatVert from '../shaders/flat-vert.glsl?raw';\nimport flatFrag from '../shaders/flat-frag.glsl?raw';\nimport quadVert from '../shaders/quad-vert.glsl?raw';\nimport initialFrag from '../shaders/initial-frag.glsl?raw';\nimport flowFrag from '../shaders/flow-frag.glsl?raw';\nimport alterwaterhightFrag from '../shaders/alterwaterhight-frag.glsl?raw';\nimport sedimentFrag from '../shaders/sediment-frag.glsl?raw';\nimport sediadvectFrag from '../shaders/sediadvect-frag.glsl?raw';\nimport maccormackFrag from '../shaders/maccormack-frag.glsl?raw';\nimport rainFrag from '../shaders/rain-frag.glsl?raw';\nimport evaFrag from '../shaders/eva-frag.glsl?raw';\nimport averageFrag from '../shaders/average-frag.glsl?raw';\nimport cleanFrag from '../shaders/clean-frag.glsl?raw';\nimport waterVert from '../shaders/water-vert.glsl?raw';\nimport waterFrag from '../shaders/water-frag.glsl?raw';\nimport thermalterrainfluxFrag from '../shaders/thermalterrainflux-frag.glsl?raw';\nimport thermalapplyFrag from '../shaders/thermalapply-frag.glsl?raw';\nimport maxslippageheightFrag from '../shaders/maxslippageheight-frag.glsl?raw';\nimport shadowmapVert from '../shaders/shadowmap-vert.glsl?raw';\nimport shadowmapFrag from '../shaders/shadowmap-frag.glsl?raw';\nimport sceneDepthFrag from '../shaders/sceneDepth-frag.glsl?raw';\nimport combineFrag from '../shaders/combine-frag.glsl?raw';\nimport bilateralBlurFrag from '../shaders/bilateralBlur-frag.glsl?raw';\nimport veladvectFrag from '../shaders/veladvect-frag.glsl?raw';\n\nexport interface Shaders {\n    lambert: ShaderProgram;\n    flat: ShaderProgram;\n    noiseterrain: ShaderProgram;\n    flow: ShaderProgram;\n    waterhight: ShaderProgram;\n    sediment: ShaderProgram;\n    sediadvect: ShaderProgram;\n    macCormack: ShaderProgram;\n    rains: ShaderProgram;\n    evaporation: ShaderProgram;\n    average: ShaderProgram;\n    clean: ShaderProgram;\n    water: ShaderProgram;\n    thermalterrainflux: ShaderProgram;\n    thermalapply: ShaderProgram;\n    maxslippageheight: ShaderProgram;\n    shadowMapShader: ShaderProgram;\n    sceneDepthShader: ShaderProgram;\n    combinedShader: ShaderProgram;\n    bilateralBlur: ShaderProgram;\n    veladvect: ShaderProgram;\n}\n\nexport function createShaders(gl_context: any): Shaders {\n    const lambert = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, terrainVert),\n        new Shader(gl_context.FRAGMENT_SHADER, terrainFrag),\n    ]);\n\n    const flat = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, flatVert),\n        new Shader(gl_context.FRAGMENT_SHADER, flatFrag),\n    ]);\n\n    const noiseterrain = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, initialFrag),\n    ]);\n\n    const flow = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, flowFrag),\n    ]);\n\n    const waterhight = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, alterwaterhightFrag),\n    ]);\n\n    const sediment = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, sedimentFrag),\n    ]);\n\n    const sediadvect = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, sediadvectFrag),\n    ]);\n\n    const macCormack = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, maccormackFrag),\n    ]);\n\n    const rains = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, rainFrag),\n    ]);\n\n    const evaporation = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, evaFrag),\n    ]);\n\n    const average = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, averageFrag),\n    ]);\n\n    const clean = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, cleanFrag),\n    ]);\n\n    const water = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, waterVert),\n        new Shader(gl_context.FRAGMENT_SHADER, waterFrag),\n    ]);\n\n    const thermalterrainflux = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, thermalterrainfluxFrag),\n    ]);\n\n    const thermalapply = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, thermalapplyFrag),\n    ]);\n\n    const maxslippageheight = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, maxslippageheightFrag),\n    ]);\n\n    const shadowMapShader = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, shadowmapVert),\n        new Shader(gl_context.FRAGMENT_SHADER, shadowmapFrag),\n    ]);\n\n    const sceneDepthShader = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, terrainVert),\n        new Shader(gl_context.FRAGMENT_SHADER, sceneDepthFrag),\n    ]);\n\n    const combinedShader = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, combineFrag),\n    ]);\n\n    const bilateralBlur = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, bilateralBlurFrag),\n    ]);\n\n    const veladvect = new ShaderProgram([\n        new Shader(gl_context.VERTEX_SHADER, quadVert),\n        new Shader(gl_context.FRAGMENT_SHADER, veladvectFrag),\n    ]);\n\n    return {\n        lambert,\n        flat,\n        noiseterrain,\n        flow,\n        waterhight,\n        sediment,\n        sediadvect,\n        macCormack,\n        rains,\n        evaporation,\n        average,\n        clean,\n        water,\n        thermalterrainflux,\n        thermalapply,\n        maxslippageheight,\n        shadowMapShader,\n        sceneDepthShader,\n        combinedShader,\n        bilateralBlur,\n        veladvect\n    };\n}\n\n","import {mat4, vec2, vec3, vec4} from 'gl-matrix';\n// @ts-ignore\nimport Stats from 'stats-js';\nimport * as DAT from 'dat-gui';\nimport Square from './geometry/Square';\nimport Plane from './geometry/Plane';\nimport OpenGLRenderer from './rendering/gl/OpenGLRenderer';\nimport Camera from './Camera';\nimport {gl, setGL} from './globals';\nimport ShaderProgram, {Shader} from './rendering/gl/ShaderProgram';\nimport {stat} from \"fs\";\nimport mouseChange from 'mouse-change';\nimport { ControlsConfig, getMouseButtonAction, isModifierPressed } from './controls-config';\nimport { loadSettings } from './settings';\nimport { setupGUI, GUIControllers } from './gui/gui-setup';\nimport { createEventHandlers } from './events/event-handlers';\nimport { updateBrushState, BrushContext, BrushControls, getOriginalBrushOperation, setOriginalBrushOperation } from './brush-handler';\nimport { updatePaletteSelection } from './brush-palette';\nimport { MAX_WATER_SOURCES, waterSources, getWaterSourceCount } from './utils/water-sources';\nimport { rayCast } from './utils/raycast';\nimport { rayCastBVH } from './utils/bvh-raycast';\nimport { createTerrainGeometry, updateTerrainGeometry } from './utils/terrain-geometry-builder';\nimport { MeshBVH, SAH } from 'three-mesh-bvh';\nimport { createHeightMapLoader } from './utils/heightmap-loader';\nimport { getCachedUniformLocation } from './utils/uniform-cache';\nimport { \n    simres, shadowMapResolution, SimFramecnt, TerrainGeometryDirty, PauseGeneration, \n    HightMapCpuBuf, HightMapBufCounter, MaxHightMapBufCounter, shouldReadHeightmap, setSimRes, setGlContext, \n    setClientDimensions, setLastMousePosition, clientWidth, clientHeight, lastX, lastY,\n    setPauseGeneration, setSimFramecnt, incrementSimFramecnt, setTerrainGeometryDirty,\n    resizeHightMapCpuBuf, incrementHightMapBufCounter, resetHightMapBufCounter,\n    terrainGeometry, terrainBVH, setTerrainGeometry, setTerrainBVH\n} from './simulation/simulation-state';\nimport {\n    frame_buffer, shadowMap_frame_buffer, deferred_frame_buffer,\n    render_buffer, shadowMap_render_buffer, deferred_render_buffer,\n    shadowMap_tex, scene_depth_tex, bilateral_filter_horizontal_tex, bilateral_filter_vertical_tex,\n    color_pass_tex, color_pass_reflection_tex, scatter_pass_tex,\n    read_terrain_tex, write_terrain_tex, read_flux_tex, write_flux_tex,\n    read_terrain_flux_tex, write_terrain_flux_tex, read_maxslippage_tex, write_maxslippage_tex,\n    read_vel_tex, write_vel_tex, read_sediment_tex, write_sediment_tex,\n    terrain_nor, read_sediment_blend, write_sediment_blend,\n    sediment_advect_a, sediment_advect_b,\n    setupFramebufferandtextures, resizeTextures4Simulation, resizeScreenTextures,\n    setHeightMapTexture, getHeightMapTexture,\n    swapTerrainTextures, swapFluxTextures, swapVelTextures, swapSedimentTextures,\n    swapSedimentBlendTextures, swapMaxSlippageTextures, swapTerrainFluxTextures,\n    swapBilateralFilterTextures\n} from './simulation/texture-management';\nimport { Render2Texture } from './rendering/render-utils';\nimport { createShaders, Shaders } from './rendering/shader-factory';\n\n// Note: Most state variables are now imported from simulation-state.ts\n// Additional local variables\nlet speed = 3;\nconst enableBilateralBlur = false;\nvar gl_context : WebGL2RenderingContext;\n\n\n\n//  (for backup)\nconst controlscomp = {\n\n\n    tesselations: 5,\n    pipelen:  0.8,//\n    Kc : 0.10,\n    Ks : 0.020,\n    Kd : 0.013,\n    timestep : 0.05,\n    pipeAra :  0.6,\n    RainErosion : false, //\n    RainErosionStrength : 1.0,\n    RainErosionDropSize : 1.0,\n    EvaporationConstant : 0.005,\n    VelocityMultiplier : 1,\n    RainDegree : 4.5,\n    AdvectionSpeedScaling : 1.0,\n    spawnposx : 0.5,\n    spawnposy : 0.5,\n    posTemp : vec2.fromValues(0.0,0.0),\n    'Load Scene': loadScene, // A function pointer, essentially\n    'Start/Resume' :StartGeneration,\n    'ResetTerrain' : Reset,\n    'setTerrainRandom':setTerrainRandom,\n    SimulationSpeed : 3,\n    TerrainBaseMap : 0,\n    TerrainBaseType : 0,//0 ordinary fbm, 1 domain warping, 2 terrace, 3 voroni\n    TerrainBiomeType : 1,\n    TerrainScale : 3.2,\n    TerrainHeight : 2.0,\n    TerrainMask : 0,//0 off, 1 sphere\n    TerrainDebug : 0,\n    WaterTransparency : 0.50,\n    SedimentTrace : 0, // 0 on, 1 off\n    TerrainPlatte : 1, // 0 normal alphine mtn, 1 desert, 2 jungle\n    SnowRange : 0,\n    ForestRange : 0,\n    brushType : 2, // 0 : no brush, 1 : terrain, 2 : water\n    brushSize : 4,\n    brushStrenth : 0.40,\n    brushOperation : 0, // 0 : add, 1 : subtract\n    brushPressed : 0, // 0 : not pressed, 1 : pressed\n    sourceCount : 0, // Number of active water sources\n    thermalRate : 0.5,\n    thermalErosionScale : 1.0,\n    lightPosX : 0.4,\n    lightPosY : 0.2,\n    lightPosZ : -1.0,\n    showScattering : true,\n    enableBilateralBlur : true,\n    AdvectionMethod : 1,\n    SimulationResolution : simres,\n\n};\n\n\nconst controls = {\n    tesselations: 5,\n    pipelen:  0.8,//\n    Kc : 0.06,\n    Ks : 0.036,\n    Kd : 0.006,\n    timestep : 0.05,\n    pipeAra :  0.6,\n    ErosionMode : 0, // 0 river erosion, 1 : mountain erosion, 2 : polygonal mode\n    RainErosion : false, //\n    RainErosionStrength : 0.2,\n    RainErosionDropSize : 2.0,\n    EvaporationConstant : 0.003,\n    VelocityMultiplier : 1,\n    RainDegree : 4.5,\n    AdvectionSpeedScaling : 1.0,\n    spawnposx : 0.5,\n    spawnposy : 0.5,\n    posTemp : vec2.fromValues(0.0,0.0),\n    'Load Scene': loadScene, // A function pointer, essentially\n    'Pause/Resume' :StartGeneration,\n    'ResetTerrain' : Reset,\n    'setTerrainRandom':setTerrainRandom,\n    'Import Height Map': () => {}, // Will be set in main() after gl_context is available\n    'Clear Height Map': () => {}, // Will be set in main() after gl_context is available\n    SimulationSpeed : 3,\n    TerrainBaseMap : 0,\n    TerrainBaseType : 0,//0 ordinary fbm, 1 domain warping, 2 terrace, 3 voroni\n    TerrainBiomeType : 1,\n    TerrainScale : 3.2,\n    TerrainHeight : 2.0,\n    TerrainMask : 0,//0 off, 1 sphere\n    TerrainDebug : 0,\n    WaterTransparency : 0.50,\n    SedimentTrace : true, // 0 on, 1 off\n    ShowFlowTrace : false,\n    TerrainPlatte : 1, // 0 normal alphine mtn, 1 desert, 2 jungle\n    SnowRange : 0,\n    ForestRange : 0,\n    brushType : 2, // 0 : no brush, 1 : terrain, 2 : water, 3 : rock, 4 : smooth, 5 : flatten, 6 : slope\n    brushSize : 4,\n    brushStrenth : 0.25,\n    brushOperation : 0, // 0 : add, 1 : subtract\n    brushPressed : 0, // 0 : not pressed, 1 : pressed\n    raycastMethod : 'bvh' as 'heightmap' | 'bvh', // Raycast method: 'heightmap' or 'bvh' (will be overridden by settings)\n    flattenTargetHeight : 0.0, // Target height for flatten brush (will be set to center height on Alt+click)\n    slopeStartPos : vec2.fromValues(0.0, 0.0), // Start position for slope brush\n    slopeEndPos : vec2.fromValues(0.0, 0.0), // End position for slope brush\n    slopeActive : 0, // 0 : not active, 1 : start set, 2 : end set\n    sourceCount : 0, // Number of active water sources\n    rockErosionResistance : 0.8, // 0.0 = erodes normally, 1.0 = doesn't erode (multiplier for Ks/Kc) - increased default so rock actually erodes much slower\n    thermalTalusAngleScale : 8.0,\n    thermalRate : 0.5,\n    thermalErosionScale : 1.0,\n    lightPosX : 0.4,\n    lightPosY : 0.8,\n    lightPosZ : -0.0,\n    showScattering : true,\n    enableBilateralBlur : true,\n    AdvectionMethod : 1,\n    VelocityAdvectionMag : 0.2,\n    SimulationResolution : simres,\n};\n\n\n\n\n\n// ================ geometries ============\n// =============================================================\nlet square: Square;\nlet plane : Plane;\nlet waterPlane : Plane;\n\n\n// Note: All texture and framebuffer variables are now imported from texture-management.ts\n\n// Reference to the initial terrain shader (set in main function)\nlet noiseterrain: ShaderProgram | null = null;\n\n// ================ dat gui button call backs ============\n// =============================================================\n\nfunction loadScene() {\n  square = new Square(vec3.fromValues(0, 0, 0));\n  square.create();\n  plane = new Plane(vec3.fromValues(0,0,0), vec2.fromValues(1,1), 18);\n  plane.create();\n  waterPlane = new Plane(vec3.fromValues(0,0,0), vec2.fromValues(1,1), 18);\n  waterPlane.create();\n}\n\nfunction StartGeneration(){\n    setPauseGeneration(!PauseGeneration);\n}\n\n\nfunction Reset(){\n    setSimFramecnt(0);\n    setTerrainGeometryDirty(true);\n    if(controls.SimulationResolution!=simres){\n        const newRes = Number(controls.SimulationResolution); // Ensure it's a number, not a string\n        setSimRes(newRes);\n        resizeTextures4Simulation(gl_context, newRes);\n        resizeHightMapCpuBuf(newRes); // Resize the CPU buffer to match new resolution\n    }\n    //PauseGeneration = true;\n}\n\nfunction setTerrainRandom() {\n}\n\n// Heightmap loading functions are now created via createHeightMapLoader in main()\n\n\n// Render2Texture is now imported from rendering/render-utils.ts\n\n\n\nfunction SimulatePerStep(renderer:OpenGLRenderer,\n                         gl_context:WebGL2RenderingContext,\n                         camera:Camera,\n                         shader:ShaderProgram,\n                         waterhight:ShaderProgram,\n                         veladvect : ShaderProgram,\n                         sedi:ShaderProgram,\n                         advect:ShaderProgram,\n                         macCormack : ShaderProgram,\n                         rains:ShaderProgram,\n                         eva:ShaderProgram,\n                         ave:ShaderProgram,\n                         thermalterrainflux:ShaderProgram,\n                         thermalapply:ShaderProgram,\n                         maxslippageheight:ShaderProgram) {\n\n\n    //////////////////////////////////////////////////////////////////\n    //rain precipitation\n    //0---use hight map to derive hight map : hight map -----> hight map\n    //////////////////////////////////////////////////////////////////\n\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_terrain_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // let status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n\n    renderer.clear();\n    rains.use();\n\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i(getCachedUniformLocation(rains.prog,\"readTerrain\"),0);\n    gl_context.uniform1f(getCachedUniformLocation(rains.prog,'raindeg'),controls.RainDegree);\n\n    renderer.render(camera,rains,[square]);\n\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n\n    //swap terrain tex-----------------------------------------------\n    swapTerrainTextures();\n    //swap terrain tex-----------------------------------------------\n\n\n    //////////////////////////////////////////////////////////////////\n    //1---use hight map to derive flux map : hight map -----> flux map\n    //////////////////////////////////////////////////////////////////\n\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_flux_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n\n    renderer.clear();\n    shader.use();\n\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i(getCachedUniformLocation(shader.prog,\"readTerrain\"),0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_flux_tex);\n    gl_context.uniform1i(getCachedUniformLocation(shader.prog,\"readFlux\"),1);\n\n    gl_context.activeTexture(gl_context.TEXTURE2);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_sediment_tex);\n    gl_context.uniform1i(getCachedUniformLocation(shader.prog,\"readSedi\"),2);\n\n    renderer.render(camera,shader,[square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n\n\n    //-----swap flux ping and pong\n    swapFluxTextures();\n    //-----swap flux ping and pong\n\n    //////////////////////////////////////////////////////////////////\n    //2---use flux map and hight map to derive velocity map and new hight map :\n    // hight map + flux map -----> velocity map + hight map\n    //////////////////////////////////////////////////////////////////\n\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_terrain_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,write_vel_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0,gl_context.COLOR_ATTACHMENT1]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n\n    renderer.clear();\n    waterhight.use();\n\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i(getCachedUniformLocation(waterhight.prog,\"readTerrain\"),0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_flux_tex);\n    gl_context.uniform1i(getCachedUniformLocation(waterhight.prog,\"readFlux\"),1);\n\n    gl_context.activeTexture(gl_context.TEXTURE2);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_sediment_tex);\n    gl_context.uniform1i(getCachedUniformLocation(waterhight.prog,\"readSedi\"),2);\n\n    gl_context.activeTexture(gl_context.TEXTURE3);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_vel_tex);\n    gl_context.uniform1i(getCachedUniformLocation(waterhight.prog,\"readVel\"),3);\n\n\n\n    renderer.render(camera,waterhight,[square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n\n    //-----swap terrain ping and pong and velocity ping pong\n    swapTerrainTextures();\n    swapVelTextures();\n    //-----swap terrain ping and pong and velocity ping pong\n\n\n    // //////////////////////////////////////////////////////////////////\n    // // experimental pass : self advection of velocity (potentially flux) to bring about momentum\n    // // ideally :\n    // // velocity map + (flux optional) ----> velocity map + (flux optional)\n    // //////////////////////////////////////////////////////////////////\n    //\n    //\n    // gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n    // gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_vel_tex,0);\n    // gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,null,0);\n    // gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    // gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    // gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n    //\n    // gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n    //\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if(status !== gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER)){\n    //     console.log(\"frame buffer status\" + status.toString());\n    // }\n    //\n    // gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n    // gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n    // gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, null);\n    //\n    // gl_context.viewport(0, 0, simres, simres);\n    // gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n    //\n    // renderer.clear();\n    // veladvect.use();\n    //\n    // gl_context.activeTexture(gl_context.TEXTURE0);\n    // gl_context.bindTexture(gl_context.TEXTURE_2D,read_vel_tex);\n    // gl_context.uniform1i(getCachedUniformLocation(veladvect.prog,\"readVel\"),0);\n    //\n    // renderer.render(camera,veladvect,[square]);\n    // gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    //\n    // //-----swap velocity ping pong\n    //\n    // tmp = read_vel_tex;\n    // read_vel_tex = write_vel_tex;\n    // write_vel_tex = tmp;\n    //\n    // //-----swap velocity ping pong\n\n    //////////////////////////////////////////////////////////////////\n    //3---use velocity map, sediment map and hight map to derive sediment map and new hight map and velocity map :\n    // hight map + velocity map + sediment map -----> sediment map + hight map + terrain normal map + velocity map\n    //////////////////////////////////////////////////////////////////\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_terrain_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,write_sediment_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,terrain_nor,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,write_vel_tex,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0,gl_context.COLOR_ATTACHMENT1,gl_context.COLOR_ATTACHMENT2, gl_context.COLOR_ATTACHMENT3]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n\n    renderer.clear();\n    sedi.use();\n\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i(getCachedUniformLocation(sedi.prog,\"readTerrain\"),0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_vel_tex);\n    gl_context.uniform1i(getCachedUniformLocation(sedi.prog,\"readVelocity\"),1);\n\n    gl_context.activeTexture(gl_context.TEXTURE2);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_sediment_tex);\n    gl_context.uniform1i(getCachedUniformLocation(sedi.prog,\"readSediment\"),2);\n\n    renderer.render(camera,sedi,[square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n\n    //----------swap terrain and sediment map---------\n    swapSedimentTextures();\n    swapTerrainTextures();\n    swapVelTextures();\n    //----------swap terrain and sediment map---------\n\n\n\n    //////////////////////////////////////////////////////////////////\n    // semi-lagrangian advection for sediment transportation\n    // 4---use velocity map, sediment map to derive new sediment map :\n    // velocity map + sediment map -----> sediment map\n    //////////////////////////////////////////////////////////////////\n    if(controls.AdvectionMethod == 1) {\n        //4.1  first subpass writing to the intermidiate sediment advection texture a\n        {\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT0, gl_context.TEXTURE_2D, sediment_advect_a, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT1, gl_context.TEXTURE_2D, write_vel_tex, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT2, gl_context.TEXTURE_2D, write_sediment_blend, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT3, gl_context.TEXTURE_2D, null, 0);\n            gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER, gl_context.DEPTH_ATTACHMENT, gl_context.RENDERBUFFER, render_buffer);\n\n            gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0, gl_context.COLOR_ATTACHMENT1, gl_context.COLOR_ATTACHMENT2]);\n\n            // Removed expensive checkFramebufferStatus call for performance\n            // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n            // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n            //     console.log(\"frame buffer status:\" + status.toString());\n            // }\n\n            gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n            gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, null);\n\n            gl_context.viewport(0, 0, simres, simres);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n\n\n            renderer.clear();\n            advect.use();\n            gl_context.activeTexture(gl_context.TEXTURE0);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_vel_tex);\n            gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"vel\"), 0);\n\n            gl_context.activeTexture(gl_context.TEXTURE1);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_tex);\n            gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"sedi\"), 1);\n\n            gl_context.activeTexture(gl_context.TEXTURE2);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_blend);\n            gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"sediBlend\"), 2);\n\n            gl_context.activeTexture(gl_context.TEXTURE3);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_terrain_tex);\n            gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"terrain\"), 3);\n\n            advect.setFloat(1, \"unif_advectMultiplier\");\n\n            renderer.render(camera, advect, [square]);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n\n        }\n        //4.2  second subpass writing to the intermidiate sediment advection texture b using a\n        {\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT0, gl_context.TEXTURE_2D, sediment_advect_b, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT1, gl_context.TEXTURE_2D, write_vel_tex, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT2, gl_context.TEXTURE_2D, write_sediment_blend, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT3, gl_context.TEXTURE_2D, null, 0);\n            gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER, gl_context.DEPTH_ATTACHMENT, gl_context.RENDERBUFFER, render_buffer);\n\n            gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0, gl_context.COLOR_ATTACHMENT1, gl_context.COLOR_ATTACHMENT2]);\n\n            // Removed expensive checkFramebufferStatus call for performance\n            // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n            // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n            //     console.log(\"frame buffer status:\" + status.toString());\n            // }\n\n            gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n            gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, null);\n\n            gl_context.viewport(0, 0, simres, simres);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n\n\n            renderer.clear();\n            advect.use();\n            gl_context.activeTexture(gl_context.TEXTURE0);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_vel_tex);\n            gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"vel\"), 0);\n\n            gl_context.activeTexture(gl_context.TEXTURE1);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, sediment_advect_a);\n            gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"sedi\"), 1);\n\n            gl_context.activeTexture(gl_context.TEXTURE2);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_blend);\n            gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"sediBlend\"), 2);\n\n            gl_context.activeTexture(gl_context.TEXTURE3);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_terrain_tex);\n            gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"terrain\"), 3);\n\n            advect.setFloat(-1, \"unif_advectMultiplier\");\n\n            renderer.render(camera, advect, [square]);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n\n        }\n        //4.3 thrid subpass : mac cormack advection writing to actual sediment using intermidiate advection textures\n        {\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT0, gl_context.TEXTURE_2D, write_sediment_tex, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT1, gl_context.TEXTURE_2D, null, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT2, gl_context.TEXTURE_2D, null, 0);\n            gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT3, gl_context.TEXTURE_2D, null, 0);\n            gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER, gl_context.DEPTH_ATTACHMENT, gl_context.RENDERBUFFER, render_buffer);\n\n            gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0, gl_context.COLOR_ATTACHMENT1, gl_context.COLOR_ATTACHMENT2]);\n\n            // Removed expensive checkFramebufferStatus call for performance\n            // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n            // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n            //     console.log(\"frame buffer status:\" + status.toString());\n            // }\n\n            gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n            gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, null);\n\n            gl_context.viewport(0, 0, simres, simres);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n\n\n            renderer.clear();\n            macCormack.use();\n            gl_context.activeTexture(gl_context.TEXTURE0);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_vel_tex);\n            gl_context.uniform1i(getCachedUniformLocation(macCormack.prog, \"vel\"), 0);\n\n            gl_context.activeTexture(gl_context.TEXTURE1);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_tex);\n            gl_context.uniform1i(getCachedUniformLocation(macCormack.prog, \"sedi\"), 1);\n\n            gl_context.activeTexture(gl_context.TEXTURE2);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, sediment_advect_a);\n            gl_context.uniform1i(getCachedUniformLocation(macCormack.prog, \"sediadvecta\"), 2);\n\n            gl_context.activeTexture(gl_context.TEXTURE3);\n            gl_context.bindTexture(gl_context.TEXTURE_2D, sediment_advect_b);\n            gl_context.uniform1i(getCachedUniformLocation(macCormack.prog, \"sediadvectb\"), 3);\n\n\n            renderer.render(camera, macCormack, [square]);\n            gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n\n        }\n\n    }else{\n        gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n        gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT0, gl_context.TEXTURE_2D, write_sediment_tex, 0);\n        gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT1, gl_context.TEXTURE_2D, write_vel_tex, 0);\n        gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT2, gl_context.TEXTURE_2D, write_sediment_blend, 0);\n        gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT3, gl_context.TEXTURE_2D, null, 0);\n        gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER, gl_context.DEPTH_ATTACHMENT, gl_context.RENDERBUFFER, render_buffer);\n\n        gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0, gl_context.COLOR_ATTACHMENT1, gl_context.COLOR_ATTACHMENT2]);\n\n        // Removed expensive checkFramebufferStatus call for performance\n        // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n        // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n        //     console.log(\"frame buffer status:\" + status.toString());\n        // }\n\n        gl_context.bindTexture(gl_context.TEXTURE_2D, null);\n        gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n        gl_context.bindRenderbuffer(gl_context.RENDERBUFFER, null);\n\n        gl_context.viewport(0, 0, simres, simres);\n        gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n\n\n        renderer.clear();\n        advect.use();\n        gl_context.activeTexture(gl_context.TEXTURE0);\n        gl_context.bindTexture(gl_context.TEXTURE_2D, read_vel_tex);\n        gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"vel\"), 0);\n\n        gl_context.activeTexture(gl_context.TEXTURE1);\n        gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_tex);\n        gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"sedi\"), 1);\n\n        gl_context.activeTexture(gl_context.TEXTURE2);\n        gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_blend);\n        gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"sediBlend\"), 2);\n\n        gl_context.activeTexture(gl_context.TEXTURE3);\n        gl_context.bindTexture(gl_context.TEXTURE_2D, read_terrain_tex);\n        gl_context.uniform1i(getCachedUniformLocation(advect.prog, \"terrain\"), 3);\n\n        advect.setFloat(1, \"unif_advectMultiplier\");\n\n        renderer.render(camera, advect, [square]);\n        gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n    }\n    //----------swap sediment map---------\n    swapSedimentBlendTextures();\n    swapSedimentTextures();\n    swapVelTextures();\n    //----------swap sediment map---------\n\n    //////////////////////////////////////////////////////////////////\n    // maxslippage map generation\n    // 4.5---use terrain map to derive new maxslippage map :\n    // hight map -----> max slippage  map\n    //////////////////////////////////////////////////////////////////\n\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_maxslippage_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n\n\n    renderer.clear();\n    maxslippageheight.use();\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i(getCachedUniformLocation(maxslippageheight.prog,\"readTerrain\"),0);\n\n\n\n    renderer.render(camera,maxslippageheight,[square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n\n    //---------------------------------\n    //swap maxslippage maps\n    swapMaxSlippageTextures();\n    //--------------------------------\n\n\n    //////////////////////////////////////////////////////////////////\n    // thermal terrain flux map generation\n    // 5---use velocity map, sediment map to derive new sediment map :\n    // hight map -----> terrain flux map\n    //////////////////////////////////////////////////////////////////\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_terrain_flux_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n\n\n    renderer.clear();\n    thermalterrainflux.use();\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i( getCachedUniformLocation(thermalterrainflux.prog,\"readTerrain\"),0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_maxslippage_tex);\n    gl_context.uniform1i(getCachedUniformLocation(thermalterrainflux.prog,\"readMaxSlippage\"),1);\n\n\n    renderer.render(camera,thermalterrainflux,[square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n    //---------------------------------\n    //swap terrain flux maps\n    swapTerrainFluxTextures();\n\n\n    //////////////////////////////////////////////////////////////////\n    // thermal erosion apply\n    // 6---use terrain flux map to derive new terrain map :\n    // terrain flux map -----> terrain map\n    //////////////////////////////////////////////////////////////////\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_terrain_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n\n\n    renderer.clear();\n    thermalapply.use();\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_flux_tex);\n    gl_context.uniform1i(getCachedUniformLocation(thermalapply.prog,\"readTerrainFlux\"),0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i(getCachedUniformLocation(thermalapply.prog,\"readTerrain\"),1);\n\n\n    renderer.render(camera,thermalapply,[square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n\n    //---------------swap terrain mao----------------------------\n    swapTerrainTextures();\n    //////////////////////////////////////////////////////////////////\n    // water level evaporation at end of each iteration\n    // 7---use terrain map to derive new terrain map :\n    // terrain map -----> terrain map\n    //////////////////////////////////////////////////////////////////\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_terrain_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n\n    renderer.clear();\n    eva.use();\n\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i(getCachedUniformLocation(eva.prog,\"terrain\"),0);\n    gl_context.uniform1f(getCachedUniformLocation(eva.prog,'evapod'),controls.EvaporationConstant);\n\n    renderer.render(camera,eva,[square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n\n    //---------------swap terrain mao----------------------------\n    swapTerrainTextures();\n    //---------------swap terrain mao----------------------------\n\n    //////////////////////////////////////////////////////////////////\n    // final average step : average terrain to avoid extremly sharp ridges or ravines\n    // 6---use terrain map to derive new terrain map :\n    //  terrain map -----> terrain map\n    //////////////////////////////////////////////////////////////////\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,write_terrain_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,terrain_nor,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT2,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT3,gl_context.TEXTURE_2D,null,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0,gl_context.COLOR_ATTACHMENT1]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // Only enable in debug builds if needed\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //     console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n    gl_context.viewport(0,0,simres,simres);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,frame_buffer);\n    renderer.clear();\n    ave.use();\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    gl_context.uniform1i(getCachedUniformLocation(ave.prog,\"readTerrain\"),0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_sediment_tex);\n    gl_context.uniform1i(getCachedUniformLocation(ave.prog,\"readSedi\"),1);\n\n    renderer.render(camera,ave,[square]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n    //---------------swap terrain mao----------------------------\n    swapTerrainTextures();\n    //---------------swap terrain mao----------------------------\n}\n\n// Texture management functions are now imported from simulation/texture-management.ts\n\n\n\nfunction SimulationStep(curstep:number,\n                        flow:ShaderProgram,\n                        waterhight : ShaderProgram,\n                        veladvect : ShaderProgram,\n                        sediment : ShaderProgram,\n                        advect:ShaderProgram,\n                        macCormack : ShaderProgram,\n                        rains:ShaderProgram,\n                        evapo:ShaderProgram,\n                        average:ShaderProgram,\n                        thermalterrainflux:ShaderProgram,\n                        thermalapply:ShaderProgram,\n                        maxslippageheight : ShaderProgram,\n                        renderer:OpenGLRenderer,\n                        gl_context:WebGL2RenderingContext,camera:Camera){\n    if(PauseGeneration) return true;\n    else{\n        SimulatePerStep(renderer,\n            gl_context,camera,flow,waterhight,veladvect,sediment,advect, macCormack,rains,evapo,average,thermalterrainflux,thermalapply, maxslippageheight);\n    }\n    return false;\n}\n\n// Unified coordinate normalization function\n// Converts viewport coordinates (clientX/clientY) to canvas-relative normalized coordinates [0, 1]\nfunction normalizeMousePosition(canvas: HTMLCanvasElement, clientX: number, clientY: number): {x: number, y: number} {\n    if (!canvas) {\n        return {x: 0, y: 0};\n    }\n    const rect = canvas.getBoundingClientRect();\n    if (rect.width <= 0 || rect.height <= 0) {\n        return {x: 0, y: 0};\n    }\n    const x = (clientX - rect.left) / rect.width;\n    const y = (clientY - rect.top) / rect.height;\n    return {x, y};\n}\n\nfunction handleInteraction (buttons : number, x : number, y : number){\n    // mouseChange provides element-local coordinates (relative to canvas)\n    // NOTE: This function may be interfering with pointer events\n    // Disabled to prevent coordinate conflicts - pointer events handle mouse position directly\n    // const canvas = document.getElementById('canvas') as HTMLCanvasElement;\n    // if (canvas) {\n    //     const rect = canvas.getBoundingClientRect();\n    //     if (rect.width > 0 && rect.height > 0) {\n    //         setLastMousePosition(rect.left + x, rect.top + y);\n    //     }\n    // }\n    //console.log(x + ' ' + y);\n}\n\n// Controls configuration - can be changed at runtime if needed\n// controlsConfig will be loaded from settings in main() function\nlet controlsConfig: ControlsConfig;\n\nfunction main() {\n\n  // Initial display for framerate\n  const stats = Stats();\n  stats.setMode(0);\n  stats.domElement.style.position = 'absolute';\n  stats.domElement.style.left = '0px';\n  stats.domElement.style.bottom = '0px';\n  stats.domElement.style.top = 'auto';\n  document.body.appendChild(stats.domElement);\n\n\n    //HightMapCpuBuf = new Float32Array(simresolution * simresolution * 4);\n\n  // Setup GUI\n  const { gui, controllers } = setupGUI(controls);\n  const { brushTypeController, brushSizeController, brushStrengthController, brushOperationController } = controllers;\n\n  // get canvas and webgl context\n  const canvas = <HTMLCanvasElement> document.getElementById('canvas');\n  gl_context = <WebGL2RenderingContext> canvas.getContext('webgl2');\n  setGlContext(gl_context);\n  setClientDimensions(canvas.clientWidth, canvas.clientHeight);\n  \n  // Create heightmap loader functions\n  const { loadHeightMap, clearHeightMap } = createHeightMapLoader(gl_context, simres, controls);\n  controls['Import Height Map'] = loadHeightMap;\n  controls['Clear Height Map'] = clearHeightMap;\n\n  // Load settings (from localStorage or defaults) - must be done before creating event handlers\n  controlsConfig = loadSettings();\n  \n  // Apply raycast method from settings\n  controls.raycastMethod = controlsConfig.raycast.method;\n  \n  // Heightfield raycasting uses the CPU heightmap buffer\n  \n  // Create camera first (needed for event handlers)\n  const brushUsesLeftClickForCamera = controlsConfig.mouse.brushActivate === 'LEFT' || \n                                       (controlsConfig.mouse.brushActivate === null && controlsConfig.keys.brushActivate === 'LEFT');\n  const camera = new Camera(vec3.fromValues(-0.18, 0.3, 0.6), vec3.fromValues(0, 0, 0), controlsConfig.camera, brushUsesLeftClickForCamera);\n  \n  // Create event handlers (must be done after controlsConfig and camera are loaded)\n  const eventHandlers = createEventHandlers(controls, controlsConfig, camera);\n  const { onKeyDown, onKeyUp, onMouseDown, onMouseUp } = eventHandlers;\n\n  // Disabled mouseChange to prevent coordinate conflicts with pointer events\n  // Pointer events now handle all mouse position tracking directly\n  // mouseChange(canvas, handleInteraction);\n  document.addEventListener('keydown', onKeyDown, false);\n  document.addEventListener('keyup', onKeyUp, false);\n  \n  // Note: controlsConfig will be loaded in main() before event listeners are set up\n  window.addEventListener('pointerdown', (e) => {\n    const buttonName = ['LEFT', 'MIDDLE', 'RIGHT'][e.button];\n    console.log('[DEBUG] WINDOW pointerdown CAPTURE - button:', e.button, 'buttonName:', buttonName, 'target:', e.target);\n    // Check if target is canvas or contains canvas\n    const target = e.target as HTMLElement;\n    const isCanvas = target === canvas || target.id === 'canvas' || target.closest('#canvas') === canvas;\n    console.log('[DEBUG] WINDOW pointerdown - isCanvas:', isCanvas, 'target:', target, 'canvas:', canvas);\n    if (isCanvas) {\n      // Always update mouse position when clicking on canvas (needed for accurate brush positioning)\n      setLastMousePosition(e.clientX, e.clientY);\n      \n      // Check if this is a brush action BEFORE calling handler\n      const action = getMouseButtonAction(e.button, controlsConfig);\n      if (action === 'brushActivate') {\n        console.log('[DEBUG] WINDOW pointerdown - BRUSH ACTION, stopping propagation immediately');\n        // Stop propagation IMMEDIATELY to prevent OrbitControls from seeing it\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        e.stopPropagation();\n        // Now call our handler\n        onMouseDown(e);\n        return;\n      }\n    }\n  }, true);\n  window.addEventListener('pointerup', (e) => {\n    console.log('[DEBUG] WINDOW pointerup CAPTURE - button:', e.button, 'target:', e.target);\n    const target = e.target as HTMLElement;\n    if (target === canvas || target.id === 'canvas' || target.closest('#canvas') === canvas) {\n      const action = getMouseButtonAction(e.button, controlsConfig);\n      if (action === 'brushActivate') {\n        console.log('[DEBUG] WINDOW pointerup - BRUSH ACTION, stopping propagation');\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        e.stopPropagation();\n        onMouseUp(e);\n      }\n    }\n  }, true);\n  \n  // Handle pointermove to update brush position (both when active and for preview)\n  window.addEventListener('pointermove', (e) => {\n    const target = e.target as HTMLElement;\n    const isCanvas = target === canvas || target.id === 'canvas' || target.closest('#canvas') === canvas;\n    if (isCanvas) {\n      // Always update mouse position for ray casting (needed for brush preview circle)\n      // Store client coordinates directly\n      setLastMousePosition(e.clientX, e.clientY);\n      \n      // Only check modifier state when brush is actively pressed\n      if (controls.brushPressed === 1) {\n        // Continuously check modifier state while brush is active\n        const invertModifier = controlsConfig.modifiers.brushInvert;\n        if (invertModifier) {\n          const modifierPressed = isModifierPressed(invertModifier, e);\n          \n          if (modifierPressed && getOriginalBrushOperation() === null) {\n            // Modifier is pressed but operation not inverted yet - invert it\n            setOriginalBrushOperation(controls.brushOperation);\n            controls.brushOperation = controls.brushOperation === 0 ? 1 : 0;\n            console.log('[DEBUG] Brush operation inverted on modifier (pointermove) to:', controls.brushOperation === 0 ? 'Add' : 'Subtract');\n          } else if (!modifierPressed && getOriginalBrushOperation() !== null) {\n            // Modifier released - restore original operation\n            const original = getOriginalBrushOperation();\n            if (original !== null) {\n                controls.brushOperation = original;\n                setOriginalBrushOperation(null);\n            }\n            console.log('[DEBUG] Brush operation restored on modifier release (pointermove) to:', controls.brushOperation === 0 ? 'Add' : 'Subtract');\n          }\n        }\n      }\n    }\n  }, true);\n  \n  // Handle pointercancel to deactivate brush if pointer is lost\n  window.addEventListener('pointercancel', (e) => {\n    if (controls.brushPressed === 1) {\n      console.log('[DEBUG] WINDOW pointercancel - deactivating brush');\n      controls.brushPressed = 0;\n    }\n  }, true);\n  \n  // Handle wheel events for brush size adjustment (configurable modifier + Scroll)\n  // Attach to canvas in capture phase to intercept before OrbitControls\n  canvas.addEventListener('wheel', (e) => {\n    const scrollModifier = controlsConfig.modifiers.brushSizeScroll;\n    if (!scrollModifier) {\n      // Brush size scroll is disabled, let OrbitControls handle all scroll events\n      return;\n    }\n    \n    // Check if the configured modifier is pressed\n      const modifierPressed = isModifierPressed(scrollModifier, e);\n    \n    if (modifierPressed) {\n      // Prevent default zoom behavior so OrbitControls doesn't zoom\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n      \n      // Adjust brush size based on scroll direction with very fine granularity\n      // deltaY > 0 means scrolling down (decrease size), < 0 means scrolling up (increase size)\n      const scrollDelta = e.deltaY;\n      const sizeChange = scrollDelta * 0.002; // Even more granular: 0.002 per scroll unit (reduced from 0.01)\n      const newSize = controls.brushSize - sizeChange; // Invert because scroll down should decrease\n      \n      // Clamp to valid range (0.1 to 20.0) and round to 2 decimal places for cleaner values\n      controls.brushSize = Math.round(Math.max(0.1, Math.min(20.0, newSize)) * 100) / 100;\n      \n      // Force dat-gui controller to update the display\n      const brushSizeController = (window as any).brushSizeController;\n      if (brushSizeController) {\n        brushSizeController.updateDisplay();\n      }\n      \n      // Update brush palette slider and label\n      const brushPalette = (window as any).brushPalette;\n      if (brushPalette) {\n        updatePaletteSelection(brushPalette, controls);\n      }\n    }\n    // If modifier is not pressed, do nothing - let OrbitControls handle zoom normally\n  }, { capture: true, passive: false }); // capture: true to intercept before OrbitControls, passive: false allows preventDefault\n\n    if (!gl_context) {\n    alert('WebGL 2 not supported!');\n  }\n    var extensions = gl_context.getSupportedExtensions();\n    for(let e in extensions){\n        console.log(e);\n    }\n  if(!gl_context.getExtension('OES_texture_float_linear')){\n        console.log(\"float texture not supported\");\n    }\n  if(!gl_context.getExtension('OES_texture_float')){\n      console.log(\"no float texutre!!!?? y am i here?\");\n  }\n  if(!gl_context.getExtension('EXT_color_buffer_float')) {\n      console.log(\"cant render to float texture \");\n  }\n  // `setGL` is a function imported above which sets the value of `gl_context` in the `globals.ts` module.\n  // Later, we can import `gl_context` from `globals.ts` to access it\n  setGL(gl_context);\n\n  // Initial call to load scene\n  loadScene();\n\n  // Camera is already created above, just check brushUsesLeftClick here for reference\n  const brushUsesLeftClick = controlsConfig.mouse.brushActivate === 'LEFT' || \n                             (controlsConfig.mouse.brushActivate === null && controlsConfig.keys.brushActivate === 'LEFT');\n  const renderer = new OpenGLRenderer(canvas);\n  renderer.setClearColor(0.0, 0.0, 0.0, 0);\n  gl_context.enable(gl_context.DEPTH_TEST);\n\n    setupFramebufferandtextures(gl_context, simres);\n    \n    // Create all shaders\n    const shaders = createShaders(gl_context);\n    const {\n        lambert, flat, flow, waterhight, sediment, sediadvect, macCormack,\n        rains, evaporation, average, clean, water, thermalterrainflux,\n        thermalapply, maxslippageheight, shadowMapShader, sceneDepthShader,\n        combinedShader, bilateralBlur, veladvect\n    } = shaders;\n    noiseterrain = shaders.noiseterrain;\n\n\n    let timer = 0;\n    function cleanUpTextures(){\n        Render2Texture(renderer, gl_context, camera, clean, read_terrain_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, read_vel_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, read_flux_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, read_terrain_flux_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, write_terrain_flux_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, read_maxslippage_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, write_maxslippage_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, read_sediment_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, write_terrain_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, write_vel_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, write_flux_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, write_sediment_tex, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, terrain_nor, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, read_sediment_blend, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, write_sediment_blend, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, sediment_advect_a, square, noiseterrain);\n        Render2Texture(renderer, gl_context, camera, clean, sediment_advect_b, square, noiseterrain);\n    }\n\n    // rayCast is now imported from utils/raycast.ts\n\n  // Reusable objects to avoid allocations every frame\n  const reusableViewProj = mat4.create();\n  const reusableInvViewProj = mat4.create();\n  const reusableMousePoint = vec4.create();\n  const reusableMousePointEnd = vec4.create();\n  const reusableDir = vec3.create();\n  const reusableRo = vec3.create();\n  const reusablePos = vec2.create();\n  const reusableLightViewMat = mat4.create();\n  const reusableLightProjMat = mat4.create();\n  const reusableLightPos = vec3.create();\n  const reusableSpawnPos = vec2.create();\n  \n  // Reusable arrays for water sources (reused instead of creating new ones)\n  const reusableSourcePositions = new Float32Array(MAX_WATER_SOURCES * 2);\n  const reusableSourceSizes = new Float32Array(MAX_WATER_SOURCES);\n  const reusableSourceStrengths = new Float32Array(MAX_WATER_SOURCES);\n\n  // Track brush state transitions for heightmap readback\n  let lastBrushPressed = 0;\n  let lastReadMouseX = -1;\n  let lastReadMouseY = -1;\n\n  function tick() {\n\n    // Update camera before raycasting so matrices are in sync with rendered view\n    camera.update(controlsConfig.camera);\n\n    // ================ ray casting ===================\n    //===================================================\n    const normalizedMouse = normalizeMousePosition(canvas, lastX, lastY);\n    var screenMouseX = normalizedMouse.x;\n    var screenMouseY = normalizedMouse.y;\n    //console.log(screenMouseX + ' ' + screenMouseY);\n\n      //console.log(clientHeight + ' ' + clientWidth);\n    mat4.multiply(reusableViewProj, camera.projectionMatrix, camera.viewMatrix);\n    mat4.invert(reusableInvViewProj, reusableViewProj);\n    reusableMousePoint[0] = 2.0 * screenMouseX - 1.0;\n    reusableMousePoint[1] = 1.0 - 2.0 * screenMouseY;\n    reusableMousePoint[2] = -1.0;\n    reusableMousePoint[3] = 1.0;\n    reusableMousePointEnd[0] = 2.0 * screenMouseX - 1.0;\n    reusableMousePointEnd[1] = 1.0 - 2.0 * screenMouseY;\n    reusableMousePointEnd[2] = -0.0;\n    reusableMousePointEnd[3] = 1.0;\n\n    vec4.transformMat4(reusableMousePoint, reusableMousePoint, reusableInvViewProj);\n    vec4.transformMat4(reusableMousePointEnd, reusableMousePointEnd, reusableInvViewProj);\n    reusableMousePoint[0] /= reusableMousePoint[3];\n    reusableMousePoint[1] /= reusableMousePoint[3];\n    reusableMousePoint[2] /= reusableMousePoint[3];\n    reusableMousePoint[3] /= reusableMousePoint[3];\n    reusableMousePointEnd[0] /= reusableMousePointEnd[3];\n    reusableMousePointEnd[1] /= reusableMousePointEnd[3];\n    reusableMousePointEnd[2] /= reusableMousePointEnd[3];\n    reusableMousePointEnd[3] /= reusableMousePointEnd[3];\n    reusableDir[0] = reusableMousePointEnd[0] - reusableMousePoint[0];\n    reusableDir[1] = reusableMousePointEnd[1] - reusableMousePoint[1];\n    reusableDir[2] = reusableMousePointEnd[2] - reusableMousePoint[2];\n    vec3.normalize(reusableDir, reusableDir);\n    reusableRo[0] = reusableMousePoint[0];\n    reusableRo[1] = reusableMousePoint[1];\n    reusableRo[2] = reusableMousePoint[2];\n\n\n    //==========set initial terrain uniforms=================\n    timer++;\n    noiseterrain.setTime(timer);\n    noiseterrain.setTerrainHeight(controls.TerrainHeight);\n    noiseterrain.setTerrainScale(controls.TerrainScale);\n    noiseterrain.setInt(controls.TerrainMask,\"u_TerrainMask\");\n    gl_context.uniform1i(getCachedUniformLocation(noiseterrain.prog,\"u_terrainBaseType\"),controls.TerrainBaseType);\n\n\n    if(TerrainGeometryDirty){\n\n        //=============clean up all simulation textures===================\n        cleanUpTextures();\n        //=============recreate base terrain textures=====================\n        Render2Texture(renderer,gl_context,camera,noiseterrain,read_terrain_tex,square,noiseterrain);\n        Render2Texture(renderer,gl_context,camera,noiseterrain,write_terrain_tex,square,noiseterrain);\n\n        //=============rebuild secondary terrain mesh and BVH for raycasting===================\n        // Dispose old BVH and geometry if they exist\n        if (terrainBVH) {\n            // BVH doesn't have explicit dispose, but we'll null the reference\n            setTerrainBVH(null);\n        }\n        if (terrainGeometry) {\n            terrainGeometry.dispose();\n            setTerrainGeometry(null);\n        }\n        \n        // Create new terrain geometry from heightmap\n        // Note: HightMapCpuBuf might not be populated yet on first frame\n        // The BVH will be built when the buffer is available (next frame or when heightmap is read)\n        // Check if buffer has actual data (not all zeros) before creating geometry\n        if (HightMapCpuBuf && HightMapCpuBuf.length >= simres * simres * 4) {\n            // Check if buffer has non-zero height data (sample a few points)\n            let hasData = false;\n            const sampleCount = Math.min(100, simres * simres);\n            for (let i = 0; i < sampleCount; i++) {\n                const idx = Math.floor(Math.random() * simres * simres) * 4;\n                if (HightMapCpuBuf[idx] !== 0) {\n                    hasData = true;\n                    break;\n                }\n            }\n            \n            if (hasData) {\n                try {\n                    const newGeometry = createTerrainGeometry(simres, HightMapCpuBuf, 1.0);\n                setTerrainGeometry(newGeometry);\n                \n                // Build BVH from geometry\n                const bvh = new MeshBVH(newGeometry, {\n                    strategy: SAH, // Surface Area Heuristic for best performance (use constant, not string)\n                    maxDepth: 40,    // Reasonable depth limit\n                    indirect: false   // Direct indexed geometry\n                });\n                setTerrainBVH(bvh);\n                    console.log('[BVH] Terrain BVH built successfully');\n                } catch (error) {\n                    console.warn('[BVH] Failed to build BVH (heightmap may not be ready yet):', error);\n                }\n            } else {\n                console.log('[BVH] Heightmap buffer exists but has no data yet, will build when populated');\n            }\n        } else {\n            console.log('[BVH] Heightmap buffer not ready yet, BVH will be built when available');\n        }\n\n        setTerrainGeometryDirty(false);\n    }\n    \n    // Build BVH if it doesn't exist but heightmap buffer is available\n    // This handles the case where terrain was dirty but buffer wasn't ready yet\n    if (!terrainBVH && !terrainGeometry && HightMapCpuBuf && HightMapCpuBuf.length >= simres * simres * 4) {\n        // Check if buffer has actual data (not all zeros)\n        let hasData = false;\n        const sampleCount = Math.min(100, simres * simres);\n        for (let i = 0; i < sampleCount; i++) {\n            const idx = Math.floor(Math.random() * simres * simres) * 4;\n            if (HightMapCpuBuf[idx] !== 0) {\n                hasData = true;\n                break;\n            }\n        }\n        \n        if (hasData) {\n            try {\n                const newGeometry = createTerrainGeometry(simres, HightMapCpuBuf, 1.0);\n                setTerrainGeometry(newGeometry);\n                \n                const bvh = new MeshBVH(newGeometry, {\n                    strategy: SAH,\n                    maxDepth: 40,\n                    indirect: false\n                });\n                setTerrainBVH(bvh);\n                console.log('[BVH] Terrain BVH built (delayed initialization)');\n            } catch (error) {\n                console.warn('[BVH] Failed to build BVH:', error);\n            }\n        }\n    }\n\n    //ray cast happens here\n    // Initialize to invalid values so we can detect misses\n    reusablePos[0] = -10.0;\n    reusablePos[1] = -10.0;\n    \n    \n    // Toggle between heightmap and BVH raycast methods for A/B testing\n    if (controls.raycastMethod === 'bvh' && terrainBVH && terrainGeometry) {\n        // Use BVH raycast\n        const hit = rayCastBVH(reusableRo, reusableDir, terrainBVH, terrainGeometry, reusablePos);\n        if (!hit) {\n            // Fallback to heightmap if BVH misses\n            const heightmapPos = vec2.create();\n            rayCast(reusableRo, reusableDir, simres, HightMapCpuBuf, heightmapPos);\n            reusablePos[0] = heightmapPos[0];\n            reusablePos[1] = heightmapPos[1];\n        }\n    } else {\n        // Use heightmap raycast (default)\n        rayCast(reusableRo, reusableDir, simres, HightMapCpuBuf, reusablePos);\n    }\n    \n    \n    controls.posTemp = reusablePos;\n\n    //===================per tick uniforms==================\n\n\n    flat.setTime(timer);\n\n    gl_context.uniform1f(getCachedUniformLocation(flat.prog,\"u_far\"),camera.far);\n    gl_context.uniform1f(getCachedUniformLocation(flat.prog,\"u_near\"),camera.near);\n    reusableLightPos[0] = controls.lightPosX;\n    reusableLightPos[1] = controls.lightPosY;\n    reusableLightPos[2] = controls.lightPosZ;\n    gl_context.uniform3fv(getCachedUniformLocation(flat.prog,\"unif_LightPos\"), reusableLightPos);\n\n    water.setWaterTransparency(controls.WaterTransparency);\n    water.setSimres(simres);\n    gl_context.uniform1f(getCachedUniformLocation(water.prog,\"u_far\"),camera.far);\n    gl_context.uniform1f(getCachedUniformLocation(water.prog,\"u_near\"),camera.near);\n    gl_context.uniform3fv(getCachedUniformLocation(water.prog,\"unif_LightPos\"), reusableLightPos);\n\n    lambert.setTerrainDebug(controls.TerrainDebug);\n    lambert.setMouseWorldPos(reusableMousePoint);\n    lambert.setMouseWorldDir(reusableDir);\n    lambert.setBrushSize(controls.brushSize);\n    lambert.setBrushType(controls.brushType);\n    lambert.setBrushPos(reusablePos);\n    lambert.setSimres(simres);\n    lambert.setFloat(controls.SnowRange, \"u_SnowRange\");\n    lambert.setFloat(controls.ForestRange, \"u_ForestRange\");\n    lambert.setInt(controls.TerrainPlatte, \"u_TerrainPlatte\");\n    lambert.setInt(controls.ShowFlowTrace ? 0 : 1,\"u_FlowTrace\");\n    lambert.setInt(controls.SedimentTrace ? 0 : 1,\"u_SedimentTrace\");\n    // Fill reusable arrays with source data (reuse instead of creating new ones)\n    for (let i = 0; i < MAX_WATER_SOURCES; i++) {\n        if (i < waterSources.length) {\n            reusableSourcePositions[i * 2] = waterSources[i].position[0];\n            reusableSourcePositions[i * 2 + 1] = waterSources[i].position[1];\n            reusableSourceSizes[i] = waterSources[i].size;\n            reusableSourceStrengths[i] = waterSources[i].strength;\n        } else {\n            // Fill with zeros for inactive sources\n            reusableSourcePositions[i * 2] = 0.0;\n            reusableSourcePositions[i * 2 + 1] = 0.0;\n            reusableSourceSizes[i] = 0.0;\n            reusableSourceStrengths[i] = 0.0;\n        }\n    }\n\n    // Set source arrays for terrain shader (visualization)\n    lambert.setSourceCount(getWaterSourceCount());\n    lambert.setSourcePositions(reusableSourcePositions);\n    lambert.setSourceSizes(reusableSourceSizes);\n    reusableLightPos[0] = controls.lightPosX;\n    reusableLightPos[1] = controls.lightPosY;\n    reusableLightPos[2] = controls.lightPosZ;\n    gl_context.uniform3fv(getCachedUniformLocation(lambert.prog,\"unif_LightPos\"), reusableLightPos);\n\n    sceneDepthShader.setSimres(simres);\n\n    rains.setMouseWorldPos(reusableMousePoint);\n    rains.setMouseWorldDir(reusableDir);\n    rains.setBrushSize(controls.brushSize);\n    rains.setBrushStrength(controls.brushStrenth);\n    rains.setBrushType(controls.brushType);\n    rains.setBrushPressed(controls.brushPressed);\n    rains.setSimres(simres);\n    \n    // Update brush state (flatten target height, slope end points, etc.)\n        const brushContext: BrushContext = {\n            controls: controls as BrushControls,\n            controlsConfig: controlsConfig,\n            simres: Number(simres), // Ensure it's a number, not a string\n            HightMapCpuBuf: HightMapCpuBuf,\n            camera: camera\n        };\n    updateBrushState(reusablePos, brushContext);\n    \n    // Set brush uniforms for shader\n    rains.setFloat(controls.flattenTargetHeight, 'u_FlattenTargetHeight');\n    rains.setVec2(controls.slopeStartPos, 'u_SlopeStartPos');\n    rains.setVec2(controls.slopeEndPos, 'u_SlopeEndPos');\n    rains.setInt(controls.slopeActive, 'u_SlopeActive');\n    // Set source arrays for rain shader (water emission)\n    rains.setSourceCount(getWaterSourceCount());\n    rains.setSourcePositions(reusableSourcePositions);\n    rains.setSourceSizes(reusableSourceSizes);\n    rains.setSourceStrengths(reusableSourceStrengths);\n    rains.setBrushPos(reusablePos);\n    // Set brush operation - this determines add vs subtract mode\n    rains.setBrushOperation(controls.brushOperation);\n    reusableSpawnPos[0] = controls.spawnposx;\n    reusableSpawnPos[1] = controls.spawnposy;\n    rains.setSpawnPos(reusableSpawnPos);\n    rains.setTime(timer);\n    gl_context.uniform1i(getCachedUniformLocation(rains.prog,\"u_RainErosion\"),controls.RainErosion ? 1 : 0);\n    rains.setFloat(controls.RainErosionStrength,'u_RainErosionStrength');\n    rains.setFloat(controls.RainErosionDropSize,'u_RainErosionDropSize');\n\n    flow.setPipeLen(controls.pipelen);\n    flow.setSimres(simres);\n    flow.setTimestep(controls.timestep);\n    flow.setPipeArea(controls.pipeAra);\n\n    waterhight.setPipeLen(controls.pipelen);\n    waterhight.setSimres(simres);\n    waterhight.setTimestep(controls.timestep);\n    waterhight.setPipeArea(controls.pipeAra);\n    waterhight.setFloat(controls.VelocityMultiplier, 'u_VelMult');\n    waterhight.setFloat(controls.VelocityAdvectionMag, 'u_VelAdvMag');\n    waterhight.setTime(timer);\n\n    sediment.setSimres(simres);\n    sediment.setPipeLen(controls.pipelen);\n    sediment.setKc(controls.Kc);\n    sediment.setKs(controls.Ks);\n    sediment.setKd(controls.Kd);\n    sediment.setRockErosionResistance(controls.rockErosionResistance);\n    sediment.setTimestep(controls.timestep);\n    sediment.setTime(timer);\n\n    sediadvect.setSimres(simres);\n    sediadvect.setPipeLen(controls.pipelen);\n    sediadvect.setKc(controls.Kc);\n    sediadvect.setKs(controls.Ks);\n    sediadvect.setKd(controls.Kd);\n    sediadvect.setTimestep(controls.timestep);\n    sediadvect.setFloat(controls.AdvectionSpeedScaling, \"unif_advectionSpeedScale\");\n\n    veladvect.setSimres(simres);\n    veladvect.setPipeLen(controls.pipelen);\n    veladvect.setKc(controls.Kc);\n    veladvect.setKs(controls.Ks);\n    veladvect.setKd(controls.Kd);\n    veladvect.setTimestep(controls.timestep);\n\n    macCormack.setSimres(simres);\n    macCormack.setPipeLen(controls.pipelen);\n    macCormack.setKc(controls.Kc);\n    macCormack.setKs(controls.Ks);\n    macCormack.setKd(controls.Kd);\n    macCormack.setTimestep(controls.timestep);\n    macCormack.setFloat(controls.AdvectionSpeedScaling, \"unif_advectionSpeedScale\");\n\n    thermalterrainflux.setSimres(simres);\n    thermalterrainflux.setPipeLen(controls.pipelen);\n    thermalterrainflux.setTimestep(controls.timestep);\n    thermalterrainflux.setPipeArea(controls.pipeAra);\n    gl_context.uniform1f(getCachedUniformLocation(thermalterrainflux.prog,\"unif_thermalRate\"),controls.thermalRate);\n\n    thermalapply.setSimres(simres);\n    thermalapply.setPipeLen(controls.pipelen);\n    thermalapply.setTimestep(controls.timestep);\n    thermalapply.setPipeArea(controls.pipeAra);\n    gl_context.uniform1f(getCachedUniformLocation(thermalapply.prog,\"unif_thermalErosionScale\"),controls.thermalErosionScale);\n\n    maxslippageheight.setSimres(simres);\n    maxslippageheight.setPipeLen(controls.pipelen);\n    maxslippageheight.setTimestep(controls.timestep);\n    maxslippageheight.setPipeArea(controls.pipeAra);\n    maxslippageheight.setFloat(controls.thermalTalusAngleScale, \"unif_TalusScale\");\n      if(controls.RainErosion){\n          maxslippageheight.setInt(1, 'unif_rainMode');\n      }else{\n          maxslippageheight.setInt(0,'unif_rainMode');\n      }\n\n    average.setSimres(simres);\n    average.setInt(controls.ErosionMode,'unif_ErosionMode');\n    if(controls.RainErosion){\n        average.setInt(1, 'unif_rainMode');\n    }else{\n        average.setInt(0,'unif_rainMode');\n    }\n\n    const brushPressed = controls.brushPressed === 1;\n    const brushVisible = Number(controls.brushType) !== 0;\n    const justPressed = brushPressed && lastBrushPressed === 0;\n    incrementHightMapBufCounter();\n    stats.begin();\n\n      //==========================  we begin simulation from now ===========================================\n\n    for(let i = 0;i<controls.SimulationSpeed;i++) {\n        SimulationStep(SimFramecnt, flow, waterhight, veladvect,sediment, sediadvect, macCormack,rains,evaporation,average,thermalterrainflux, thermalapply, maxslippageheight, renderer, gl_context, camera);\n        incrementSimFramecnt();\n    }\n\n    const mouseMoved = (lastReadMouseX < 0 || lastReadMouseY < 0) ||\n        (Math.abs(lastX - lastReadMouseX) + Math.abs(lastY - lastReadMouseY) > 1);\n    if ((justPressed || mouseMoved) && shouldReadHeightmap(brushPressed, brushVisible, simres)) {\n        // Read full resolution for accurate raycasting\n        gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, frame_buffer);\n        gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT0, gl_context.TEXTURE_2D, read_terrain_tex, 0);\n        gl_context.readBuffer(gl_context.COLOR_ATTACHMENT0);\n        gl_context.readPixels(0, 0, simres, simres, gl_context.RGBA, gl_context.FLOAT, HightMapCpuBuf);\n        gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n        lastReadMouseX = lastX;\n        lastReadMouseY = lastY;\n        if (!brushPressed && !brushVisible && HightMapBufCounter >= MaxHightMapBufCounter) {\n            resetHightMapBufCounter();\n        }\n    }\n\n    lastBrushPressed = brushPressed ? 1 : 0;\n\n    gl_context.viewport(0, 0, window.innerWidth, window.innerHeight);\n    renderer.clear();\n\n    //========================== we enter a series of render pass from now ================================\n    //========================== pass 1 : render shadow map pass=====================================\n\n\n      gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,shadowMap_frame_buffer);\n      gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,shadowMap_tex,0);\n      gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,shadowMap_render_buffer);\n\n      gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n      // Removed expensive checkFramebufferStatus call for performance\n      // let status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n      // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n      //     console.log( \"frame buffer status:\" + status.toString());\n      // }\n\n      gl_context.bindTexture(gl_context.TEXTURE_2D,null);\n      gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n      gl_context.bindRenderbuffer(gl_context.RENDERBUFFER,null);\n\n      gl_context.viewport(0,0,shadowMapResolution,shadowMapResolution);\n      gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,shadowMap_frame_buffer);\n      renderer.clear();// clear when attached to shadow map\n      shadowMapShader.use();\n\n      gl_context.activeTexture(gl_context.TEXTURE0);\n      gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n      gl_context.uniform1i(getCachedUniformLocation(shadowMapShader.prog,\"hightmap\"),0);\n\n      gl_context.activeTexture(gl_context.TEXTURE1);\n      gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_tex);\n      gl_context.uniform1i(getCachedUniformLocation(shadowMapShader.prog, \"sedimap\"), 1);\n\n      mat4.ortho(reusableLightProjMat, -1.6, 1.6, -1.6, 1.6, 0, 100);\n      reusableLightPos[0] = controls.lightPosX;\n      reusableLightPos[1] = controls.lightPosY;\n      reusableLightPos[2] = controls.lightPosZ;\n      mat4.lookAt(reusableLightViewMat, reusableLightPos, [0,0,0], [0,1,0]);\n\n      gl_context.uniformMatrix4fv(getCachedUniformLocation(shadowMapShader.prog,'u_proj'),false,reusableLightProjMat);\n      gl_context.uniformMatrix4fv(getCachedUniformLocation(shadowMapShader.prog,'u_view'),false,reusableLightViewMat);\n      shadowMapShader.setSimres(simres);\n\n      renderer.render(camera,shadowMapShader,[plane]);\n      gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n\n      //=========================== pass 2 :  render scene depth tex ================================\n      sceneDepthShader.use();\n      gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,deferred_frame_buffer);\n      gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,scene_depth_tex,0);\n      gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,deferred_render_buffer);\n\n      gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n      // Removed expensive checkFramebufferStatus call for performance\n      // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n      // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n      //     console.log( \"frame buffer status:\" + status.toString());\n      // }\n\n      renderer.clear();// clear when attached to scene depth map\n      gl_context.viewport(0,0,window.innerWidth, window.innerHeight);\n      renderer.render(camera, sceneDepthShader, [\n          plane,\n      ]);\n      gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n    //============================= pass 3 : render terrain and water geometry ================================================\n    //============ terrain geometry =========\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,deferred_frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,color_pass_tex,0);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT1,gl_context.TEXTURE_2D,color_pass_reflection_tex,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,deferred_render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0, gl_context.COLOR_ATTACHMENT1]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //   console.log( \"frame buffer status:\" + status.toString());\n    // }\n    renderer.clear();\n\n    lambert.use();\n    gl_context.viewport(0,0,window.innerWidth, window.innerHeight);\n    //plane.setDrawMode(gl_context.LINE_STRIP);\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    let PingUniform = getCachedUniformLocation(lambert.prog,\"hightmap\");\n    gl_context.uniform1i(PingUniform,0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,terrain_nor);\n    let norUniform = getCachedUniformLocation(lambert.prog,\"normap\");\n    gl_context.uniform1i(norUniform,1);\n\n    gl_context.activeTexture(gl_context.TEXTURE2);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_tex);\n    let sediUniform = getCachedUniformLocation(lambert.prog, \"sedimap\");\n    gl_context.uniform1i(sediUniform, 2);\n\n    gl_context.activeTexture(gl_context.TEXTURE3);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, read_vel_tex);\n    let velUniform = getCachedUniformLocation(lambert.prog, \"velmap\");\n    gl_context.uniform1i(velUniform, 3);\n\n    gl_context.activeTexture(gl_context.TEXTURE4);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, read_flux_tex);\n    let fluxUniform = getCachedUniformLocation(lambert.prog, \"fluxmap\");\n    gl_context.uniform1i(fluxUniform, 4);\n\n    gl_context.activeTexture(gl_context.TEXTURE5);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, read_terrain_flux_tex);\n    let terrainfluxUniform = getCachedUniformLocation(lambert.prog, \"terrainfluxmap\");\n    gl_context.uniform1i(terrainfluxUniform, 5);\n\n    gl_context.activeTexture(gl_context.TEXTURE6);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, read_maxslippage_tex);\n    let terrainslippageUniform = getCachedUniformLocation(lambert.prog, \"maxslippagemap\");\n    gl_context.uniform1i(terrainslippageUniform, 6);\n\n    gl_context.activeTexture(gl_context.TEXTURE7);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_blend);\n    gl_context.uniform1i(getCachedUniformLocation(lambert.prog, \"sediBlend\"), 7);\n\n\n    gl_context.activeTexture(gl_context.TEXTURE8);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, shadowMap_tex);\n    gl_context.uniform1i(getCachedUniformLocation(lambert.prog, \"shadowMap\"), 8);\n\n    gl_context.activeTexture(gl_context.TEXTURE9);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, scene_depth_tex);\n    gl_context.uniform1i(getCachedUniformLocation(lambert.prog, \"sceneDepth\"), 9);\n\n    gl_context.uniformMatrix4fv(getCachedUniformLocation(lambert.prog,'u_sproj'),false,reusableLightProjMat);\n    gl_context.uniformMatrix4fv(getCachedUniformLocation(lambert.prog,'u_sview'),false,reusableLightViewMat);\n\n\n      renderer.render(camera, lambert, [\n      plane,\n    ]);\n\n    // =============== water =====================\n    gl_context.enable(gl_context.BLEND);\n    gl_context.blendFunc(gl_context.SRC_ALPHA, gl_context.ONE_MINUS_SRC_ALPHA);\n    water.use();\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_terrain_tex);\n    PingUniform = getCachedUniformLocation(water.prog,\"hightmap\");\n    gl_context.uniform1i(PingUniform,0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,terrain_nor);\n    norUniform = getCachedUniformLocation(water.prog,\"normap\");\n    gl_context.uniform1i(norUniform,1);\n\n    gl_context.activeTexture(gl_context.TEXTURE2);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,read_sediment_tex);\n    sediUniform = getCachedUniformLocation(water.prog,\"sedimap\");\n    gl_context.uniform1i(sediUniform,2);\n\n    gl_context.activeTexture(gl_context.TEXTURE3);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,scene_depth_tex);\n    gl_context.uniform1i(getCachedUniformLocation(water.prog,\"sceneDepth\"),3);\n\n    gl_context.activeTexture(gl_context.TEXTURE4);\n    gl_context.bindTexture(gl_context.TEXTURE_2D,color_pass_reflection_tex);\n    gl_context.uniform1i(getCachedUniformLocation(water.prog,\"colorReflection\"),4);\n\n\n      renderer.render(camera, water, [\n      plane,\n    ]);\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,null);\n\n    gl_context.blendFunc(gl_context.SRC_ALPHA, gl_context.ONE_MINUS_SRC_ALPHA);\n\n\n    // ======================== pass 4 : back ground & post processing & rayleigh mie scattering ==================================\n\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER,deferred_frame_buffer);\n    gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER,gl_context.COLOR_ATTACHMENT0,gl_context.TEXTURE_2D,scatter_pass_tex,0);\n    gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER,gl_context.DEPTH_ATTACHMENT,gl_context.RENDERBUFFER,deferred_render_buffer);\n\n    gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n    // Removed expensive checkFramebufferStatus call for performance\n    // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n    // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n    //   console.log( \"frame buffer status:\" + status.toString());\n    // }\n\n    renderer.clear();// clear when attached to scene depth map\n    gl_context.viewport(0,0,window.innerWidth, window.innerHeight);\n\n    flat.use();\n\n    gl_context.enable(gl_context.DEPTH_TEST);\n    gl_context.depthFunc(gl_context.LESS);\n    gl_context.enable(gl_context.BLEND);\n    gl_context.blendFunc(gl_context.SRC_ALPHA, gl_context.ONE_MINUS_SRC_ALPHA);\n\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, read_sediment_tex);\n    gl_context.uniform1i(getCachedUniformLocation(flat.prog,\"hightmap\"),0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, scene_depth_tex);\n    gl_context.uniform1i(getCachedUniformLocation(flat.prog,\"sceneDepth\"),1);\n\n    gl_context.activeTexture(gl_context.TEXTURE2);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, shadowMap_tex);\n    gl_context.uniform1i(getCachedUniformLocation(flat.prog,\"shadowMap\"),2);\n\n    gl_context.uniformMatrix4fv(getCachedUniformLocation(flat.prog,'u_sproj'),false,reusableLightProjMat);\n    gl_context.uniformMatrix4fv(getCachedUniformLocation(flat.prog,'u_sview'),false,reusableLightViewMat);\n    gl_context.uniform1i(getCachedUniformLocation(flat.prog,\"u_showScattering\"),controls.showScattering ? 1 : 0);\n\n    renderer.render(camera, flat, [\n      square,\n    ]);\n    gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n\n\n    // ======================== pass 5 : bilateral blurring pass ==================================\n      if(controls.enableBilateralBlur) {\n          let NumBlurPass = 4;\n          for (let i = 0; i < NumBlurPass; ++i) {\n\n              gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, deferred_frame_buffer);\n              gl_context.framebufferTexture2D(gl_context.FRAMEBUFFER, gl_context.COLOR_ATTACHMENT0, gl_context.TEXTURE_2D, bilateral_filter_horizontal_tex, 0);\n              gl_context.framebufferRenderbuffer(gl_context.FRAMEBUFFER, gl_context.DEPTH_ATTACHMENT, gl_context.RENDERBUFFER, deferred_render_buffer);\n\n              gl_context.drawBuffers([gl_context.COLOR_ATTACHMENT0]);\n\n              // Removed expensive checkFramebufferStatus call for performance\n              // status = gl_context.checkFramebufferStatus(gl_context.FRAMEBUFFER);\n              // if (status !== gl_context.FRAMEBUFFER_COMPLETE) {\n              //     console.log(\"frame buffer status:\" + status.toString());\n              // }\n\n              renderer.clear();// clear when attached to scene depth map\n\n              bilateralBlur.use();\n              gl_context.activeTexture(gl_context.TEXTURE0);\n              if (i == 0) {\n                  gl_context.bindTexture(gl_context.TEXTURE_2D, scatter_pass_tex);\n              } else {\n                  gl_context.bindTexture(gl_context.TEXTURE_2D, bilateral_filter_vertical_tex);\n              }\n              gl_context.uniform1i(getCachedUniformLocation(bilateralBlur.prog, \"scatter_tex\"), 0);\n\n              gl_context.activeTexture(gl_context.TEXTURE1);\n              gl_context.bindTexture(gl_context.TEXTURE_2D, scene_depth_tex);\n              gl_context.uniform1i(getCachedUniformLocation(bilateralBlur.prog, \"scene_depth\"), 1);\n\n              gl_context.uniform1f(getCachedUniformLocation(bilateralBlur.prog, \"u_far\"), camera.far);\n              gl_context.uniform1f(getCachedUniformLocation(bilateralBlur.prog, \"u_near\"), camera.near);\n\n              gl_context.uniform1i(getCachedUniformLocation(bilateralBlur.prog, \"u_isHorizontal\"), i % 2);\n\n\n              renderer.render(camera, bilateralBlur, [\n                  square,\n              ]);\n\n              swapBilateralFilterTextures();\n\n              gl_context.bindFramebuffer(gl_context.FRAMEBUFFER, null);\n          }\n      }\n\n    // ===================================== pass 6 : combination pass =====================================================================\n    combinedShader.use();\n\n    gl_context.activeTexture(gl_context.TEXTURE0);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, color_pass_tex);\n    gl_context.uniform1i(getCachedUniformLocation(combinedShader.prog,\"color_tex\"),0);\n\n    gl_context.activeTexture(gl_context.TEXTURE1);\n    if(controls.enableBilateralBlur)\n        gl_context.bindTexture(gl_context.TEXTURE_2D, bilateral_filter_horizontal_tex);\n    else\n        gl_context.bindTexture(gl_context.TEXTURE_2D, scatter_pass_tex);\n    gl_context.uniform1i(getCachedUniformLocation(combinedShader.prog,\"bi_tex\"),1);\n\n    gl_context.activeTexture(gl_context.TEXTURE2);\n    gl_context.bindTexture(gl_context.TEXTURE_2D, scene_depth_tex);\n    gl_context.uniform1i(getCachedUniformLocation(combinedShader.prog,\"sceneDepth_tex\"),2);\n\n    renderer.clear();\n    renderer.render(camera, combinedShader, [\n      square,\n    ]);\n\n    gl_context.disable(gl_context.BLEND);\n    //gl_context.disable(gl_context.DEPTH_TEST);\n    stats.end();\n\n    // Tell the browser to call `tick` again whenever it renders a new frame\n    requestAnimationFrame(tick);\n  }\n\n  window.addEventListener('resize', function() {\n\n    resizeScreenTextures();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n\n    camera.setAspectRatio(window.innerWidth / window.innerHeight);\n    camera.updateProjectionMatrix();\n  }, false);\n\n  renderer.setSize(window.innerWidth, window.innerHeight);\n  camera.setAspectRatio(window.innerWidth / window.innerHeight);\n  camera.updateProjectionMatrix();\n\n  // Start the render loop\n  tick();\n}\n\nmain();\n"],"names":["gl","setGL","_gl","Drawable","m","Square","center","vec4.fromValues","Plane","scale","subdivs","vec3.fromValues","width","normalize","posIdx","x","z","uvIdx","indexIdx","i","j","OpenGLRenderer","canvas","r","g","b","a","height","camera","prog","drawables","model","mat4.create","viewProj","mat4.identity","mat4.multiply","drawable","Camera","position","target","cameraConfig","brushUsesLeftClick","vec3.create","Vector3","vec3.subtract","PerspectiveCamera","OrbitControls","mouseButtons","THREE.MOUSE","vec3.add","wd","lookatVec","tmpRight","camUp","vec3.cross","vec3.normalize","vec3.scale","mat4.lookAt","aspectRatio","mat4.perspective","key","deltaTime","config","acceleration","deceleration","maxSpeed","fastMaxSpeed","forward","right","up","desiredDirection","threeForward","vec3.length","vec3.set","threeRight","worldUpVec","vec3.copy","currentMaxSpeed","desiredVelocity","velocityChange","accelRate","decelRate","currentSpeed","movementDelta","currentTime","rawDeltaTime","defaultControlsConfig","getKeyAction","isBrushActivate","input","buttonName","getMouseButtonAction","button","isModifierPressed","modifier","event","SETTINGS_STORAGE_KEY","loadSettings","stored","parsed","mergeWithDefaults","error","saveSettings","loaded","_a","_b","_c","_d","_e","_f","_g","_h","_i","_j","_k","_l","_m","_n","_o","_p","_q","_s","_r","_u","_t","_w","_v","_y","_x","_z","BRUSH_TYPES","BRUSH_SIZE_PRESETS","BRUSH_STRENGTH_PRESETS","createBrushPalette","controls","onBrushChange","onSizeChange","onStrengthChange","onOperationChange","palette","isMinimized","isDragging","dragOffset","handleMouseDown","e","rect","handleMouseMove","handleMouseUp","header","title","controlsButton","readmeButton","minimizeBtn","content","brushSection","brushLabel","brush","shortcutText","updatePaletteSelection","separator","sizeContainer","sizeHeader","sizeLabel","sizePresets","preset","presetBtn","sizeInput","value","strengthContainer","strengthHeader","strengthLabel","strengthPresets","strengthInput","operationContainer","operationLabel","operationToggle","addBtn","subtractBtn","flattenContainer","flattenLabel","flattenInput","handleKeyPress","brushId","isSelected","btn","strengthInputs","initBrushPalette","existing","cleanup","setupGUI","gui","DAT.GUI","simcontrols","terrainParameters","erosionpara","RainErosionPara","thermalerosionpara","terraineditor","brushTypeController","flattenTargetHeightController","brushSizeController","brushStrengthController","brushOperationController","brushPalette","brushType","size","strength","operation","renderingpara","renderingparalightpos","INITIAL_STEP_SIZE","REFINEMENT_STEP_SIZE","ULTRA_REFINEMENT_STEP_SIZE","TERRAIN_PROXIMITY_THRESHOLD","MAX_RAY_DISTANCE","MAX_ITERATIONS","BINARY_SEARCH_ITERATIONS","BINARY_SEARCH_CONVERGENCE_THRESHOLD","getHeightAt","y","simres","buffer","clampedX","index","sampleHeightBilinear","uv","clampedU","clampedV","x0","y0","x1","y1","fx","fy","h00","h10","h01","h11","h0","h1","rayCast","ro","rd","HightMapCpuBuf","out","cur","prev","curTexSpace","vec2.create","rdscaled","binarySearchStart","binarySearchEnd","binarySearchMid","step","totalDistance","foundHit","hitPosition","startTexSpace","startTerrainHeight","terrainHeight","bestPosition","bestDistanceToSurface","vec3.distance","vec3.lerp","midTexSpace","midTerrainHeight","distanceToSurface","finalTexSpace","finalTerrainHeight","threshold","distanceToTerrain","rayCastBVH","rayOrigin","rayDirection","bvh","geometry","origin","direction","isNearlyHorizontal","hit","maxDistance","offsetOrigin","offsetRay","Ray","ray","worldX","worldZ","u","v","hitInfo","getTriangleHitPointInfo","simresolution","shadowMapResolution","SimFramecnt","TerrainGeometryDirty","PauseGeneration","HightMapBufCounter","incrementHightMapBufCounter","resetHightMapBufCounter","MaxHightMapBufCounter","ActiveHeightmapReadInterval","HoverHeightmapReadInterval","getResolutionScale","currentPixels","shouldReadHeightmap","brushPressed","brushVisible","resizeHightMapCpuBuf","newRes","lastX","lastY","setSimRes","setLastMousePosition","setPauseGeneration","setSimFramecnt","incrementSimFramecnt","setTerrainGeometryDirty","terrainGeometry","terrainBVH","setTerrainGeometry","setTerrainBVH","originalBrushOperation","getOriginalBrushOperation","setOriginalBrushOperation","handleBrushMouseDown","context","controlsConfig","brushTypeNum","secondaryModifier","normalizedX","normalizedY","invViewProj","mat4.invert","mousePoint","vec4.create","mousePointEnd","vec4.transformMat4","rayDir","freshPos","heightmapPos","brushUV","vec2.fromValues","heightValue","vec2.clone","vec2.equals","invertModifier","handleBrushMouseUp","updateBrushState","pos","MAX_WATER_SOURCES","waterSources","addWaterSource","newSource","removeNearestWaterSource","nearestIndex","nearestDist","dist","vec2.distance","clearAllWaterSources","getWaterSourceCount","createEventHandlers","onKeyDown","action","modifierPressed","onKeyUp","original","onMouseDown","brushContext","result","onMouseUp","createTerrainGeometry","heightMapBuffer","BufferGeometry","numVertices","positions","uvs","indices","worldHeight","worldY","topLeft","topRight","bottomLeft","bottomRight","BufferAttribute","gl_context","frame_buffer","shadowMap_frame_buffer","deferred_frame_buffer","render_buffer","shadowMap_render_buffer","deferred_render_buffer","shadowMap_tex","scene_depth_tex","bilateral_filter_horizontal_tex","bilateral_filter_vertical_tex","color_pass_tex","color_pass_reflection_tex","scatter_pass_tex","read_terrain_tex","write_terrain_tex","read_flux_tex","write_flux_tex","read_terrain_flux_tex","write_terrain_flux_tex","read_maxslippage_tex","write_maxslippage_tex","read_vel_tex","write_vel_tex","read_sediment_tex","write_sediment_tex","terrain_nor","read_sediment_blend","write_sediment_blend","sediment_advect_a","sediment_advect_b","heightmap_tex","LE_create_texture","w","h","samplingType","new_tex","LE_recreate_texture","texHandle","LE_create_screen_texture","resizeTextures4Simulation","simulationTextureSampler","setupFramebufferandtextures","resizeScreenTextures","setHeightMapTexture","tex","getHeightMapTexture","swapTerrainTextures","tmp","swapFluxTextures","swapVelTextures","swapSedimentTextures","swapSedimentBlendTextures","swapMaxSlippageTextures","swapTerrainFluxTextures","swapBilateralFilterTextures","createHeightMapLoader","loadHeightMap","file","reader","img","ctx","imageData","heightData","maxHeight","clearHeightMap","uniformLocationCache","getCachedUniformLocation","name","progCache","loc","Render2Texture","renderer","shader","cur_texture","square","noiseterrain","status","setTerrainType","t","setTerrainDebug","setTerrainScale","setTerrainHeight","setRndTerrain","setBrushType","setBrushSize","setBrushStrength","setBrushOperation","setBrushPos","setBrushPressed","setSimres","res","setPipeLen","len","setKs","k","setKc","setKd","setRockErosionResistance","resistance","setTimestep","setPipeArea","activeProgram","Shader","type","source","ShaderProgram","shaders","modelinvtr","mat4.transpose","vp","f","TerrainUniforms.setTerrainType","BrushUniforms.setBrushType","BrushUniforms.setBrushSize","BrushUniforms.setBrushStrength","BrushUniforms.setBrushOperation","BrushUniforms.setBrushPos","BrushUniforms.setBrushPressed","count","sizes","strengths","TerrainUniforms.setTerrainDebug","TerrainUniforms.setTerrainScale","TerrainUniforms.setTerrainHeight","dir","TerrainUniforms.setRndTerrain","eye","ref","SimulationUniforms.setPipeLen","SimulationUniforms.setKs","SimulationUniforms.setKc","SimulationUniforms.setTimestep","SimulationUniforms.setPipeArea","SimulationUniforms.setKd","SimulationUniforms.setRockErosionResistance","SimulationUniforms.setSimres","d","terrainVert","terrainFrag","flatVert","flatFrag","quadVert","initialFrag","flowFrag","alterwaterhightFrag","sedimentFrag","sediadvectFrag","maccormackFrag","rainFrag","evaFrag","averageFrag","cleanFrag","waterVert","waterFrag","thermalterrainfluxFrag","thermalapplyFrag","maxslippageheightFrag","shadowmapVert","shadowmapFrag","sceneDepthFrag","combineFrag","bilateralBlurFrag","veladvectFrag","createShaders","lambert","flat","flow","waterhight","sediment","sediadvect","macCormack","rains","evaporation","average","clean","water","thermalterrainflux","thermalapply","maxslippageheight","shadowMapShader","sceneDepthShader","combinedShader","bilateralBlur","veladvect","loadScene","StartGeneration","Reset","setTerrainRandom","plane","waterPlane","SimulatePerStep","sedi","advect","eva","ave","SimulationStep","curstep","evapo","normalizeMousePosition","clientX","clientY","main","stats","Stats","brushUsesLeftClickForCamera","eventHandlers","isCanvas","scrollModifier","sizeChange","newSize","extensions","timer","cleanUpTextures","reusableViewProj","reusableInvViewProj","reusableMousePoint","reusableMousePointEnd","reusableDir","reusableRo","reusablePos","reusableLightViewMat","reusableLightProjMat","reusableLightPos","reusableSpawnPos","reusableSourcePositions","reusableSourceSizes","reusableSourceStrengths","lastBrushPressed","lastReadMouseX","lastReadMouseY","tick","normalizedMouse","screenMouseX","screenMouseY","hasData","sampleCount","idx","newGeometry","MeshBVH","SAH","justPressed","mouseMoved","mat4.ortho","PingUniform","norUniform","sediUniform","velUniform","fluxUniform","terrainfluxUniform","terrainslippageUniform","NumBlurPass"],"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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"}